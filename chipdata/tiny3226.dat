;        .DAT sections
;==========================================================================
;
;  Built by GCBASIC converter
;  XC8 processor include for the chip shown below
;
; Microchip IDE version 6.20
; C:\Users\admin\.mchp_packs\index.idx
; C:\Users\admin\.mchp_packs\Microchip\ATtiny_DFP\3.1.260\avrasm\inc\tn3226def.inc
; d:avr chipdata.csv
; C:\Users\admin\.mchp_packs\Microchip\ATtiny_DFP\3.1.260\edc\ATTINY3226.PIC
; 
;
; Registers not processed: RTC_CMP,SREG,CPU_SPL, CPU_SPH 
; Bits not processed: CPU_RAMPZ
;==========================================================================
;==========================================================================
;
;       Register Definitions
;
;==========================================================================

;----- Register Files -----------------------------------------------------

[ChipData]
';All items in the ChipData section are available to user programs as constants
';The constants have the prefix of CHIP: See the details below

'This constant is exposed as CHIPWORDS
Prog=16384

'This constant is exposed as CHIPEEPROM
EEPROM=256

'This constant is exposed as CHIPRAM
RAM=3072

'This constant is exposed as CHIPIO - sourced from `d:avr chipdata.csv`
I/O=18

'This constant is exposed as CHIPADC - sourced from `d:avr chipdata.csv`
ADC=15
ADCPPORTMAP=AVRDxADC15Type4Lookup

'This constant is exposed as CHIPMhz
MaxMHz=20
'This constant is exposed with only the first parameter (if more than one)
IntOsc=20, 10, 5, 2.5, 1.25, 0.625, 0.3125, 3.3333333, 2, 1.6666667, 0.8333333, 0.4166667

'This constant is exposed as CHIPPINS - sourced from `d:avr chipdata.csv`
Pins=20

'This constant is exposed as CHIPUSART - sourced from `d:avr chipdata.csv`
USART=2

'These USART constants are exposed with the prefix of CHIP - sourced from `d:avr chipdata.csv`
USART0TXDefault=PORTB.2
USART0RXDefault=PORTB.3

'This constant is exposed as CHIPFamily - sourced from `d:avr chipdata.csv`
Family=140

'This constant is exposed as CHIPCONFWORDS
ConfigWords=0

'This constant is exposed as CHIPGPR
GPR=32

'This constant is exposed as CHIPMAXADDRESS. This value is the maximum address of the internal SRAM.  SRAM is used for data storage and stack.
MaxAddress=16384

'This constant is exposed as CHIPHARDWAREMULT
HardwareMult=y

'This constant is exposed as CHIPAVRFAMILY - sourced from `d:avr chipdata.csv`
AVRFamily=tinyAVRSeries2

'This constant is exposed as CHIPAVRGCC - sourced from `d:avr chipdata.csv`
AVRGCC=avrxmega3

'This constant is exposed as CHIPAVRDX - sourced from `d:avr chipdata.csv`
AVRDX=1

'DFP version and family
DFPFamily=ATtiny_DFP
DFPVersion=3.1.260

'For details of microcontroller specifications see the microcontroller datasheet
_DATAMEM_START = 0x0000
_DATAMEM_SIZE = 0x10000
_DATAMEM_END = (0x0000 + 0x10000 - 1)
_IO_START = 0x0000
_IO_SIZE = 0x1100
_IO_END = (0x0000 + 0x1100 - 1)
_SIGNATURES_START = 0x1100
_SIGNATURES_SIZE = 0x0003
_SIGNATURES_END = (0x1100 + 0x0003 - 1)
_SIGNATURES_PAGE_SIZE = 0x80
_PROD_SIGNATURES_START = 0x1103
_PROD_SIGNATURES_SIZE = 0x003D
_PROD_SIGNATURES_END = (0x1103 + 0x003D - 1)
_PROD_SIGNATURES_PAGE_SIZE = 0x80
_FUSES_START = 0x1280
_FUSES_SIZE = 0x000A
_FUSES_END = (0x1280 + 0x000A - 1)
_FUSES_PAGE_SIZE = 0x20
_LOCKBITS_START = 0x128A
_LOCKBITS_SIZE = 0x0001
_LOCKBITS_END = (0x128A + 0x0001 - 1)
_LOCKBITS_PAGE_SIZE = 0x20
_USER_SIGNATURES_START = 0x1300
_USER_SIGNATURES_SIZE = 0x0020
_USER_SIGNATURES_END = (0x1300 + 0x0020 - 1)
_USER_SIGNATURES_PAGE_SIZE = 0x20
_EEPROM_START = 0x1400
_EEPROM_SIZE = 0x0100
_EEPROM_END = (0x1400 + 0x0100 - 1)
_EEPROM_PAGE_SIZE = 0x40
_INTERNAL_SRAM_START = 0x3400
_INTERNAL_SRAM_SIZE = 0x0C00
_INTERNAL_SRAM_END = (0x3400 + 0x0C00 - 1)
_MAPPED_PROGMEM_START = 0x8000
_MAPPED_PROGMEM_SIZE = 0x8000
_MAPPED_PROGMEM_END = (0x8000 + 0x8000 - 1)
_MAPPED_PROGMEM_PAGE_SIZE = 0x80
_PROGMEM_START = 0x0000
_PROGMEM_SIZE = 0x8000
_PROGMEM_END = (0x0000 + 0x8000 - 1)
_PROGMEM_PAGE_SIZE = 0x80

[Pointers]
'This section are the registers used by compilers
XL:26
XH:27
YL:28
YH:29
ZL:30
ZH:31

[Interrupts]
'For specific details of the interrupts see the microcontroller datasheet
'The first parameter is the GCBASIC identifier used in user code to expose the specific interrupt
'
' Specific to AVRDX chips - an explaination - the entries
' GCBASIC friendly name:Source Interrupt Name,vector,register.bit to enable the interrupt,register.bit or !register.bit to clear the interrupt
'   name     interrupt   #    enable reg.bit(s)                  clear reg.bit(s)
' NMIfromCRC:CRCSCAN_NMI,2,CRCSCAN_CTRLA.CRCSCAN_NMIEN_bp,!CRCSCAN_CTRLA.CRCSCAN_RESET_bp
'
' The enable reg.bit(s) can be a single bit or bits will be used to set the register
' The clear reg.bit(s) can be a single bit or bits will be used to set the register
' ! (eqautes to NOT ) inverts the bit
'
; CRCSCAN interrupt vectors
	NMIfromCRC:CRCSCAN_NMI,2,CRCSCAN_CTRLA.CRCSCAN_NMIEN_bp,!CRCSCAN_CTRLA.CRCSCAN_RESET_bp
; BOD interrupt vectors
	BOD_VLM:BOD_VLM,4,BOD_INTCTRL.BOD_VLMIE_bp,!BOD_INTFLAGS.BOD_VLMIF_bp
; RTC interrupt vectors
	RTCOverflow:RTC_CNT,6,RTC_INTCTRL.RTC_OVF_bp,RTC_INTFLAGS.RTC_OVF_bp
	PITOverflow:RTC_PIT,8,RTC_PITINTCTRL.RTC_PI_bp,RTC_PITINTFLAGS.RTC_PI_bp
; CCL interrupt vectors
	CCL_CCL:CCL_CCL,10,CCL_INTCTRL0.CCL_INTMODE0_gp,!CCL_INTFLAGS.CCL_INT_gp
; PORTA interrupt vectors
	PortAChange:PORTA_PORT,12, PORTA_PORTCTRL.PORT_INT_gm,PORTA_INTFLAGS.PORT_INT_gm
; PORTB interrupt vectors
	PORTBChange:PORTB_PORT,14,PORTB_PORTCTRL.PORT_INT_gm,PORTB_INTFLAGS.PORT_INT_gm
; TCA0 interrupt vectors
	Timer0Overflow:TCA0_LUNF,16,TCA0_SINGLE_INTCTRL.TCA_SINGLE_OVF_bp,!TCA0_SINGLE_INTFLAGS.TCA_SINGLE_OVF_bp
	Timer0Underflow:TCA0_HUNF,18,TCA_SPLIT_HUNF_bp,!TCA0_SPLIT_INTFLAGS.TCA_SPLIT_HUNF_bp 
	Timer0Match0:TCA0_CMP0,20,TCA0_SINGLE_INTCTRL.TCA_SINGLE_CMP0_bp,TCA0_SINGLE_INTFLAGS.TCA_SINGLE_CMP0_bp
	Timer0Match1:TCA0_CMP1,22,TCA0_SINGLE_INTCTRL.TCA_SINGLE_CMP1_bp,TCA0_SINGLE_INTFLAGS.TCA_SINGLE_CMP1_bp
	Timer0Match2:TCA0_CMP2,24,TCA0_SINGLE_INTCTRL.TCA_SINGLE_CMP2_bp,TCA0_SINGLE_INTFLAGS.TCA_SINGLE_CMP0_bp
; TCB0 interrupt vectors
	Timer0Capture:TCB0_INT,26,TCB0_INTCTRL.TCB_CAPT_bp,TCB0_INTFLAGS.TCB_CAPT_bp
; TWI0 interrupt vectors
	TWISlaveReady:TWI0_TWIS,28,TWI0_SCTRLA.TWI_DIEN_bp ,TWI0_SSTATUS.TWI_DIF_bp
	TWIMasterReady:TWI0_TWIM,30,TWI0_MCTRLA.TWI_RIEN_bp,TWI0_MSTATUS.TWI_RIF_bp
; SPI0 interrupt vectors
	SPIReady:SPI0_INT,32,SPI0_INTCTRL.SPI_IE_bp,SPI0_INTFLAGS.SPI_IF_bp
; USART0 interrupt vectors
	Usart0RXReady:USART0_RXC,34, USART0_CTRLA.USART_RXCIE_bp, USART0_STATUS.USART_RXCIF_bp
	UsartTX0Ready:USART0_DRE,36,USART0_CTRLA.USART_DREIE_bp,USART0_STATUS.USART_DREIF_bp
	UsartTX0Sent:USART0_TXC,38,USART0_CTRLA.USART_TXCIE_bp,USART0_STATUS.USART_TXCIF_bp
; AC0 interrupt vectors
	AC0Compare:AC0_AC,40,AC0_INTCTRL.AC_CMP_bp,AC0_STATUS.AC_CMP_bp 
; ADC0 interrupt vectors
		ADC0_ERROR:ADC0_ERROR,42,,
		ADC0_RESRDY:ADC0_RESRDY,44,,
		ADC0_SAMPRDY:ADC0_SAMPRDY,46,,
; PORTC interrupt vectors
	PORTCChange:PORTC_PORT,48,PORTC_PORTCTRL.PORT_INT_gm,PORTC_INTFLAGS.PORT_INT_gm
; TCB1 interrupt vectors
	Timer1Capture:TCB1_INT,50,TCB1_INTCTRL.TCB_CAPT_bp,TCB1_INTFLAGS.TCB_CAPT_bp
; USART1 interrupt vectors
	Usart1RXReady:USART1_RXC,52,USART1_CTRLA.USART_RXCIE_bp,USART1_STATUS.USART_RXCIF_bp
	UsartTX1Ready:USART1_DRE,54,USART1_CTRLA.USART_DREIE_bp,USART1_STATUS.USART_DREIF_bp
	UsartTX1Sent:USART1_TXC,56,USART1_CTRLA.USART_TXCIE_bp,USART1_STATUS.USART_TXCIF_bp
; NVMCTRL interrupt vectors
	;EEREADY Interrupt Flag.  This flag is set continuously as long as the EEPROM is not busy. This flag is cleared by writing a '1' to it.
	NVMCTRLReady:NVMCTRL_EE,58,NVMCTRL_INTCTRL.NVMCTRL_EEREADY_bp ,NVMCTRL_INTFLAGS.NVMCTRL_EEREADY_bp

[AVRAlias]
  'This section is for the AVRDX support
  'The aliasing is megaAVR register = value = AVRDX register
  ' example:          ALIAS_PORTA_DIR = 0 = DDRA
  '
 'Format is Strict: 
  ' There must be two entries per alias, the order is not importand, the relatiionship as shown above is critical.
  ' The value is NOT a register address value. The value MUST be unique
  ' The assignment must be an equal sign `=`
   '
 'How does this all work?
  ' The compiler will look up a megaAVR register ( ignoring any register.bits), and, using the returned number, lookup the AVRDX alias.
  ' DDRA = 0, lookup the AVRDX alias of 0, returns ALIAS_PORTA_DIR
  ' the compiler strips off the `ALIAS_`PORTA_DIR prefix as the register to be used.
  '
 'A deeper dive.
  ' The compiler treats this list of AVRAlias(es) just like the [register] section of this file.
  ' The compiler loads these AVRAlias(es) but with the attribute of .ALIAS set (true).
  ' This means, using the example above, that DDRA is not a real register and it is has the .ALIAS attribute set. 
  ' So, the compiler knows that DDRA for this specific chip and all AVRDX chips that DDRA is actually to be transformed to an AVRDX set of instructiions.

'PortA
ALIAS_PORTA_DIR=0                                      ; 0000             
DDRA=0                                          ; 0000 alias
ALIAS_PORTA_OUT=1                                      ; 0001             
PORTA=1                                         ; 0001 alias         
ALIAS_PORTA_IN=2                                       ; 0002   
PINA=2                                          ; 0002 alias

'PortB
ALIAS_PORTB_DIR=4                                      ; 0004            
DDRB=4                                          ; 0004 alias
ALIAS_PORTB_OUT=5                                      ; 0005              
PORTB=5                                         ; 0005 alias
ALIAS_PORTB_IN=6                                       ; 0006
PINB=6                                          ; 0006 alias

'PortC
ALIAS_PORTC_DIR=8                                      ; 0008          
DDRC=8                                          ; 0008 alias
ALIAS_PORTC_OUT=9                                      ; 0009
PORTC=9                                         ; 0009 alias
ALIAS_PORTC_IN=10                                      ; 000A
PINC=10                                         ; 000A alias

'Additional Aliases are required
ALIAS_CPU_SPL=61    
CPU_SPL=61    
ALIAS_CPU_SPH=62                                                                                     
CPU_SPH=62 
'Additional lock register alias
ALIAS_CPU_CCP=52                                  ; 0034
CPU_CCP=52                                        ; 0034
'Required register
SREG=63                                           ; 003F alias
ALIAS_SREG=63

[AVRMASKS]
'For details of the see the microcontroller datasheet
'

  PIN0_bm =  1                  ; port.pin bit mask
  PIN1_bm =  2                  ; port.pin bit mask
  PIN2_bm =  4                  ; port.pin bit mask
  PIN3_bm =  8                  ; port.pin bit mask
  PIN4_bm =  16                 ; port.pin bit mask
  PIN5_bm =  32                 ; port.pin bit mask
  PIN6_bm =  64                 ; port.pin bit mask
  PIN7_bm =  128                ; port.pin bit mask


  PIN0_bp =  0                  ; port.pin bit position
  PIN1_bp =  1                  ; port.pin bit position
  PIN2_bp =  2                  ; port.pin bit position
  PIN3_bp =  3                  ; port.pin bit position
  PIN4_bp =  4                  ; port.pin bit position
  PIN5_bp =  5                  ; port.pin bit position
  PIN6_bp =  6                  ; port.pin bit position
  PIN7_bp =  7                  ; port.pin bit position

  
  
  ;*************************************************************************
  ;** AC - Analog Comparator
  ;*************************************************************************
  
  ; AC_CTRLA masks
  AC_ENABLE_bm = 0x01                 ; Enable bit mask
  AC_ENABLE_bp = 0                    ; Enable bit position
  AC_HYSMODE_gm = 0x06                ; Hysteresis Mode group mask
  AC_HYSMODE_gp = 1                   ; Hysteresis Mode group position
  AC_HYSMODE_0_bm = (1<<1)            ; Hysteresis Mode bit 0 mask
  AC_HYSMODE_0_bp = 1                 ; Hysteresis Mode bit 0 position
  AC_HYSMODE_1_bm = (1<<2)            ; Hysteresis Mode bit 1 mask
  AC_HYSMODE_1_bp = 2                 ; Hysteresis Mode bit 1 position
  AC_LPMODE_bm = 0x08                 ; Low Power Mode bit mask
  AC_LPMODE_bp = 3                    ; Low Power Mode bit position
  AC_INTMODE_gm = 0x30                ; Interrupt Mode group mask
  AC_INTMODE_gp = 4                   ; Interrupt Mode group position
  AC_INTMODE_0_bm = (1<<4)            ; Interrupt Mode bit 0 mask
  AC_INTMODE_0_bp = 4                 ; Interrupt Mode bit 0 position
  AC_INTMODE_1_bm = (1<<5)            ; Interrupt Mode bit 1 mask
  AC_INTMODE_1_bp = 5                 ; Interrupt Mode bit 1 position
  AC_OUTEN_bm = 0x40                  ; Output Buffer Enable bit mask
  AC_OUTEN_bp = 6                     ; Output Buffer Enable bit position
  AC_RUNSTDBY_bm = 0x80               ; Run in Standby Mode bit mask
  AC_RUNSTDBY_bp = 7                  ; Run in Standby Mode bit position
  
  ; AC_MUXCTRLA masks
  AC_MUXNEG_gm = 0x03                 ; Negative Input MUX Selection group mask
  AC_MUXNEG_gp = 0                    ; Negative Input MUX Selection group position
  AC_MUXNEG_0_bm = (1<<0)             ; Negative Input MUX Selection bit 0 mask
  AC_MUXNEG_0_bp = 0                  ; Negative Input MUX Selection bit 0 position
  AC_MUXNEG_1_bm = (1<<1)             ; Negative Input MUX Selection bit 1 mask
  AC_MUXNEG_1_bp = 1                  ; Negative Input MUX Selection bit 1 position
  AC_MUXPOS_gm = 0x18                 ; Positive Input MUX Selection group mask
  AC_MUXPOS_gp = 3                    ; Positive Input MUX Selection group position
  AC_MUXPOS_0_bm = (1<<3)             ; Positive Input MUX Selection bit 0 mask
  AC_MUXPOS_0_bp = 3                  ; Positive Input MUX Selection bit 0 position
  AC_MUXPOS_1_bm = (1<<4)             ; Positive Input MUX Selection bit 1 mask
  AC_MUXPOS_1_bp = 4                  ; Positive Input MUX Selection bit 1 position
  AC_INVERT_bm = 0x80                 ; Invert AC Output bit mask
  AC_INVERT_bp = 7                    ; Invert AC Output bit position
  
  ; AC_DACREF masks
  AC_DACREF_gm = 0xFF                 ; DACREF Data Value group mask
  AC_DACREF_gp = 0                    ; DACREF Data Value group position
  AC_DACREF_0_bm = (1<<0)             ; DACREF Data Value bit 0 mask
  AC_DACREF_0_bp = 0                  ; DACREF Data Value bit 0 position
  AC_DACREF_1_bm = (1<<1)             ; DACREF Data Value bit 1 mask
  AC_DACREF_1_bp = 1                  ; DACREF Data Value bit 1 position
  AC_DACREF_2_bm = (1<<2)             ; DACREF Data Value bit 2 mask
  AC_DACREF_2_bp = 2                  ; DACREF Data Value bit 2 position
  AC_DACREF_3_bm = (1<<3)             ; DACREF Data Value bit 3 mask
  AC_DACREF_3_bp = 3                  ; DACREF Data Value bit 3 position
  AC_DACREF_4_bm = (1<<4)             ; DACREF Data Value bit 4 mask
  AC_DACREF_4_bp = 4                  ; DACREF Data Value bit 4 position
  AC_DACREF_5_bm = (1<<5)             ; DACREF Data Value bit 5 mask
  AC_DACREF_5_bp = 5                  ; DACREF Data Value bit 5 position
  AC_DACREF_6_bm = (1<<6)             ; DACREF Data Value bit 6 mask
  AC_DACREF_6_bp = 6                  ; DACREF Data Value bit 6 position
  AC_DACREF_7_bm = (1<<7)             ; DACREF Data Value bit 7 mask
  AC_DACREF_7_bp = 7                  ; DACREF Data Value bit 7 position
  
  ; AC_INTCTRL masks
  AC_CMP_bm = 0x01                    ; Analog Comparator 0 Interrupt Enable bit mask
  AC_CMP_bp = 0                       ; Analog Comparator 0 Interrupt Enable bit position
  
  ; AC_STATUS masks
  ; Masks for AC_CMP already defined
  AC_STATE_bm = 0x10                  ; Analog Comparator State bit mask
  AC_STATE_bp = 4                     ; Analog Comparator State bit position
  
  ; Hysteresis Mode select
  AC_HYSMODE_OFF_gc = (0x00<<1)       ; No hysteresis
  AC_HYSMODE_10mV_gc = (0x01<<1)      ; 10mV hysteresis
  AC_HYSMODE_25mV_gc = (0x02<<1)      ; 25mV hysteresis
  AC_HYSMODE_50mV_gc = (0x03<<1)      ; 50mV hysteresis
  
  ; Interrupt Mode select
  AC_INTMODE_BOTHEDGE_gc = (0x00<<4)  ; Both Edge
  AC_INTMODE_NEGEDGE_gc = (0x02<<4)   ; Negative Edge
  AC_INTMODE_POSEDGE_gc = (0x03<<4)   ; Positive Edge
  
  ; Low Power Mode select
  AC_LPMODE_DIS_gc = (0x00<<3)        ; Low power mode disabled
  AC_LPMODE_EN_gc = (0x01<<3)         ; Low power mode enabled
  
  ; Negative Input MUX Selection
  AC_MUXNEG_AINN0_gc = (0x00<<0)      ; Negative Pin 0
  AC_MUXNEG_AINN1_gc = (0x01<<0)      ; Negative Pin 1
  AC_MUXNEG_AINN2_gc = (0x02<<0)      ; Negative Pin 2
  AC_MUXNEG_DACREF_gc = (0x03<<0)     ; DAC Voltage Reference
  
  ; Positive Input MUX Selection
  AC_MUXPOS_AINP0_gc = (0x00<<3)      ; Positive Pin 0
  AC_MUXPOS_AINP1_gc = (0x01<<3)      ; Positive Pin 1
  AC_MUXPOS_AINP2_gc = (0x02<<3)      ; Positive Pin 2
  
  
  ;*************************************************************************
  ;** ADC - Analog to Digital Converter
  ;*************************************************************************
  
  ; ADC_CTRLA masks
  ADC_ENABLE_bm = 0x01                ; ADC Enable bit mask
  ADC_ENABLE_bp = 0                   ; ADC Enable bit position
  ADC_LOWLAT_bm = 0x20                ; ADC Low latency mode bit mask
  ADC_LOWLAT_bp = 5                   ; ADC Low latency mode bit position
  ADC_RUNSTDBY_bm = 0x80              ; Run standby mode bit mask
  ADC_RUNSTDBY_bp = 7                 ; Run standby mode bit position
  
  ; ADC_CTRLB masks
  ADC_PRESC_gm = 0x0F                 ; Prescaler Value group mask
  ADC_PRESC_gp = 0                    ; Prescaler Value group position
  ADC_PRESC_0_bm = (1<<0)             ; Prescaler Value bit 0 mask
  ADC_PRESC_0_bp = 0                  ; Prescaler Value bit 0 position
  ADC_PRESC_1_bm = (1<<1)             ; Prescaler Value bit 1 mask
  ADC_PRESC_1_bp = 1                  ; Prescaler Value bit 1 position
  ADC_PRESC_2_bm = (1<<2)             ; Prescaler Value bit 2 mask
  ADC_PRESC_2_bp = 2                  ; Prescaler Value bit 2 position
  ADC_PRESC_3_bm = (1<<3)             ; Prescaler Value bit 3 mask
  ADC_PRESC_3_bp = 3                  ; Prescaler Value bit 3 position
  
  ; ADC_CTRLC masks
  ADC_REFSEL_gm = 0x07                ; Reference select group mask
  ADC_REFSEL_gp = 0                   ; Reference select group position
  ADC_REFSEL_0_bm = (1<<0)            ; Reference select bit 0 mask
  ADC_REFSEL_0_bp = 0                 ; Reference select bit 0 position
  ADC_REFSEL_1_bm = (1<<1)            ; Reference select bit 1 mask
  ADC_REFSEL_1_bp = 1                 ; Reference select bit 1 position
  ADC_REFSEL_2_bm = (1<<2)            ; Reference select bit 2 mask
  ADC_REFSEL_2_bp = 2                 ; Reference select bit 2 position
  ADC_TIMEBASE_gm = 0xF8              ; Reference Selection group mask
  ADC_TIMEBASE_gp = 3                 ; Reference Selection group position
  ADC_TIMEBASE_0_bm = (1<<3)          ; Reference Selection bit 0 mask
  ADC_TIMEBASE_0_bp = 3               ; Reference Selection bit 0 position
  ADC_TIMEBASE_1_bm = (1<<4)          ; Reference Selection bit 1 mask
  ADC_TIMEBASE_1_bp = 4               ; Reference Selection bit 1 position
  ADC_TIMEBASE_2_bm = (1<<5)          ; Reference Selection bit 2 mask
  ADC_TIMEBASE_2_bp = 5               ; Reference Selection bit 2 position
  ADC_TIMEBASE_3_bm = (1<<6)          ; Reference Selection bit 3 mask
  ADC_TIMEBASE_3_bp = 6               ; Reference Selection bit 3 position
  ADC_TIMEBASE_4_bm = (1<<7)          ; Reference Selection bit 4 mask
  ADC_TIMEBASE_4_bp = 7               ; Reference Selection bit 4 position
  
  ; ADC_CTRLD masks
  ADC_WINCM_gm = 0x07                 ; Window Comparator Mode group mask
  ADC_WINCM_gp = 0                    ; Window Comparator Mode group position
  ADC_WINCM_0_bm = (1<<0)             ; Window Comparator Mode bit 0 mask
  ADC_WINCM_0_bp = 0                  ; Window Comparator Mode bit 0 position
  ADC_WINCM_1_bm = (1<<1)             ; Window Comparator Mode bit 1 mask
  ADC_WINCM_1_bp = 1                  ; Window Comparator Mode bit 1 position
  ADC_WINCM_2_bm = (1<<2)             ; Window Comparator Mode bit 2 mask
  ADC_WINCM_2_bp = 2                  ; Window Comparator Mode bit 2 position
  ADC_WINSRC_bm = 0x08                ; Window Mode Source bit mask
  ADC_WINSRC_bp = 3                   ; Window Mode Source bit position
  
  ; ADC_INTCTRL masks
  ADC_RESRDY_bm = 0x01                ; Result Ready Interrupt Enable bit mask
  ADC_RESRDY_bp = 0                   ; Result Ready Interrupt Enable bit position
  ADC_SAMPRDY_bm = 0x02               ; Sample Ready Interrupt Enable bit mask
  ADC_SAMPRDY_bp = 1                  ; Sample Ready Interrupt Enable bit position
  ADC_WCMP_bm = 0x04                  ; Window Comparator Interrupt Enable bit mask
  ADC_WCMP_bp = 2                     ; Window Comparator Interrupt Enable bit position
  ADC_RESOVR_bm = 0x08                ; Result Overwritten Interrupt Enable bit mask
  ADC_RESOVR_bp = 3                   ; Result Overwritten Interrupt Enable bit position
  ADC_SAMPOVR_bm = 0x10               ; Sample Overwritten Interrupt Enable bit mask
  ADC_SAMPOVR_bp = 4                  ; Sample Overwritten Interrupt Enable bit position
  ADC_TRIGOVR_bm = 0x20               ; Trigger Overrun Interrupt Enable bit mask
  ADC_TRIGOVR_bp = 5                  ; Trigger Overrun Interrupt Enable bit position
  
  ; ADC_INTFLAGS masks
  ; Masks for ADC_RESRDY already defined
  ; Masks for ADC_SAMPRDY already defined
  ; Masks for ADC_WCMP already defined
  ; Masks for ADC_RESOVR already defined
  ; Masks for ADC_SAMPOVR already defined
  ; Masks for ADC_TRIGOVR already defined
  
  ; ADC_STATUS masks
  ADC_ADCBUSY_bm = 0x01               ; ADC Busy bit mask
  ADC_ADCBUSY_bp = 0                  ; ADC Busy bit position
  
  ; ADC_DBGCTRL masks
  ADC_DBGRUN_bm = 0x01                ; Debug run bit mask
  ADC_DBGRUN_bp = 0                   ; Debug run bit position
  
  ; ADC_CTRLE masks
  ADC_SAMPDUR_gm = 0xFF               ; Sampling time group mask
  ADC_SAMPDUR_gp = 0                  ; Sampling time group position
  ADC_SAMPDUR_0_bm = (1<<0)           ; Sampling time bit 0 mask
  ADC_SAMPDUR_0_bp = 0                ; Sampling time bit 0 position
  ADC_SAMPDUR_1_bm = (1<<1)           ; Sampling time bit 1 mask
  ADC_SAMPDUR_1_bp = 1                ; Sampling time bit 1 position
  ADC_SAMPDUR_2_bm = (1<<2)           ; Sampling time bit 2 mask
  ADC_SAMPDUR_2_bp = 2                ; Sampling time bit 2 position
  ADC_SAMPDUR_3_bm = (1<<3)           ; Sampling time bit 3 mask
  ADC_SAMPDUR_3_bp = 3                ; Sampling time bit 3 position
  ADC_SAMPDUR_4_bm = (1<<4)           ; Sampling time bit 4 mask
  ADC_SAMPDUR_4_bp = 4                ; Sampling time bit 4 position
  ADC_SAMPDUR_5_bm = (1<<5)           ; Sampling time bit 5 mask
  ADC_SAMPDUR_5_bp = 5                ; Sampling time bit 5 position
  ADC_SAMPDUR_6_bm = (1<<6)           ; Sampling time bit 6 mask
  ADC_SAMPDUR_6_bp = 6                ; Sampling time bit 6 position
  ADC_SAMPDUR_7_bm = (1<<7)           ; Sampling time bit 7 mask
  ADC_SAMPDUR_7_bp = 7                ; Sampling time bit 7 position
  
  ; ADC_CTRLF masks
  ADC_SAMPNUM_gm = 0x0F               ; Sample numbers group mask
  ADC_SAMPNUM_gp = 0                  ; Sample numbers group position
  ADC_SAMPNUM_0_bm = (1<<0)           ; Sample numbers bit 0 mask
  ADC_SAMPNUM_0_bp = 0                ; Sample numbers bit 0 position
  ADC_SAMPNUM_1_bm = (1<<1)           ; Sample numbers bit 1 mask
  ADC_SAMPNUM_1_bp = 1                ; Sample numbers bit 1 position
  ADC_SAMPNUM_2_bm = (1<<2)           ; Sample numbers bit 2 mask
  ADC_SAMPNUM_2_bp = 2                ; Sample numbers bit 2 position
  ADC_SAMPNUM_3_bm = (1<<3)           ; Sample numbers bit 3 mask
  ADC_SAMPNUM_3_bp = 3                ; Sample numbers bit 3 position
  ADC_LEFTADJ_bm = 0x10               ; Left adjust bit mask
  ADC_LEFTADJ_bp = 4                  ; Left adjust bit position
  ADC_FREERUN_bm = 0x20               ; Free running mode bit mask
  ADC_FREERUN_bp = 5                  ; Free running mode bit position
  
  ; ADC_COMMAND masks
  ADC_START_gm = 0x07                 ; Start command group mask
  ADC_START_gp = 0                    ; Start command group position
  ADC_START_0_bm = (1<<0)             ; Start command bit 0 mask
  ADC_START_0_bp = 0                  ; Start command bit 0 position
  ADC_START_1_bm = (1<<1)             ; Start command bit 1 mask
  ADC_START_1_bp = 1                  ; Start command bit 1 position
  ADC_START_2_bm = (1<<2)             ; Start command bit 2 mask
  ADC_START_2_bp = 2                  ; Start command bit 2 position
  ADC_MODE_gm = 0x70                  ; Mode group mask
  ADC_MODE_gp = 4                     ; Mode group position
  ADC_MODE_0_bm = (1<<4)              ; Mode bit 0 mask
  ADC_MODE_0_bp = 4                   ; Mode bit 0 position
  ADC_MODE_1_bm = (1<<5)              ; Mode bit 1 mask
  ADC_MODE_1_bp = 5                   ; Mode bit 1 position
  ADC_MODE_2_bm = (1<<6)              ; Mode bit 2 mask
  ADC_MODE_2_bp = 6                   ; Mode bit 2 position
  ADC_DIFF_bm = 0x80                  ; Differential mode bit mask
  ADC_DIFF_bp = 7                     ; Differential mode bit position
  
  ; ADC_PGACTRL masks
  ADC_PGAEN_bm = 0x01                 ; PGA Enable bit mask
  ADC_PGAEN_bp = 0                    ; PGA Enable bit position
  ADC_ADCPGASAMPDUR_gm = 0x06         ; ADC PGA Sample Duration group mask
  ADC_ADCPGASAMPDUR_gp = 1            ; ADC PGA Sample Duration group position
  ADC_ADCPGASAMPDUR_0_bm = (1<<1)     ; ADC PGA Sample Duration bit 0 mask
  ADC_ADCPGASAMPDUR_0_bp = 1          ; ADC PGA Sample Duration bit 0 position
  ADC_ADCPGASAMPDUR_1_bm = (1<<2)     ; ADC PGA Sample Duration bit 1 mask
  ADC_ADCPGASAMPDUR_1_bp = 2          ; ADC PGA Sample Duration bit 1 position
  ADC_PGABIASSEL_gm = 0x18            ; PGA BIAS Select group mask
  ADC_PGABIASSEL_gp = 3               ; PGA BIAS Select group position
  ADC_PGABIASSEL_0_bm = (1<<3)        ; PGA BIAS Select bit 0 mask
  ADC_PGABIASSEL_0_bp = 3             ; PGA BIAS Select bit 0 position
  ADC_PGABIASSEL_1_bm = (1<<4)        ; PGA BIAS Select bit 1 mask
  ADC_PGABIASSEL_1_bp = 4             ; PGA BIAS Select bit 1 position
  ADC_GAIN_gm = 0xE0                  ; Gain group mask
  ADC_GAIN_gp = 5                     ; Gain group position
  ADC_GAIN_0_bm = (1<<5)              ; Gain bit 0 mask
  ADC_GAIN_0_bp = 5                   ; Gain bit 0 position
  ADC_GAIN_1_bm = (1<<6)              ; Gain bit 1 mask
  ADC_GAIN_1_bp = 6                   ; Gain bit 1 position
  ADC_GAIN_2_bm = (1<<7)              ; Gain bit 2 mask
  ADC_GAIN_2_bp = 7                   ; Gain bit 2 position
  
  ; ADC_MUXPOS masks
  ADC_MUXPOS_gm = 0x3F                ; Analog Channel Selection Bits group mask
  ADC_MUXPOS_gp = 0                   ; Analog Channel Selection Bits group position
  ADC_MUXPOS_0_bm = (1<<0)            ; Analog Channel Selection Bits bit 0 mask
  ADC_MUXPOS_0_bp = 0                 ; Analog Channel Selection Bits bit 0 position
  ADC_MUXPOS_1_bm = (1<<1)            ; Analog Channel Selection Bits bit 1 mask
  ADC_MUXPOS_1_bp = 1                 ; Analog Channel Selection Bits bit 1 position
  ADC_MUXPOS_2_bm = (1<<2)            ; Analog Channel Selection Bits bit 2 mask
  ADC_MUXPOS_2_bp = 2                 ; Analog Channel Selection Bits bit 2 position
  ADC_MUXPOS_3_bm = (1<<3)            ; Analog Channel Selection Bits bit 3 mask
  ADC_MUXPOS_3_bp = 3                 ; Analog Channel Selection Bits bit 3 position
  ADC_MUXPOS_4_bm = (1<<4)            ; Analog Channel Selection Bits bit 4 mask
  ADC_MUXPOS_4_bp = 4                 ; Analog Channel Selection Bits bit 4 position
  ADC_MUXPOS_5_bm = (1<<5)            ; Analog Channel Selection Bits bit 5 mask
  ADC_MUXPOS_5_bp = 5                 ; Analog Channel Selection Bits bit 5 position
  ADC_VIA_gm = 0xC0                   ; VIA group mask
  ADC_VIA_gp = 6                      ; VIA group position
  ADC_VIA_0_bm = (1<<6)               ; VIA bit 0 mask
  ADC_VIA_0_bp = 6                    ; VIA bit 0 position
  ADC_VIA_1_bm = (1<<7)               ; VIA bit 1 mask
  ADC_VIA_1_bp = 7                    ; VIA bit 1 position
  
  ; ADC_MUXNEG masks
  ADC_MUXNEG_gm = 0x3F                ; Analog Channel Selection Bits group mask
  ADC_MUXNEG_gp = 0                   ; Analog Channel Selection Bits group position
  ADC_MUXNEG_0_bm = (1<<0)            ; Analog Channel Selection Bits bit 0 mask
  ADC_MUXNEG_0_bp = 0                 ; Analog Channel Selection Bits bit 0 position
  ADC_MUXNEG_1_bm = (1<<1)            ; Analog Channel Selection Bits bit 1 mask
  ADC_MUXNEG_1_bp = 1                 ; Analog Channel Selection Bits bit 1 position
  ADC_MUXNEG_2_bm = (1<<2)            ; Analog Channel Selection Bits bit 2 mask
  ADC_MUXNEG_2_bp = 2                 ; Analog Channel Selection Bits bit 2 position
  ADC_MUXNEG_3_bm = (1<<3)            ; Analog Channel Selection Bits bit 3 mask
  ADC_MUXNEG_3_bp = 3                 ; Analog Channel Selection Bits bit 3 position
  ADC_MUXNEG_4_bm = (1<<4)            ; Analog Channel Selection Bits bit 4 mask
  ADC_MUXNEG_4_bp = 4                 ; Analog Channel Selection Bits bit 4 position
  ADC_MUXNEG_5_bm = (1<<5)            ; Analog Channel Selection Bits bit 5 mask
  ADC_MUXNEG_5_bp = 5                 ; Analog Channel Selection Bits bit 5 position
  ; Masks for ADC_VIA already defined
  
  ; ADC_TEMP0 masks
  ADC_TEMP_gm = 0xFF                  ; Temporary group mask
  ADC_TEMP_gp = 0                     ; Temporary group position
  ADC_TEMP_0_bm = (1<<0)              ; Temporary bit 0 mask
  ADC_TEMP_0_bp = 0                   ; Temporary bit 0 position
  ADC_TEMP_1_bm = (1<<1)              ; Temporary bit 1 mask
  ADC_TEMP_1_bp = 1                   ; Temporary bit 1 position
  ADC_TEMP_2_bm = (1<<2)              ; Temporary bit 2 mask
  ADC_TEMP_2_bp = 2                   ; Temporary bit 2 position
  ADC_TEMP_3_bm = (1<<3)              ; Temporary bit 3 mask
  ADC_TEMP_3_bp = 3                   ; Temporary bit 3 position
  ADC_TEMP_4_bm = (1<<4)              ; Temporary bit 4 mask
  ADC_TEMP_4_bp = 4                   ; Temporary bit 4 position
  ADC_TEMP_5_bm = (1<<5)              ; Temporary bit 5 mask
  ADC_TEMP_5_bp = 5                   ; Temporary bit 5 position
  ADC_TEMP_6_bm = (1<<6)              ; Temporary bit 6 mask
  ADC_TEMP_6_bp = 6                   ; Temporary bit 6 position
  ADC_TEMP_7_bm = (1<<7)              ; Temporary bit 7 mask
  ADC_TEMP_7_bp = 7                   ; Temporary bit 7 position
  
  ; ADC_TEMP1 masks
  ; Masks for ADC_TEMP already defined
  
  ; ADC_TEMP2 masks
  ; Masks for ADC_TEMP already defined
  
  ; Mode select
  ADC_MODE_SINGLE_8BIT_gc = (0x00<<4) ; Single Conversion 8-bit
  ADC_MODE_SINGLE_12BIT_gc = (0x01<<4) ; Single Conversion 12-bit
  ADC_MODE_SERIES_gc = (0x02<<4)      ; Series Accumulation
  ADC_MODE_SERIES_SCALING_gc = (0x03<<4) ; Series Accumulation with Scaling
  ADC_MODE_BURST_gc = (0x04<<4)       ; Burst Accumulation
  ADC_MODE_BURST_SCALING_gc = (0x05<<4) ; Burst Accumulation with Scaling
  
  ; Start command select
  ADC_START_STOP_gc = (0x00<<0)       ; Stop an ongoing conversion
  ADC_START_IMMEDIATE_gc = (0x01<<0)  ; Start immediately
  ADC_START_MUXPOS_WRITE_gc = (0x02<<0) ; Start on MUXPOS write
  ADC_START_MUXNEG_WRITE_gc = (0x03<<0) ; Start on MUXNEG write
  ADC_START_EVENT_TRIGGER_gc = (0x04<<0) ; Start on event
  
  ; Prescaler Value select
  ADC_PRESC_DIV2_gc = (0x00<<0)       ; System clock divided by 2
  ADC_PRESC_DIV4_gc = (0x01<<0)       ; System clock divided by 4
  ADC_PRESC_DIV6_gc = (0x02<<0)       ; System clock divided by 6
  ADC_PRESC_DIV8_gc = (0x03<<0)       ; System clock divided by 8
  ADC_PRESC_DIV10_gc = (0x04<<0)      ; System clock divided by 10
  ADC_PRESC_DIV12_gc = (0x05<<0)      ; System clock divided by 12
  ADC_PRESC_DIV14_gc = (0x06<<0)      ; System clock divided by 14
  ADC_PRESC_DIV16_gc = (0x07<<0)      ; System clock divided by 16
  ADC_PRESC_DIV20_gc = (0x08<<0)      ; System clock divided by 20
  ADC_PRESC_DIV24_gc = (0x09<<0)      ; System clock divided by 24
  ADC_PRESC_DIV28_gc = (0x0A<<0)      ; System clock divided by 28
  ADC_PRESC_DIV32_gc = (0x0B<<0)      ; System clock divided by 32
  ADC_PRESC_DIV40_gc = (0x0C<<0)      ; System clock divided by 40
  ADC_PRESC_DIV48_gc = (0x0D<<0)      ; System clock divided by 48
  ADC_PRESC_DIV56_gc = (0x0E<<0)      ; System clock divided by 56
  ADC_PRESC_DIV64_gc = (0x0F<<0)      ; System clock divided by 64
  
  ; Reference select
  ADC_REFSEL_VDD_gc = (0x00<<0)       ; VDD
  ADC_REFSEL_VREFA_gc = (0x02<<0)     ; External Reference
  ADC_REFSEL_1024MV_gc = (0x04<<0)    ; Internal 1.024V Reference
  ADC_REFSEL_2048MV_gc = (0x05<<0)    ; Internal 2.048V Reference
  ADC_REFSEL_2500MV_gc = (0x06<<0)    ; Internal 2.5V Reference
  ADC_REFSEL_4096MV_gc = (0x07<<0)    ; Internal 4.096V Reference
  
  ; Window Comparator Mode select
  ADC_WINCM_NONE_gc = (0x00<<0)       ; No Window Comparison
  ADC_WINCM_BELOW_gc = (0x01<<0)      ; Below Window
  ADC_WINCM_ABOVE_gc = (0x02<<0)      ; Above Window
  ADC_WINCM_INSIDE_gc = (0x03<<0)     ; Inside Window
  ADC_WINCM_OUTSIDE_gc = (0x04<<0)    ; Outside Window
  
  ; Window Mode Source select
  ADC_WINSRC_RESULT_gc = (0x00<<3)    ; Result register
  ADC_WINSRC_SAMPLE_gc = (0x01<<3)    ; Sample register
  
  ; Sample numbers select
  ADC_SAMPNUM_NONE_gc = (0x00<<0)     ; No accumulation
  ADC_SAMPNUM_ACC2_gc = (0x01<<0)     ; 2 samples accumulation
  ADC_SAMPNUM_ACC4_gc = (0x02<<0)     ; 4 samples accumulation
  ADC_SAMPNUM_ACC8_gc = (0x03<<0)     ; 8 samples accumulation
  ADC_SAMPNUM_ACC16_gc = (0x04<<0)    ; 16 samples accumulation
  ADC_SAMPNUM_ACC32_gc = (0x05<<0)    ; 32 samples accumulation
  ADC_SAMPNUM_ACC64_gc = (0x06<<0)    ; 64 samples accumulation
  ADC_SAMPNUM_ACC128_gc = (0x07<<0)   ; 128 samples accumulation
  ADC_SAMPNUM_ACC256_gc = (0x08<<0)   ; 256 samples accumulation
  ADC_SAMPNUM_ACC512_gc = (0x09<<0)   ; 512 samples accumulation
  ADC_SAMPNUM_ACC1024_gc = (0x0A<<0)  ; 1024 samples accumulation
  
  ; Analog Channel Selection Bits
  ADC_MUXNEG_AIN1_gc = (0x01<<0)      ; ADC input pin 1
  ADC_MUXNEG_AIN2_gc = (0x02<<0)      ; ADC input pin 2
  ADC_MUXNEG_AIN3_gc = (0x03<<0)      ; ADC input pin 3
  ADC_MUXNEG_AIN4_gc = (0x04<<0)      ; ADC input pin 4
  ADC_MUXNEG_AIN5_gc = (0x05<<0)      ; ADC input pin 5
  ADC_MUXNEG_AIN6_gc = (0x06<<0)      ; ADC input pin 6
  ADC_MUXNEG_AIN7_gc = (0x07<<0)      ; ADC input pin 7
  ADC_MUXNEG_GND_gc = (0x30<<0)       ; Ground
  ADC_MUXNEG_VDDDIV10_gc = (0x31<<0)  ; VDD/10
  ADC_MUXNEG_DACREF0_gc = (0x33<<0)   ; DACREF from AC0
  
  ; VIA select
  ADC_VIA_ADC_gc = (0x00<<6)          ; Via ADC
  ADC_VIA_PGA_gc = (0x01<<6)          ; Via PGA
  
  ; Analog Channel Selection Bits
  ADC_MUXPOS_AIN1_gc = (0x01<<0)      ; ADC input pin 1
  AIN1 = (0x01<<0)      ; ADC input pin 1
  ADC_MUXPOS_AIN2_gc = (0x02<<0)      ; ADC input pin 2
  AIN2 = (0x02<<0)      ; ADC input pin 2
  ADC_MUXPOS_AIN3_gc = (0x03<<0)      ; ADC input pin 3
  AIN3 = (0x03<<0)      ; ADC input pin 3
  ADC_MUXPOS_AIN4_gc = (0x04<<0)      ; ADC input pin 4
  AIN4 = (0x04<<0)      ; ADC input pin 4
  ADC_MUXPOS_AIN5_gc = (0x05<<0)      ; ADC input pin 5
  AIN5 = (0x05<<0)      ; ADC input pin 5
  ADC_MUXPOS_AIN6_gc = (0x06<<0)      ; ADC input pin 6
  AIN6 = (0x06<<0)      ; ADC input pin 6
  ADC_MUXPOS_AIN7_gc = (0x07<<0)      ; ADC input pin 7
  AIN7 = (0x07<<0)      ; ADC input pin 7
  ADC_MUXPOS_AIN8_gc = (0x08<<0)      ; ADC input pin 8
  AIN8 = (0x08<<0)      ; ADC input pin 8
  ADC_MUXPOS_AIN9_gc = (0x09<<0)      ; ADC input pin 9
  AIN9 = (0x09<<0)      ; ADC input pin 9
  ADC_MUXPOS_AIN10_gc = (0x0A<<0)     ; ADC input pin 10
  AIN10 = (0x0A<<0)     ; ADC input pin 10
  ADC_MUXPOS_AIN11_gc = (0x0B<<0)     ; ADC input pin 11
  AIN11 = (0x0B<<0)     ; ADC input pin 11
  ADC_MUXPOS_AIN12_gc = (0x0C<<0)     ; ADC input pin 12
  AIN12 = (0x0C<<0)     ; ADC input pin 12
  ADC_MUXPOS_AIN13_gc = (0x0D<<0)     ; ADC input pin 13
  AIN13 = (0x0D<<0)     ; ADC input pin 13
  ADC_MUXPOS_AIN14_gc = (0x0E<<0)     ; ADC input pin 14
  AIN14 = (0x0E<<0)     ; ADC input pin 14
  ADC_MUXPOS_AIN15_gc = (0x0F<<0)     ; ADC input pin 15
  AIN15 = (0x0F<<0)     ; ADC input pin 15
  ADC_MUXPOS_GND_gc = (0x30<<0)       ; Ground
  ADC_MUXPOS_VDDDIV10_gc = (0x31<<0)  ; VDD/10
  ADC_MUXPOS_TEMPSENSE_gc = (0x32<<0) ; Temperature sensor
  ADC_MUXPOS_DACREF0_gc = (0x33<<0)   ; DACREF from AC0
  
  ; ADC PGA Sample Duration select
  ADC_ADCPGASAMPDUR_6CLK_gc = (0x00<<1) ; 6 ADC cycles
  ADC_ADCPGASAMPDUR_15CLK_gc = (0x01<<1) ; 15 ADC cycles
  ADC_ADCPGASAMPDUR_20CLK_gc = (0x02<<1) ; 20 ADC cycles
  
  ; Gain select
  ADC_GAIN_1X_gc = (0x00<<5)          ; 1X Gain
  ADC_GAIN_2X_gc = (0x01<<5)          ; 2X Gain
  ADC_GAIN_4X_gc = (0x02<<5)          ; 4X Gain
  ADC_GAIN_8X_gc = (0x03<<5)          ; 8X Gain
  ADC_GAIN_16X_gc = (0x04<<5)         ; 16X Gain
  
  ; PGA BIAS Select
  ADC_PGABIASSEL_1X_gc = (0x00<<3)    ; 1x BIAS current
  ADC_PGABIASSEL_3_4X_gc = (0x01<<3)  ; 3/4x BIAS current
  ADC_PGABIASSEL_1_2X_gc = (0x02<<3)  ; 1/2x BIAS current
  ADC_PGABIASSEL_1_4X_gc = (0x03<<3)  ; 1/4x BIAS current
  
  
  ;*************************************************************************
  ;** BOD - Bod interface
  ;*************************************************************************
  
  ; BOD_CTRLA masks
  BOD_SLEEP_gm = 0x03                 ; Operation in sleep mode group mask
  BOD_SLEEP_gp = 0                    ; Operation in sleep mode group position
  BOD_SLEEP_0_bm = (1<<0)             ; Operation in sleep mode bit 0 mask
  BOD_SLEEP_0_bp = 0                  ; Operation in sleep mode bit 0 position
  BOD_SLEEP_1_bm = (1<<1)             ; Operation in sleep mode bit 1 mask
  BOD_SLEEP_1_bp = 1                  ; Operation in sleep mode bit 1 position
  BOD_ACTIVE_gm = 0x0C                ; Operation in active mode group mask
  BOD_ACTIVE_gp = 2                   ; Operation in active mode group position
  BOD_ACTIVE_0_bm = (1<<2)            ; Operation in active mode bit 0 mask
  BOD_ACTIVE_0_bp = 2                 ; Operation in active mode bit 0 position
  BOD_ACTIVE_1_bm = (1<<3)            ; Operation in active mode bit 1 mask
  BOD_ACTIVE_1_bp = 3                 ; Operation in active mode bit 1 position
  BOD_SAMPFREQ_bm = 0x10              ; Sample frequency bit mask
  BOD_SAMPFREQ_bp = 4                 ; Sample frequency bit position
  
  ; BOD_CTRLB masks
  BOD_LVL_gm = 0x07                   ; Bod level group mask
  BOD_LVL_gp = 0                      ; Bod level group position
  BOD_LVL_0_bm = (1<<0)               ; Bod level bit 0 mask
  BOD_LVL_0_bp = 0                    ; Bod level bit 0 position
  BOD_LVL_1_bm = (1<<1)               ; Bod level bit 1 mask
  BOD_LVL_1_bp = 1                    ; Bod level bit 1 position
  BOD_LVL_2_bm = (1<<2)               ; Bod level bit 2 mask
  BOD_LVL_2_bp = 2                    ; Bod level bit 2 position
  
  ; BOD_VLMCTRLA masks
  BOD_VLMLVL_gm = 0x03                ; voltage level monitor level group mask
  BOD_VLMLVL_gp = 0                   ; voltage level monitor level group position
  BOD_VLMLVL_0_bm = (1<<0)            ; voltage level monitor level bit 0 mask
  BOD_VLMLVL_0_bp = 0                 ; voltage level monitor level bit 0 position
  BOD_VLMLVL_1_bm = (1<<1)            ; voltage level monitor level bit 1 mask
  BOD_VLMLVL_1_bp = 1                 ; voltage level monitor level bit 1 position
  
  ; BOD_INTCTRL masks
  BOD_VLMIE_bm = 0x01                 ; voltage level monitor interrrupt enable bit mask
  BOD_VLMIE_bp = 0                    ; voltage level monitor interrrupt enable bit position
  BOD_VLMCFG_gm = 0x06                ; Configuration group mask
  BOD_VLMCFG_gp = 1                   ; Configuration group position
  BOD_VLMCFG_0_bm = (1<<1)            ; Configuration bit 0 mask
  BOD_VLMCFG_0_bp = 1                 ; Configuration bit 0 position
  BOD_VLMCFG_1_bm = (1<<2)            ; Configuration bit 1 mask
  BOD_VLMCFG_1_bp = 2                 ; Configuration bit 1 position
  
  ; BOD_INTFLAGS masks
  BOD_VLMIF_bm = 0x01                 ; Voltage level monitor interrupt flag bit mask
  BOD_VLMIF_bp = 0                    ; Voltage level monitor interrupt flag bit position
  
  ; BOD_STATUS masks
  BOD_VLMS_bm = 0x01                  ; Voltage level monitor status bit mask
  BOD_VLMS_bp = 0                     ; Voltage level monitor status bit position
  
  ; Operation in active mode select
  BOD_ACTIVE_DIS_gc = (0x00<<2)       ; Disabled
  BOD_ACTIVE_ENABLED_gc = (0x01<<2)   ; Enabled
  BOD_ACTIVE_SAMPLED_gc = (0x02<<2)   ; Sampled
  BOD_ACTIVE_ENWAKE_gc = (0x03<<2)    ; Enabled with wake-up halted until BOD is ready
  
  ; Sample frequency select
  BOD_SAMPFREQ_1KHZ_gc = (0x00<<4)    ; 1kHz sampling frequency
  BOD_SAMPFREQ_125HZ_gc = (0x01<<4)   ; 125Hz sampling frequency
  
  ; Operation in sleep mode select
  BOD_SLEEP_DIS_gc = (0x00<<0)        ; Disabled
  BOD_SLEEP_ENABLED_gc = (0x01<<0)    ; Enabled
  BOD_SLEEP_SAMPLED_gc = (0x02<<0)    ; Sampled
  
  ; Bod level select
  BOD_LVL_BODLEVEL0_gc = (0x00<<0)    ; 1.8 V
  BOD_LVL_BODLEVEL2_gc = (0x02<<0)    ; 2.6 V
  BOD_LVL_BODLEVEL7_gc = (0x07<<0)    ; 4.2 V
  
  ; Configuration select
  BOD_VLMCFG_BELOW_gc = (0x00<<1)     ; Interrupt when supply goes below VLM level
  BOD_VLMCFG_ABOVE_gc = (0x01<<1)     ; Interrupt when supply goes above VLM level
  BOD_VLMCFG_CROSS_gc = (0x02<<1)     ; Interrupt when supply crosses VLM level
  
  ; voltage level monitor level select
  BOD_VLMLVL_5ABOVE_gc = (0x00<<0)    ; VLM threshold 5% above BOD level
  BOD_VLMLVL_15ABOVE_gc = (0x01<<0)   ; VLM threshold 15% above BOD level
  BOD_VLMLVL_25ABOVE_gc = (0x02<<0)   ; VLM threshold 25% above BOD level
  
  
  ;*************************************************************************
  ;** CCL - Configurable Custom Logic
  ;*************************************************************************
  
  ; CCL_CTRLA masks
  CCL_ENABLE_bm = 0x01                ; Enable bit mask
  CCL_ENABLE_bp = 0                   ; Enable bit position
  CCL_RUNSTDBY_bm = 0x40              ; Run in Standby bit mask
  CCL_RUNSTDBY_bp = 6                 ; Run in Standby bit position
  
  ; CCL_SEQCTRL0 masks
  CCL_SEQSEL_gm = 0x07                ; Sequential Selection group mask
  CCL_SEQSEL_gp = 0                   ; Sequential Selection group position
  CCL_SEQSEL_0_bm = (1<<0)            ; Sequential Selection bit 0 mask
  CCL_SEQSEL_0_bp = 0                 ; Sequential Selection bit 0 position
  CCL_SEQSEL_1_bm = (1<<1)            ; Sequential Selection bit 1 mask
  CCL_SEQSEL_1_bp = 1                 ; Sequential Selection bit 1 position
  CCL_SEQSEL_2_bm = (1<<2)            ; Sequential Selection bit 2 mask
  CCL_SEQSEL_2_bp = 2                 ; Sequential Selection bit 2 position
  
  ; CCL_SEQCTRL1 masks
  ; Masks for CCL_SEQSEL already defined
  
  ; CCL_INTCTRL0 masks
  CCL_INTMODE0_gm = 0x03              ; Interrupt Mode for LUT0 group mask
  CCL_INTMODE0_gp = 0                 ; Interrupt Mode for LUT0 group position
  CCL_INTMODE0_0_bm = (1<<0)          ; Interrupt Mode for LUT0 bit 0 mask
  CCL_INTMODE0_0_bp = 0               ; Interrupt Mode for LUT0 bit 0 position
  CCL_INTMODE0_1_bm = (1<<1)          ; Interrupt Mode for LUT0 bit 1 mask
  CCL_INTMODE0_1_bp = 1               ; Interrupt Mode for LUT0 bit 1 position
  CCL_INTMODE1_gm = 0x0C              ; Interrupt Mode for LUT1 group mask
  CCL_INTMODE1_gp = 2                 ; Interrupt Mode for LUT1 group position
  CCL_INTMODE1_0_bm = (1<<2)          ; Interrupt Mode for LUT1 bit 0 mask
  CCL_INTMODE1_0_bp = 2               ; Interrupt Mode for LUT1 bit 0 position
  CCL_INTMODE1_1_bm = (1<<3)          ; Interrupt Mode for LUT1 bit 1 mask
  CCL_INTMODE1_1_bp = 3               ; Interrupt Mode for LUT1 bit 1 position
  CCL_INTMODE2_gm = 0x30              ; Interrupt Mode for LUT2 group mask
  CCL_INTMODE2_gp = 4                 ; Interrupt Mode for LUT2 group position
  CCL_INTMODE2_0_bm = (1<<4)          ; Interrupt Mode for LUT2 bit 0 mask
  CCL_INTMODE2_0_bp = 4               ; Interrupt Mode for LUT2 bit 0 position
  CCL_INTMODE2_1_bm = (1<<5)          ; Interrupt Mode for LUT2 bit 1 mask
  CCL_INTMODE2_1_bp = 5               ; Interrupt Mode for LUT2 bit 1 position
  CCL_INTMODE3_gm = 0xC0              ; Interrupt Mode for LUT3 group mask
  CCL_INTMODE3_gp = 6                 ; Interrupt Mode for LUT3 group position
  CCL_INTMODE3_0_bm = (1<<6)          ; Interrupt Mode for LUT3 bit 0 mask
  CCL_INTMODE3_0_bp = 6               ; Interrupt Mode for LUT3 bit 0 position
  CCL_INTMODE3_1_bm = (1<<7)          ; Interrupt Mode for LUT3 bit 1 mask
  CCL_INTMODE3_1_bp = 7               ; Interrupt Mode for LUT3 bit 1 position
  
  ; CCL_INTFLAGS masks
  CCL_INT_gm = 0x0F                   ; Interrupt Flag group mask
  CCL_INT_gp = 0                      ; Interrupt Flag group position
  CCL_INT_0_bm = (1<<0)               ; Interrupt Flag bit 0 mask
  CCL_INT_0_bp = 0                    ; Interrupt Flag bit 0 position
  CCL_INT_1_bm = (1<<1)               ; Interrupt Flag bit 1 mask
  CCL_INT_1_bp = 1                    ; Interrupt Flag bit 1 position
  CCL_INT_2_bm = (1<<2)               ; Interrupt Flag bit 2 mask
  CCL_INT_2_bp = 2                    ; Interrupt Flag bit 2 position
  CCL_INT_3_bm = (1<<3)               ; Interrupt Flag bit 3 mask
  CCL_INT_3_bp = 3                    ; Interrupt Flag bit 3 position
  
  ; CCL_LUT0CTRLA masks
  ; Masks for CCL_ENABLE already defined
  CCL_CLKSRC_gm = 0x0E                ; Clock Source Selection group mask
  CCL_CLKSRC_gp = 1                   ; Clock Source Selection group position
  CCL_CLKSRC_0_bm = (1<<1)            ; Clock Source Selection bit 0 mask
  CCL_CLKSRC_0_bp = 1                 ; Clock Source Selection bit 0 position
  CCL_CLKSRC_1_bm = (1<<2)            ; Clock Source Selection bit 1 mask
  CCL_CLKSRC_1_bp = 2                 ; Clock Source Selection bit 1 position
  CCL_CLKSRC_2_bm = (1<<3)            ; Clock Source Selection bit 2 mask
  CCL_CLKSRC_2_bp = 3                 ; Clock Source Selection bit 2 position
  CCL_FILTSEL_gm = 0x30               ; Filter Selection group mask
  CCL_FILTSEL_gp = 4                  ; Filter Selection group position
  CCL_FILTSEL_0_bm = (1<<4)           ; Filter Selection bit 0 mask
  CCL_FILTSEL_0_bp = 4                ; Filter Selection bit 0 position
  CCL_FILTSEL_1_bm = (1<<5)           ; Filter Selection bit 1 mask
  CCL_FILTSEL_1_bp = 5                ; Filter Selection bit 1 position
  CCL_OUTEN_bm = 0x40                 ; Output Enable bit mask
  CCL_OUTEN_bp = 6                    ; Output Enable bit position
  CCL_EDGEDET_bm = 0x80               ; Edge Detection Enable bit mask
  CCL_EDGEDET_bp = 7                  ; Edge Detection Enable bit position
  
  ; CCL_LUT0CTRLB masks
  CCL_INSEL0_gm = 0x0F                ; LUT Input 0 Source Selection group mask
  CCL_INSEL0_gp = 0                   ; LUT Input 0 Source Selection group position
  CCL_INSEL0_0_bm = (1<<0)            ; LUT Input 0 Source Selection bit 0 mask
  CCL_INSEL0_0_bp = 0                 ; LUT Input 0 Source Selection bit 0 position
  CCL_INSEL0_1_bm = (1<<1)            ; LUT Input 0 Source Selection bit 1 mask
  CCL_INSEL0_1_bp = 1                 ; LUT Input 0 Source Selection bit 1 position
  CCL_INSEL0_2_bm = (1<<2)            ; LUT Input 0 Source Selection bit 2 mask
  CCL_INSEL0_2_bp = 2                 ; LUT Input 0 Source Selection bit 2 position
  CCL_INSEL0_3_bm = (1<<3)            ; LUT Input 0 Source Selection bit 3 mask
  CCL_INSEL0_3_bp = 3                 ; LUT Input 0 Source Selection bit 3 position
  CCL_INSEL1_gm = 0xF0                ; LUT Input 1 Source Selection group mask
  CCL_INSEL1_gp = 4                   ; LUT Input 1 Source Selection group position
  CCL_INSEL1_0_bm = (1<<4)            ; LUT Input 1 Source Selection bit 0 mask
  CCL_INSEL1_0_bp = 4                 ; LUT Input 1 Source Selection bit 0 position
  CCL_INSEL1_1_bm = (1<<5)            ; LUT Input 1 Source Selection bit 1 mask
  CCL_INSEL1_1_bp = 5                 ; LUT Input 1 Source Selection bit 1 position
  CCL_INSEL1_2_bm = (1<<6)            ; LUT Input 1 Source Selection bit 2 mask
  CCL_INSEL1_2_bp = 6                 ; LUT Input 1 Source Selection bit 2 position
  CCL_INSEL1_3_bm = (1<<7)            ; LUT Input 1 Source Selection bit 3 mask
  CCL_INSEL1_3_bp = 7                 ; LUT Input 1 Source Selection bit 3 position
  
  ; CCL_LUT0CTRLC masks
  CCL_INSEL2_gm = 0x0F                ; LUT Input 2 Source Selection group mask
  CCL_INSEL2_gp = 0                   ; LUT Input 2 Source Selection group position
  CCL_INSEL2_0_bm = (1<<0)            ; LUT Input 2 Source Selection bit 0 mask
  CCL_INSEL2_0_bp = 0                 ; LUT Input 2 Source Selection bit 0 position
  CCL_INSEL2_1_bm = (1<<1)            ; LUT Input 2 Source Selection bit 1 mask
  CCL_INSEL2_1_bp = 1                 ; LUT Input 2 Source Selection bit 1 position
  CCL_INSEL2_2_bm = (1<<2)            ; LUT Input 2 Source Selection bit 2 mask
  CCL_INSEL2_2_bp = 2                 ; LUT Input 2 Source Selection bit 2 position
  CCL_INSEL2_3_bm = (1<<3)            ; LUT Input 2 Source Selection bit 3 mask
  CCL_INSEL2_3_bp = 3                 ; LUT Input 2 Source Selection bit 3 position
  
  ; CCL_TRUTH0 masks
  CCL_TRUTH_gm = 0xFF                 ; Truth Table group mask
  CCL_TRUTH_gp = 0                    ; Truth Table group position
  CCL_TRUTH_0_bm = (1<<0)             ; Truth Table bit 0 mask
  CCL_TRUTH_0_bp = 0                  ; Truth Table bit 0 position
  CCL_TRUTH_1_bm = (1<<1)             ; Truth Table bit 1 mask
  CCL_TRUTH_1_bp = 1                  ; Truth Table bit 1 position
  CCL_TRUTH_2_bm = (1<<2)             ; Truth Table bit 2 mask
  CCL_TRUTH_2_bp = 2                  ; Truth Table bit 2 position
  CCL_TRUTH_3_bm = (1<<3)             ; Truth Table bit 3 mask
  CCL_TRUTH_3_bp = 3                  ; Truth Table bit 3 position
  CCL_TRUTH_4_bm = (1<<4)             ; Truth Table bit 4 mask
  CCL_TRUTH_4_bp = 4                  ; Truth Table bit 4 position
  CCL_TRUTH_5_bm = (1<<5)             ; Truth Table bit 5 mask
  CCL_TRUTH_5_bp = 5                  ; Truth Table bit 5 position
  CCL_TRUTH_6_bm = (1<<6)             ; Truth Table bit 6 mask
  CCL_TRUTH_6_bp = 6                  ; Truth Table bit 6 position
  CCL_TRUTH_7_bm = (1<<7)             ; Truth Table bit 7 mask
  CCL_TRUTH_7_bp = 7                  ; Truth Table bit 7 position
  
  ; CCL_LUT1CTRLA masks
  ; Masks for CCL_ENABLE already defined
  ; Masks for CCL_CLKSRC already defined
  ; Masks for CCL_FILTSEL already defined
  ; Masks for CCL_OUTEN already defined
  ; Masks for CCL_EDGEDET already defined
  
  ; CCL_LUT1CTRLB masks
  ; Masks for CCL_INSEL0 already defined
  ; Masks for CCL_INSEL1 already defined
  
  ; CCL_LUT1CTRLC masks
  ; Masks for CCL_INSEL2 already defined
  
  ; CCL_TRUTH1 masks
  ; Masks for CCL_TRUTH already defined
  
  ; CCL_LUT2CTRLA masks
  ; Masks for CCL_ENABLE already defined
  ; Masks for CCL_CLKSRC already defined
  ; Masks for CCL_FILTSEL already defined
  ; Masks for CCL_OUTEN already defined
  ; Masks for CCL_EDGEDET already defined
  
  ; CCL_LUT2CTRLB masks
  ; Masks for CCL_INSEL0 already defined
  ; Masks for CCL_INSEL1 already defined
  
  ; CCL_LUT2CTRLC masks
  ; Masks for CCL_INSEL2 already defined
  
  ; CCL_TRUTH2 masks
  ; Masks for CCL_TRUTH already defined
  
  ; CCL_LUT3CTRLA masks
  ; Masks for CCL_ENABLE already defined
  ; Masks for CCL_CLKSRC already defined
  ; Masks for CCL_FILTSEL already defined
  ; Masks for CCL_OUTEN already defined
  ; Masks for CCL_EDGEDET already defined
  
  ; CCL_LUT3CTRLB masks
  ; Masks for CCL_INSEL0 already defined
  ; Masks for CCL_INSEL1 already defined
  
  ; CCL_LUT3CTRLC masks
  ; Masks for CCL_INSEL2 already defined
  
  ; CCL_TRUTH3 masks
  ; Masks for CCL_TRUTH already defined
  
  ; Interrupt Mode for LUT0 select
  CCL_INTMODE0_INTDISABLE_gc = (0x00<<0) ; Interrupt disabled
  CCL_INTMODE0_RISING_gc = (0x01<<0)  ; Sense rising edge
  CCL_INTMODE0_FALLING_gc = (0x02<<0) ; Sense falling edge
  CCL_INTMODE0_BOTH_gc = (0x03<<0)    ; Sense both edges
  
  ; Interrupt Mode for LUT1 select
  CCL_INTMODE1_INTDISABLE_gc = (0x00<<2) ; Interrupt disabled
  CCL_INTMODE1_RISING_gc = (0x01<<2)  ; Sense rising edge
  CCL_INTMODE1_FALLING_gc = (0x02<<2) ; Sense falling edge
  CCL_INTMODE1_BOTH_gc = (0x03<<2)    ; Sense both edges
  
  ; Interrupt Mode for LUT2 select
  CCL_INTMODE2_INTDISABLE_gc = (0x00<<4) ; Interrupt disabled
  CCL_INTMODE2_RISING_gc = (0x01<<4)  ; Sense rising edge
  CCL_INTMODE2_FALLING_gc = (0x02<<4) ; Sense falling edge
  CCL_INTMODE2_BOTH_gc = (0x03<<4)    ; Sense both edges
  
  ; Interrupt Mode for LUT3 select
  CCL_INTMODE3_INTDISABLE_gc = (0x00<<6) ; Interrupt disabled
  CCL_INTMODE3_RISING_gc = (0x01<<6)  ; Sense rising edge
  CCL_INTMODE3_FALLING_gc = (0x02<<6) ; Sense falling edge
  CCL_INTMODE3_BOTH_gc = (0x03<<6)    ; Sense both edges
  
  ; Clock Source Selection
  CCL_CLKSRC_CLKPER_gc = (0x00<<1)    ; CLK_PER is clocking the LUT
  CCL_CLKSRC_IN2_gc = (0x01<<1)       ; IN[2] is clocking the LUT
  CCL_CLKSRC_OSC20M_gc = (0x04<<1)    ; 20MHz oscillator before prescaler is clocking the LUT
  CCL_CLKSRC_OSCULP32K_gc = (0x05<<1) ; 32kHz oscillator is clocking the LUT
  CCL_CLKSRC_OSCULP1K_gc = (0x06<<1)  ; 32kHz oscillator after DIV32 is clocking the LUT
  
  ; Edge Detection Enable select
  CCL_EDGEDET_DIS_gc = (0x00<<7)      ; Edge detector is disabled
  CCL_EDGEDET_EN_gc = (0x01<<7)       ; Edge detector is enabled
  
  ; Filter Selection
  CCL_FILTSEL_DISABLE_gc = (0x00<<4)  ; Filter disabled
  CCL_FILTSEL_SYNCH_gc = (0x01<<4)    ; Synchronizer enabled
  CCL_FILTSEL_FILTER_gc = (0x02<<4)   ; Filter enabled
  
  ; LUT Input 0 Source Selection
  CCL_INSEL0_MASK_gc = (0x00<<0)      ; Masked input
  CCL_INSEL0_FEEDBACK_gc = (0x01<<0)  ; Feedback input source
  CCL_INSEL0_LINK_gc = (0x02<<0)      ; Linked LUT input source
  CCL_INSEL0_EVENTA_gc = (0x03<<0)    ; Event input source A
  CCL_INSEL0_EVENTB_gc = (0x04<<0)    ; Event input source B
  CCL_INSEL0_IO_gc = (0x05<<0)        ; IO pin LUTn-IN0 input source
  CCL_INSEL0_AC0_gc = (0x06<<0)       ; AC0 OUT input source
  CCL_INSEL0_USART0_gc = (0x08<<0)    ; USART0 TXD input source
  CCL_INSEL0_SPI0_gc = (0x09<<0)      ; SPI0 MOSI input source
  CCL_INSEL0_TCA0_gc = (0x0A<<0)      ; TCA0 WO0 input source
  CCL_INSEL0_TCB0_gc = (0x0C<<0)      ; TCB0 WO input source
  
  ; LUT Input 1 Source Selection
  CCL_INSEL1_MASK_gc = (0x00<<4)      ; Masked input
  CCL_INSEL1_FEEDBACK_gc = (0x01<<4)  ; Feedback input source
  CCL_INSEL1_LINK_gc = (0x02<<4)      ; Linked LUT input source
  CCL_INSEL1_EVENTA_gc = (0x03<<4)    ; Event input source A
  CCL_INSEL1_EVENTB_gc = (0x04<<4)    ; Event input source B
  CCL_INSEL1_IO_gc = (0x05<<4)        ; IO pin LUTn-IN1 input source
  CCL_INSEL1_AC0_gc = (0x06<<4)       ; AC0 OUT input source
  CCL_INSEL1_USART1_gc = (0x08<<4)    ; USART1 TXD input source
  CCL_INSEL1_SPI0_gc = (0x09<<4)      ; SPI0 MOSI input source
  CCL_INSEL1_TCA0_gc = (0x0A<<4)      ; TCA0 WO1 input source
  CCL_INSEL1_TCB1_gc = (0x0C<<4)      ; TCB1 WO input source
  
  ; LUT Input 2 Source Selection
  CCL_INSEL2_MASK_gc = (0x00<<0)      ; Masked input
  CCL_INSEL2_FEEDBACK_gc = (0x01<<0)  ; Feedback input source
  CCL_INSEL2_LINK_gc = (0x02<<0)      ; Linked LUT input source
  CCL_INSEL2_EVENTA_gc = (0x03<<0)    ; Event input source A
  CCL_INSEL2_EVENTB_gc = (0x04<<0)    ; Event input source B
  CCL_INSEL2_IO_gc = (0x05<<0)        ; IO pin LUTn-IN2 input source
  CCL_INSEL2_AC0_gc = (0x06<<0)       ; AC0 OUT input source
  CCL_INSEL2_SPI0_gc = (0x09<<0)      ; SPI0 SCK input source
  CCL_INSEL2_TCA0_gc = (0x0A<<0)      ; TCA0 WO2 input source
  
  ; Sequential Selection
  CCL_SEQSEL_DISABLE_gc = (0x00<<0)   ; Sequential logic disabled
  CCL_SEQSEL_DFF_gc = (0x01<<0)       ; D FlipFlop
  CCL_SEQSEL_JK_gc = (0x02<<0)        ; JK FlipFlop
  CCL_SEQSEL_LATCH_gc = (0x03<<0)     ; D Latch
  CCL_SEQSEL_RS_gc = (0x04<<0)        ; RS Latch
  
  
  ;*************************************************************************
  ;** CLKCTRL - Clock controller
  ;*************************************************************************
  
  ; CLKCTRL_MCLKCTRLA masks
  CLKCTRL_CLKSEL_gm = 0x03            ; Clock group mask
  CLKCTRL_CLKSEL_gp = 0               ; Clock group position
  CLKCTRL_CLKSEL_0_bm = (1<<0)        ; Clock bit 0 mask
  CLKCTRL_CLKSEL_0_bp = 0             ; Clock bit 0 position
  CLKCTRL_CLKSEL_1_bm = (1<<1)        ; Clock bit 1 mask
  CLKCTRL_CLKSEL_1_bp = 1             ; Clock bit 1 position
  CLKCTRL_CLKOUT_bm = 0x80            ; System clock out bit mask
  CLKCTRL_CLKOUT_bp = 7               ; System clock out bit position
  
  ; CLKCTRL_MCLKCTRLB masks
  CLKCTRL_PEN_bm = 0x01               ; Prescaler enable bit mask
  CLKCTRL_PEN_bp = 0                  ; Prescaler enable bit position
  CLKCTRL_PDIV_gm = 0x1E              ; Prescaler division group mask
  CLKCTRL_PDIV_gp = 1                 ; Prescaler division group position
  CLKCTRL_PDIV_0_bm = (1<<1)          ; Prescaler division bit 0 mask
  CLKCTRL_PDIV_0_bp = 1               ; Prescaler division bit 0 position
  CLKCTRL_PDIV_1_bm = (1<<2)          ; Prescaler division bit 1 mask
  CLKCTRL_PDIV_1_bp = 2               ; Prescaler division bit 1 position
  CLKCTRL_PDIV_2_bm = (1<<3)          ; Prescaler division bit 2 mask
  CLKCTRL_PDIV_2_bp = 3               ; Prescaler division bit 2 position
  CLKCTRL_PDIV_3_bm = (1<<4)          ; Prescaler division bit 3 mask
  CLKCTRL_PDIV_3_bp = 4               ; Prescaler division bit 3 position
  
  ; CLKCTRL_MCLKLOCK masks
  CLKCTRL_LOCKEN_bm = 0x01            ; lock ebable bit mask
  CLKCTRL_LOCKEN_bp = 0               ; lock ebable bit position
  
  ; CLKCTRL_MCLKSTATUS masks
  CLKCTRL_SOSC_bm = 0x01              ; System Oscillator changing bit mask
  CLKCTRL_SOSC_bp = 0                 ; System Oscillator changing bit position
  CLKCTRL_OSC20MS_bm = 0x10           ; 20MHz oscillator status bit mask
  CLKCTRL_OSC20MS_bp = 4              ; 20MHz oscillator status bit position
  CLKCTRL_OSC32KS_bm = 0x20           ; 32KHz oscillator status bit mask
  CLKCTRL_OSC32KS_bp = 5              ; 32KHz oscillator status bit position
  CLKCTRL_XOSC32KS_bm = 0x40          ; 32.768 kHz Crystal Oscillator status bit mask
  CLKCTRL_XOSC32KS_bp = 6             ; 32.768 kHz Crystal Oscillator status bit position
  CLKCTRL_EXTS_bm = 0x80              ; External Clock status bit mask
  CLKCTRL_EXTS_bp = 7                 ; External Clock status bit position
  
  ; CLKCTRL_OSC20MCTRLA masks
  CLKCTRL_RUNSTDBY_bm = 0x02          ; Run standby bit mask
  CLKCTRL_RUNSTDBY_bp = 1             ; Run standby bit position
  
  ; CLKCTRL_OSC20MCALIBA masks
  CLKCTRL_CAL20M_gm = 0x7F            ; Calibration group mask
  CLKCTRL_CAL20M_gp = 0               ; Calibration group position
  CLKCTRL_CAL20M_0_bm = (1<<0)        ; Calibration bit 0 mask
  CLKCTRL_CAL20M_0_bp = 0             ; Calibration bit 0 position
  CLKCTRL_CAL20M_1_bm = (1<<1)        ; Calibration bit 1 mask
  CLKCTRL_CAL20M_1_bp = 1             ; Calibration bit 1 position
  CLKCTRL_CAL20M_2_bm = (1<<2)        ; Calibration bit 2 mask
  CLKCTRL_CAL20M_2_bp = 2             ; Calibration bit 2 position
  CLKCTRL_CAL20M_3_bm = (1<<3)        ; Calibration bit 3 mask
  CLKCTRL_CAL20M_3_bp = 3             ; Calibration bit 3 position
  CLKCTRL_CAL20M_4_bm = (1<<4)        ; Calibration bit 4 mask
  CLKCTRL_CAL20M_4_bp = 4             ; Calibration bit 4 position
  CLKCTRL_CAL20M_5_bm = (1<<5)        ; Calibration bit 5 mask
  CLKCTRL_CAL20M_5_bp = 5             ; Calibration bit 5 position
  CLKCTRL_CAL20M_6_bm = (1<<6)        ; Calibration bit 6 mask
  CLKCTRL_CAL20M_6_bp = 6             ; Calibration bit 6 position
  
  ; CLKCTRL_OSC20MCALIBB masks
  CLKCTRL_TEMPCAL20M_gm = 0x0F        ; Oscillator temperature coefficient group mask
  CLKCTRL_TEMPCAL20M_gp = 0           ; Oscillator temperature coefficient group position
  CLKCTRL_TEMPCAL20M_0_bm = (1<<0)    ; Oscillator temperature coefficient bit 0 mask
  CLKCTRL_TEMPCAL20M_0_bp = 0         ; Oscillator temperature coefficient bit 0 position
  CLKCTRL_TEMPCAL20M_1_bm = (1<<1)    ; Oscillator temperature coefficient bit 1 mask
  CLKCTRL_TEMPCAL20M_1_bp = 1         ; Oscillator temperature coefficient bit 1 position
  CLKCTRL_TEMPCAL20M_2_bm = (1<<2)    ; Oscillator temperature coefficient bit 2 mask
  CLKCTRL_TEMPCAL20M_2_bp = 2         ; Oscillator temperature coefficient bit 2 position
  CLKCTRL_TEMPCAL20M_3_bm = (1<<3)    ; Oscillator temperature coefficient bit 3 mask
  CLKCTRL_TEMPCAL20M_3_bp = 3         ; Oscillator temperature coefficient bit 3 position
  CLKCTRL_LOCK_bm = 0x80              ; Lock bit mask
  CLKCTRL_LOCK_bp = 7                 ; Lock bit position
  
  ; CLKCTRL_OSC32KCTRLA masks
  ; Masks for CLKCTRL_RUNSTDBY already defined
  
  ; CLKCTRL_XOSC32KCTRLA masks
  CLKCTRL_ENABLE_bm = 0x01            ; Enable bit mask
  CLKCTRL_ENABLE_bp = 0               ; Enable bit position
  ; Masks for CLKCTRL_RUNSTDBY already defined
  CLKCTRL_SEL_bm = 0x04               ; Select bit mask
  CLKCTRL_SEL_bp = 2                  ; Select bit position
  CLKCTRL_CSUT_gm = 0x30              ; Crystal startup time group mask
  CLKCTRL_CSUT_gp = 4                 ; Crystal startup time group position
  CLKCTRL_CSUT_0_bm = (1<<4)          ; Crystal startup time bit 0 mask
  CLKCTRL_CSUT_0_bp = 4               ; Crystal startup time bit 0 position
  CLKCTRL_CSUT_1_bm = (1<<5)          ; Crystal startup time bit 1 mask
  CLKCTRL_CSUT_1_bp = 5               ; Crystal startup time bit 1 position
  
  ; Clock select
  CLKCTRL_CLKSEL_OSC20M_gc = (0x00<<0) ; 20MHz oscillator
  CLKCTRL_CLKSEL_OSCULP32K_gc = (0x01<<0) ; 32KHz oscillator
  CLKCTRL_CLKSEL_XOSC32K_gc = (0x02<<0) ; 32.768kHz crystal oscillator
  CLKCTRL_CLKSEL_EXTCLK_gc = (0x03<<0) ; External clock
  
  ; Prescaler division select
  CLKCTRL_PDIV_2X_gc = (0x00<<1)      ; 2X
  CLKCTRL_PDIV_4X_gc = (0x01<<1)      ; 4X
  CLKCTRL_PDIV_8X_gc = (0x02<<1)      ; 8X
  CLKCTRL_PDIV_16X_gc = (0x03<<1)     ; 16X
  CLKCTRL_PDIV_32X_gc = (0x04<<1)     ; 32X
  CLKCTRL_PDIV_64X_gc = (0x05<<1)     ; 64X
  CLKCTRL_PDIV_6X_gc = (0x08<<1)      ; 6X
  CLKCTRL_PDIV_10X_gc = (0x09<<1)     ; 10X
  CLKCTRL_PDIV_12X_gc = (0x0A<<1)     ; 12X
  CLKCTRL_PDIV_24X_gc = (0x0B<<1)     ; 24X
  CLKCTRL_PDIV_48X_gc = (0x0C<<1)     ; 48X
  
  ; Crystal startup time select
  CLKCTRL_CSUT_1K_gc = (0x00<<4)      ; 1k cycles
  CLKCTRL_CSUT_16K_gc = (0x01<<4)     ; 16k cycles
  CLKCTRL_CSUT_32K_gc = (0x02<<4)     ; 32k cycles
  CLKCTRL_CSUT_64K_gc = (0x03<<4)     ; 64k cycles
  
  
  ;*************************************************************************
  ;** CPU - CPU
  ;*************************************************************************
  
  ; CPU_CCP masks
  CPU_CCP_gm = 0xFF                   ; CCP signature group mask
  CPU_CCP_gp = 0                      ; CCP signature group position
  CPU_CCP_0_bm = (1<<0)               ; CCP signature bit 0 mask
  CPU_CCP_0_bp = 0                    ; CCP signature bit 0 position
  CPU_CCP_1_bm = (1<<1)               ; CCP signature bit 1 mask
  CPU_CCP_1_bp = 1                    ; CCP signature bit 1 position
  CPU_CCP_2_bm = (1<<2)               ; CCP signature bit 2 mask
  CPU_CCP_2_bp = 2                    ; CCP signature bit 2 position
  CPU_CCP_3_bm = (1<<3)               ; CCP signature bit 3 mask
  CPU_CCP_3_bp = 3                    ; CCP signature bit 3 position
  CPU_CCP_4_bm = (1<<4)               ; CCP signature bit 4 mask
  CPU_CCP_4_bp = 4                    ; CCP signature bit 4 position
  CPU_CCP_5_bm = (1<<5)               ; CCP signature bit 5 mask
  CPU_CCP_5_bp = 5                    ; CCP signature bit 5 position
  CPU_CCP_6_bm = (1<<6)               ; CCP signature bit 6 mask
  CPU_CCP_6_bp = 6                    ; CCP signature bit 6 position
  CPU_CCP_7_bm = (1<<7)               ; CCP signature bit 7 mask
  CPU_CCP_7_bp = 7                    ; CCP signature bit 7 position
  
  ; CPU_SREG masks
  CPU_C_bm = 0x01                     ; Carry Flag bit mask
  CPU_C_bp = 0                        ; Carry Flag bit position
  CPU_Z_bm = 0x02                     ; Zero Flag bit mask
  CPU_Z_bp = 1                        ; Zero Flag bit position
  CPU_N_bm = 0x04                     ; Negative Flag bit mask
  CPU_N_bp = 2                        ; Negative Flag bit position
  CPU_V_bm = 0x08                     ; Two's Complement Overflow Flag bit mask
  CPU_V_bp = 3                        ; Two's Complement Overflow Flag bit position
  CPU_S_bm = 0x10                     ; N Exclusive Or V Flag bit mask
  CPU_S_bp = 4                        ; N Exclusive Or V Flag bit position
  CPU_H_bm = 0x20                     ; Half Carry Flag bit mask
  CPU_H_bp = 5                        ; Half Carry Flag bit position
  CPU_T_bm = 0x40                     ; Transfer Bit bit mask
  CPU_T_bp = 6                        ; Transfer Bit bit position
  CPU_I_bm = 0x80                     ; Global Interrupt Enable Flag bit mask
  CPU_I_bp = 7                        ; Global Interrupt Enable Flag bit position
  
  ; CCP signature select
  CPU_CCP_SPM_gc = (0x9D<<0)          ; SPM Instruction Protection
  CPU_CCP_IOREG_gc = (0xD8<<0)        ; IO Register Protection
  
  
  ;*************************************************************************
  ;** CPUINT - Interrupt Controller
  ;*************************************************************************
  
  ; CPUINT_CTRLA masks
  CPUINT_LVL0RR_bm = 0x01             ; Round-robin Scheduling Enable bit mask
  CPUINT_LVL0RR_bp = 0                ; Round-robin Scheduling Enable bit position
  CPUINT_CVT_bm = 0x20                ; Compact Vector Table bit mask
  CPUINT_CVT_bp = 5                   ; Compact Vector Table bit position
  CPUINT_IVSEL_bm = 0x40              ; Interrupt Vector Select bit mask
  CPUINT_IVSEL_bp = 6                 ; Interrupt Vector Select bit position
  
  ; CPUINT_STATUS masks
  CPUINT_LVL0EX_bm = 0x01             ; Level 0 Interrupt Executing bit mask
  CPUINT_LVL0EX_bp = 0                ; Level 0 Interrupt Executing bit position
  CPUINT_LVL1EX_bm = 0x02             ; Level 1 Interrupt Executing bit mask
  CPUINT_LVL1EX_bp = 1                ; Level 1 Interrupt Executing bit position
  CPUINT_NMIEX_bm = 0x80              ; Non-maskable Interrupt Executing bit mask
  CPUINT_NMIEX_bp = 7                 ; Non-maskable Interrupt Executing bit position
  
  ; CPUINT_LVL0PRI masks
  CPUINT_LVL0PRI_gm = 0xFF            ; Interrupt Level Priority group mask
  CPUINT_LVL0PRI_gp = 0               ; Interrupt Level Priority group position
  CPUINT_LVL0PRI_0_bm = (1<<0)        ; Interrupt Level Priority bit 0 mask
  CPUINT_LVL0PRI_0_bp = 0             ; Interrupt Level Priority bit 0 position
  CPUINT_LVL0PRI_1_bm = (1<<1)        ; Interrupt Level Priority bit 1 mask
  CPUINT_LVL0PRI_1_bp = 1             ; Interrupt Level Priority bit 1 position
  CPUINT_LVL0PRI_2_bm = (1<<2)        ; Interrupt Level Priority bit 2 mask
  CPUINT_LVL0PRI_2_bp = 2             ; Interrupt Level Priority bit 2 position
  CPUINT_LVL0PRI_3_bm = (1<<3)        ; Interrupt Level Priority bit 3 mask
  CPUINT_LVL0PRI_3_bp = 3             ; Interrupt Level Priority bit 3 position
  CPUINT_LVL0PRI_4_bm = (1<<4)        ; Interrupt Level Priority bit 4 mask
  CPUINT_LVL0PRI_4_bp = 4             ; Interrupt Level Priority bit 4 position
  CPUINT_LVL0PRI_5_bm = (1<<5)        ; Interrupt Level Priority bit 5 mask
  CPUINT_LVL0PRI_5_bp = 5             ; Interrupt Level Priority bit 5 position
  CPUINT_LVL0PRI_6_bm = (1<<6)        ; Interrupt Level Priority bit 6 mask
  CPUINT_LVL0PRI_6_bp = 6             ; Interrupt Level Priority bit 6 position
  CPUINT_LVL0PRI_7_bm = (1<<7)        ; Interrupt Level Priority bit 7 mask
  CPUINT_LVL0PRI_7_bp = 7             ; Interrupt Level Priority bit 7 position
  
  ; CPUINT_LVL1VEC masks
  CPUINT_LVL1VEC_gm = 0xFF            ; Interrupt Vector with High Priority group mask
  CPUINT_LVL1VEC_gp = 0               ; Interrupt Vector with High Priority group position
  CPUINT_LVL1VEC_0_bm = (1<<0)        ; Interrupt Vector with High Priority bit 0 mask
  CPUINT_LVL1VEC_0_bp = 0             ; Interrupt Vector with High Priority bit 0 position
  CPUINT_LVL1VEC_1_bm = (1<<1)        ; Interrupt Vector with High Priority bit 1 mask
  CPUINT_LVL1VEC_1_bp = 1             ; Interrupt Vector with High Priority bit 1 position
  CPUINT_LVL1VEC_2_bm = (1<<2)        ; Interrupt Vector with High Priority bit 2 mask
  CPUINT_LVL1VEC_2_bp = 2             ; Interrupt Vector with High Priority bit 2 position
  CPUINT_LVL1VEC_3_bm = (1<<3)        ; Interrupt Vector with High Priority bit 3 mask
  CPUINT_LVL1VEC_3_bp = 3             ; Interrupt Vector with High Priority bit 3 position
  CPUINT_LVL1VEC_4_bm = (1<<4)        ; Interrupt Vector with High Priority bit 4 mask
  CPUINT_LVL1VEC_4_bp = 4             ; Interrupt Vector with High Priority bit 4 position
  CPUINT_LVL1VEC_5_bm = (1<<5)        ; Interrupt Vector with High Priority bit 5 mask
  CPUINT_LVL1VEC_5_bp = 5             ; Interrupt Vector with High Priority bit 5 position
  CPUINT_LVL1VEC_6_bm = (1<<6)        ; Interrupt Vector with High Priority bit 6 mask
  CPUINT_LVL1VEC_6_bp = 6             ; Interrupt Vector with High Priority bit 6 position
  CPUINT_LVL1VEC_7_bm = (1<<7)        ; Interrupt Vector with High Priority bit 7 mask
  CPUINT_LVL1VEC_7_bp = 7             ; Interrupt Vector with High Priority bit 7 position
  
  
  ;*************************************************************************
  ;** CRCSCAN - CRCSCAN
  ;*************************************************************************
  
  ; CRCSCAN_CTRLA masks
  CRCSCAN_ENABLE_bm = 0x01            ; Enable CRC scan bit mask
  CRCSCAN_ENABLE_bp = 0               ; Enable CRC scan bit position
  CRCSCAN_NMIEN_bm = 0x02             ; Enable NMI Trigger bit mask
  CRCSCAN_NMIEN_bp = 1                ; Enable NMI Trigger bit position
  CRCSCAN_RESET_bm = 0x80             ; Reset CRC scan bit mask
  CRCSCAN_RESET_bp = 7                ; Reset CRC scan bit position
  
  ; CRCSCAN_CTRLB masks
  CRCSCAN_SRC_gm = 0x03               ; CRC Source group mask
  CRCSCAN_SRC_gp = 0                  ; CRC Source group position
  CRCSCAN_SRC_0_bm = (1<<0)           ; CRC Source bit 0 mask
  CRCSCAN_SRC_0_bp = 0                ; CRC Source bit 0 position
  CRCSCAN_SRC_1_bm = (1<<1)           ; CRC Source bit 1 mask
  CRCSCAN_SRC_1_bp = 1                ; CRC Source bit 1 position
  CRCSCAN_MODE_gm = 0x30              ; CRC Flash Access Mode group mask
  CRCSCAN_MODE_gp = 4                 ; CRC Flash Access Mode group position
  CRCSCAN_MODE_0_bm = (1<<4)          ; CRC Flash Access Mode bit 0 mask
  CRCSCAN_MODE_0_bp = 4               ; CRC Flash Access Mode bit 0 position
  CRCSCAN_MODE_1_bm = (1<<5)          ; CRC Flash Access Mode bit 1 mask
  CRCSCAN_MODE_1_bp = 5               ; CRC Flash Access Mode bit 1 position
  
  ; CRCSCAN_STATUS masks
  CRCSCAN_BUSY_bm = 0x01              ; CRC Busy bit mask
  CRCSCAN_BUSY_bp = 0                 ; CRC Busy bit position
  CRCSCAN_OK_bm = 0x02                ; CRC Ok bit mask
  CRCSCAN_OK_bp = 1                   ; CRC Ok bit position
  
  ; CRC Flash Access Mode select
  CRCSCAN_MODE_PRIORITY_gc = (0x00<<4) ; Priority to flash
  
  ; CRC Source select
  CRCSCAN_SRC_FLASH_gc = (0x00<<0)    ; CRC on entire flash
  CRCSCAN_SRC_APPLICATION_gc = (0x01<<0) ; CRC on boot and appl section of flash
  CRCSCAN_SRC_BOOT_gc = (0x02<<0)     ; CRC on boot section of flash
  
  
  ;*************************************************************************
  ;** EVSYS - Event System
  ;*************************************************************************
  
  ; EVSYS_SWEVENTA masks
  EVSYS_SWEVENTA_gm = 0xFF            ; Software event on channel group mask
  EVSYS_SWEVENTA_gp = 0               ; Software event on channel group position
  EVSYS_SWEVENTA_0_bm = (1<<0)        ; Software event on channel bit 0 mask
  EVSYS_SWEVENTA_0_bp = 0             ; Software event on channel bit 0 position
  EVSYS_SWEVENTA_1_bm = (1<<1)        ; Software event on channel bit 1 mask
  EVSYS_SWEVENTA_1_bp = 1             ; Software event on channel bit 1 position
  EVSYS_SWEVENTA_2_bm = (1<<2)        ; Software event on channel bit 2 mask
  EVSYS_SWEVENTA_2_bp = 2             ; Software event on channel bit 2 position
  EVSYS_SWEVENTA_3_bm = (1<<3)        ; Software event on channel bit 3 mask
  EVSYS_SWEVENTA_3_bp = 3             ; Software event on channel bit 3 position
  EVSYS_SWEVENTA_4_bm = (1<<4)        ; Software event on channel bit 4 mask
  EVSYS_SWEVENTA_4_bp = 4             ; Software event on channel bit 4 position
  EVSYS_SWEVENTA_5_bm = (1<<5)        ; Software event on channel bit 5 mask
  EVSYS_SWEVENTA_5_bp = 5             ; Software event on channel bit 5 position
  EVSYS_SWEVENTA_6_bm = (1<<6)        ; Software event on channel bit 6 mask
  EVSYS_SWEVENTA_6_bp = 6             ; Software event on channel bit 6 position
  EVSYS_SWEVENTA_7_bm = (1<<7)        ; Software event on channel bit 7 mask
  EVSYS_SWEVENTA_7_bp = 7             ; Software event on channel bit 7 position
  
  ; EVSYS_CHANNEL0 masks
  EVSYS_CHANNEL0_gm = 0xFF            ; Channel 0 generator select group mask
  EVSYS_CHANNEL0_gp = 0               ; Channel 0 generator select group position
  EVSYS_CHANNEL0_0_bm = (1<<0)        ; Channel 0 generator select bit 0 mask
  EVSYS_CHANNEL0_0_bp = 0             ; Channel 0 generator select bit 0 position
  EVSYS_CHANNEL0_1_bm = (1<<1)        ; Channel 0 generator select bit 1 mask
  EVSYS_CHANNEL0_1_bp = 1             ; Channel 0 generator select bit 1 position
  EVSYS_CHANNEL0_2_bm = (1<<2)        ; Channel 0 generator select bit 2 mask
  EVSYS_CHANNEL0_2_bp = 2             ; Channel 0 generator select bit 2 position
  EVSYS_CHANNEL0_3_bm = (1<<3)        ; Channel 0 generator select bit 3 mask
  EVSYS_CHANNEL0_3_bp = 3             ; Channel 0 generator select bit 3 position
  EVSYS_CHANNEL0_4_bm = (1<<4)        ; Channel 0 generator select bit 4 mask
  EVSYS_CHANNEL0_4_bp = 4             ; Channel 0 generator select bit 4 position
  EVSYS_CHANNEL0_5_bm = (1<<5)        ; Channel 0 generator select bit 5 mask
  EVSYS_CHANNEL0_5_bp = 5             ; Channel 0 generator select bit 5 position
  EVSYS_CHANNEL0_6_bm = (1<<6)        ; Channel 0 generator select bit 6 mask
  EVSYS_CHANNEL0_6_bp = 6             ; Channel 0 generator select bit 6 position
  EVSYS_CHANNEL0_7_bm = (1<<7)        ; Channel 0 generator select bit 7 mask
  EVSYS_CHANNEL0_7_bp = 7             ; Channel 0 generator select bit 7 position
  
  ; EVSYS_CHANNEL1 masks
  EVSYS_CHANNEL1_gm = 0xFF            ; Channel 1 generator select group mask
  EVSYS_CHANNEL1_gp = 0               ; Channel 1 generator select group position
  EVSYS_CHANNEL1_0_bm = (1<<0)        ; Channel 1 generator select bit 0 mask
  EVSYS_CHANNEL1_0_bp = 0             ; Channel 1 generator select bit 0 position
  EVSYS_CHANNEL1_1_bm = (1<<1)        ; Channel 1 generator select bit 1 mask
  EVSYS_CHANNEL1_1_bp = 1             ; Channel 1 generator select bit 1 position
  EVSYS_CHANNEL1_2_bm = (1<<2)        ; Channel 1 generator select bit 2 mask
  EVSYS_CHANNEL1_2_bp = 2             ; Channel 1 generator select bit 2 position
  EVSYS_CHANNEL1_3_bm = (1<<3)        ; Channel 1 generator select bit 3 mask
  EVSYS_CHANNEL1_3_bp = 3             ; Channel 1 generator select bit 3 position
  EVSYS_CHANNEL1_4_bm = (1<<4)        ; Channel 1 generator select bit 4 mask
  EVSYS_CHANNEL1_4_bp = 4             ; Channel 1 generator select bit 4 position
  EVSYS_CHANNEL1_5_bm = (1<<5)        ; Channel 1 generator select bit 5 mask
  EVSYS_CHANNEL1_5_bp = 5             ; Channel 1 generator select bit 5 position
  EVSYS_CHANNEL1_6_bm = (1<<6)        ; Channel 1 generator select bit 6 mask
  EVSYS_CHANNEL1_6_bp = 6             ; Channel 1 generator select bit 6 position
  EVSYS_CHANNEL1_7_bm = (1<<7)        ; Channel 1 generator select bit 7 mask
  EVSYS_CHANNEL1_7_bp = 7             ; Channel 1 generator select bit 7 position
  
  ; EVSYS_CHANNEL2 masks
  EVSYS_CHANNEL2_gm = 0xFF            ; Channel 2 generator select group mask
  EVSYS_CHANNEL2_gp = 0               ; Channel 2 generator select group position
  EVSYS_CHANNEL2_0_bm = (1<<0)        ; Channel 2 generator select bit 0 mask
  EVSYS_CHANNEL2_0_bp = 0             ; Channel 2 generator select bit 0 position
  EVSYS_CHANNEL2_1_bm = (1<<1)        ; Channel 2 generator select bit 1 mask
  EVSYS_CHANNEL2_1_bp = 1             ; Channel 2 generator select bit 1 position
  EVSYS_CHANNEL2_2_bm = (1<<2)        ; Channel 2 generator select bit 2 mask
  EVSYS_CHANNEL2_2_bp = 2             ; Channel 2 generator select bit 2 position
  EVSYS_CHANNEL2_3_bm = (1<<3)        ; Channel 2 generator select bit 3 mask
  EVSYS_CHANNEL2_3_bp = 3             ; Channel 2 generator select bit 3 position
  EVSYS_CHANNEL2_4_bm = (1<<4)        ; Channel 2 generator select bit 4 mask
  EVSYS_CHANNEL2_4_bp = 4             ; Channel 2 generator select bit 4 position
  EVSYS_CHANNEL2_5_bm = (1<<5)        ; Channel 2 generator select bit 5 mask
  EVSYS_CHANNEL2_5_bp = 5             ; Channel 2 generator select bit 5 position
  EVSYS_CHANNEL2_6_bm = (1<<6)        ; Channel 2 generator select bit 6 mask
  EVSYS_CHANNEL2_6_bp = 6             ; Channel 2 generator select bit 6 position
  EVSYS_CHANNEL2_7_bm = (1<<7)        ; Channel 2 generator select bit 7 mask
  EVSYS_CHANNEL2_7_bp = 7             ; Channel 2 generator select bit 7 position
  
  ; EVSYS_CHANNEL3 masks
  EVSYS_CHANNEL3_gm = 0xFF            ; Channel 3 generator select group mask
  EVSYS_CHANNEL3_gp = 0               ; Channel 3 generator select group position
  EVSYS_CHANNEL3_0_bm = (1<<0)        ; Channel 3 generator select bit 0 mask
  EVSYS_CHANNEL3_0_bp = 0             ; Channel 3 generator select bit 0 position
  EVSYS_CHANNEL3_1_bm = (1<<1)        ; Channel 3 generator select bit 1 mask
  EVSYS_CHANNEL3_1_bp = 1             ; Channel 3 generator select bit 1 position
  EVSYS_CHANNEL3_2_bm = (1<<2)        ; Channel 3 generator select bit 2 mask
  EVSYS_CHANNEL3_2_bp = 2             ; Channel 3 generator select bit 2 position
  EVSYS_CHANNEL3_3_bm = (1<<3)        ; Channel 3 generator select bit 3 mask
  EVSYS_CHANNEL3_3_bp = 3             ; Channel 3 generator select bit 3 position
  EVSYS_CHANNEL3_4_bm = (1<<4)        ; Channel 3 generator select bit 4 mask
  EVSYS_CHANNEL3_4_bp = 4             ; Channel 3 generator select bit 4 position
  EVSYS_CHANNEL3_5_bm = (1<<5)        ; Channel 3 generator select bit 5 mask
  EVSYS_CHANNEL3_5_bp = 5             ; Channel 3 generator select bit 5 position
  EVSYS_CHANNEL3_6_bm = (1<<6)        ; Channel 3 generator select bit 6 mask
  EVSYS_CHANNEL3_6_bp = 6             ; Channel 3 generator select bit 6 position
  EVSYS_CHANNEL3_7_bm = (1<<7)        ; Channel 3 generator select bit 7 mask
  EVSYS_CHANNEL3_7_bp = 7             ; Channel 3 generator select bit 7 position
  
  ; EVSYS_CHANNEL4 masks
  EVSYS_CHANNEL4_gm = 0xFF            ; Channel 4 generator select group mask
  EVSYS_CHANNEL4_gp = 0               ; Channel 4 generator select group position
  EVSYS_CHANNEL4_0_bm = (1<<0)        ; Channel 4 generator select bit 0 mask
  EVSYS_CHANNEL4_0_bp = 0             ; Channel 4 generator select bit 0 position
  EVSYS_CHANNEL4_1_bm = (1<<1)        ; Channel 4 generator select bit 1 mask
  EVSYS_CHANNEL4_1_bp = 1             ; Channel 4 generator select bit 1 position
  EVSYS_CHANNEL4_2_bm = (1<<2)        ; Channel 4 generator select bit 2 mask
  EVSYS_CHANNEL4_2_bp = 2             ; Channel 4 generator select bit 2 position
  EVSYS_CHANNEL4_3_bm = (1<<3)        ; Channel 4 generator select bit 3 mask
  EVSYS_CHANNEL4_3_bp = 3             ; Channel 4 generator select bit 3 position
  EVSYS_CHANNEL4_4_bm = (1<<4)        ; Channel 4 generator select bit 4 mask
  EVSYS_CHANNEL4_4_bp = 4             ; Channel 4 generator select bit 4 position
  EVSYS_CHANNEL4_5_bm = (1<<5)        ; Channel 4 generator select bit 5 mask
  EVSYS_CHANNEL4_5_bp = 5             ; Channel 4 generator select bit 5 position
  EVSYS_CHANNEL4_6_bm = (1<<6)        ; Channel 4 generator select bit 6 mask
  EVSYS_CHANNEL4_6_bp = 6             ; Channel 4 generator select bit 6 position
  EVSYS_CHANNEL4_7_bm = (1<<7)        ; Channel 4 generator select bit 7 mask
  EVSYS_CHANNEL4_7_bp = 7             ; Channel 4 generator select bit 7 position
  
  ; EVSYS_CHANNEL5 masks
  EVSYS_CHANNEL5_gm = 0xFF            ; Channel 5 generator select group mask
  EVSYS_CHANNEL5_gp = 0               ; Channel 5 generator select group position
  EVSYS_CHANNEL5_0_bm = (1<<0)        ; Channel 5 generator select bit 0 mask
  EVSYS_CHANNEL5_0_bp = 0             ; Channel 5 generator select bit 0 position
  EVSYS_CHANNEL5_1_bm = (1<<1)        ; Channel 5 generator select bit 1 mask
  EVSYS_CHANNEL5_1_bp = 1             ; Channel 5 generator select bit 1 position
  EVSYS_CHANNEL5_2_bm = (1<<2)        ; Channel 5 generator select bit 2 mask
  EVSYS_CHANNEL5_2_bp = 2             ; Channel 5 generator select bit 2 position
  EVSYS_CHANNEL5_3_bm = (1<<3)        ; Channel 5 generator select bit 3 mask
  EVSYS_CHANNEL5_3_bp = 3             ; Channel 5 generator select bit 3 position
  EVSYS_CHANNEL5_4_bm = (1<<4)        ; Channel 5 generator select bit 4 mask
  EVSYS_CHANNEL5_4_bp = 4             ; Channel 5 generator select bit 4 position
  EVSYS_CHANNEL5_5_bm = (1<<5)        ; Channel 5 generator select bit 5 mask
  EVSYS_CHANNEL5_5_bp = 5             ; Channel 5 generator select bit 5 position
  EVSYS_CHANNEL5_6_bm = (1<<6)        ; Channel 5 generator select bit 6 mask
  EVSYS_CHANNEL5_6_bp = 6             ; Channel 5 generator select bit 6 position
  EVSYS_CHANNEL5_7_bm = (1<<7)        ; Channel 5 generator select bit 7 mask
  EVSYS_CHANNEL5_7_bp = 7             ; Channel 5 generator select bit 7 position
  
  ; EVSYS_USERCCLLUT0A masks
  EVSYS_USER_gm = 0xFF                ; Channel selector group mask
  EVSYS_USER_gp = 0                   ; Channel selector group position
  EVSYS_USER_0_bm = (1<<0)            ; Channel selector bit 0 mask
  EVSYS_USER_0_bp = 0                 ; Channel selector bit 0 position
  EVSYS_USER_1_bm = (1<<1)            ; Channel selector bit 1 mask
  EVSYS_USER_1_bp = 1                 ; Channel selector bit 1 position
  EVSYS_USER_2_bm = (1<<2)            ; Channel selector bit 2 mask
  EVSYS_USER_2_bp = 2                 ; Channel selector bit 2 position
  EVSYS_USER_3_bm = (1<<3)            ; Channel selector bit 3 mask
  EVSYS_USER_3_bp = 3                 ; Channel selector bit 3 position
  EVSYS_USER_4_bm = (1<<4)            ; Channel selector bit 4 mask
  EVSYS_USER_4_bp = 4                 ; Channel selector bit 4 position
  EVSYS_USER_5_bm = (1<<5)            ; Channel selector bit 5 mask
  EVSYS_USER_5_bp = 5                 ; Channel selector bit 5 position
  EVSYS_USER_6_bm = (1<<6)            ; Channel selector bit 6 mask
  EVSYS_USER_6_bp = 6                 ; Channel selector bit 6 position
  EVSYS_USER_7_bm = (1<<7)            ; Channel selector bit 7 mask
  EVSYS_USER_7_bp = 7                 ; Channel selector bit 7 position
  
  ; EVSYS_USERCCLLUT0B masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT1A masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT1B masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT2A masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT2B masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT3A masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT3B masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERADC0START masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USEREVSYSEVOUTA masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USEREVSYSEVOUTB masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USEREVSYSEVOUTC masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERUSART0IRDA masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERUSART1IRDA masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCA0CNTA masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCA0CNTB masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB0CAPT masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB0COUNT masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB1CAPT masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB1COUNT masks
  ; Masks for EVSYS_USER already defined
  
  ; Channel 0 generator select
  EVSYS_CHANNEL0_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL0_UPDI_gc = (0x01<<0)  ; Unified Program and Debug Interface
  EVSYS_CHANNEL0_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL0_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL0_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL0_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL0_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL0_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL0_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL0_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL0_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL0_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL0_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL0_ADC0_RES_gc = (0x24<<0) ; ADC 0 Result ready event
  EVSYS_CHANNEL0_ADC0_SAMP_gc = (0x25<<0) ; ADC 0 Sample ready event
  EVSYS_CHANNEL0_ADC0_WCMP_gc = (0x26<<0) ; ADC 0 Window compare match event
  EVSYS_CHANNEL0_PORTA_PIN0_gc = (0x40<<0) ; Port A Pin 0
  EVSYS_CHANNEL0_PORTA_PIN1_gc = (0x41<<0) ; Port A Pin 1
  EVSYS_CHANNEL0_PORTA_PIN2_gc = (0x42<<0) ; Port A Pin 2
  EVSYS_CHANNEL0_PORTA_PIN3_gc = (0x43<<0) ; Port A Pin 3
  EVSYS_CHANNEL0_PORTA_PIN4_gc = (0x44<<0) ; Port A Pin 4
  EVSYS_CHANNEL0_PORTA_PIN5_gc = (0x45<<0) ; Port A Pin 5
  EVSYS_CHANNEL0_PORTA_PIN6_gc = (0x46<<0) ; Port A Pin 6
  EVSYS_CHANNEL0_PORTA_PIN7_gc = (0x47<<0) ; Port A Pin 7
  EVSYS_CHANNEL0_PORTB_PIN0_gc = (0x48<<0) ; Port B Pin 0
  EVSYS_CHANNEL0_PORTB_PIN1_gc = (0x49<<0) ; Port B Pin 1
  EVSYS_CHANNEL0_PORTB_PIN2_gc = (0x4A<<0) ; Port B Pin 2
  EVSYS_CHANNEL0_PORTB_PIN3_gc = (0x4B<<0) ; Port B Pin 3
  EVSYS_CHANNEL0_PORTB_PIN4_gc = (0x4C<<0) ; Port B Pin 4
  EVSYS_CHANNEL0_PORTB_PIN5_gc = (0x4D<<0) ; Port B Pin 5
  EVSYS_CHANNEL0_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL0_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL0_SPI0_SCK_gc = (0x68<<0) ; SPI 0 Sclock
  EVSYS_CHANNEL0_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte underflow
  EVSYS_CHANNEL0_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte underflow
  EVSYS_CHANNEL0_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL0_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL0_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL0_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL0_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL0_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL0_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  
  ; Channel 1 generator select
  EVSYS_CHANNEL1_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL1_UPDI_gc = (0x01<<0)  ; Unified Program and Debug Interface
  EVSYS_CHANNEL1_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL1_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL1_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL1_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL1_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL1_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL1_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL1_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL1_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL1_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL1_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL1_ADC0_RES_gc = (0x24<<0) ; ADC 0 Result ready event
  EVSYS_CHANNEL1_ADC0_SAMP_gc = (0x25<<0) ; ADC 0 Sample ready event
  EVSYS_CHANNEL1_ADC0_WCMP_gc = (0x26<<0) ; ADC 0 Window compare match event
  EVSYS_CHANNEL1_PORTA_PIN0_gc = (0x40<<0) ; Port A Pin 0
  EVSYS_CHANNEL1_PORTA_PIN1_gc = (0x41<<0) ; Port A Pin 1
  EVSYS_CHANNEL1_PORTA_PIN2_gc = (0x42<<0) ; Port A Pin 2
  EVSYS_CHANNEL1_PORTA_PIN3_gc = (0x43<<0) ; Port A Pin 3
  EVSYS_CHANNEL1_PORTA_PIN4_gc = (0x44<<0) ; Port A Pin 4
  EVSYS_CHANNEL1_PORTA_PIN5_gc = (0x45<<0) ; Port A Pin 5
  EVSYS_CHANNEL1_PORTA_PIN6_gc = (0x46<<0) ; Port A Pin 6
  EVSYS_CHANNEL1_PORTA_PIN7_gc = (0x47<<0) ; Port A Pin 7
  EVSYS_CHANNEL1_PORTB_PIN0_gc = (0x48<<0) ; Port B Pin 0
  EVSYS_CHANNEL1_PORTB_PIN1_gc = (0x49<<0) ; Port B Pin 1
  EVSYS_CHANNEL1_PORTB_PIN2_gc = (0x4A<<0) ; Port B Pin 2
  EVSYS_CHANNEL1_PORTB_PIN3_gc = (0x4B<<0) ; Port B Pin 3
  EVSYS_CHANNEL1_PORTB_PIN4_gc = (0x4C<<0) ; Port B Pin 4
  EVSYS_CHANNEL1_PORTB_PIN5_gc = (0x4D<<0) ; Port B Pin 5
  EVSYS_CHANNEL1_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL1_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL1_SPI0_SCK_gc = (0x68<<0) ; SPI 0 Sclock
  EVSYS_CHANNEL1_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte underflow
  EVSYS_CHANNEL1_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte underflow
  EVSYS_CHANNEL1_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL1_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL1_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL1_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL1_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL1_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL1_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  
  ; Channel 2 generator select
  EVSYS_CHANNEL2_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL2_UPDI_gc = (0x01<<0)  ; Unified Program and Debug Interface
  EVSYS_CHANNEL2_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL2_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL2_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL2_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL2_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL2_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL2_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL2_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL2_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL2_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL2_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL2_ADC0_RES_gc = (0x24<<0) ; ADC 0 Result ready event
  EVSYS_CHANNEL2_ADC0_SAMP_gc = (0x25<<0) ; ADC 0 Sample ready event
  EVSYS_CHANNEL2_ADC0_WCMP_gc = (0x26<<0) ; ADC 0 Window compare match event
  EVSYS_CHANNEL2_PORTC_PIN0_gc = (0x40<<0) ; Port C Pin 0
  EVSYS_CHANNEL2_PORTC_PIN1_gc = (0x41<<0) ; Port C Pin 1
  EVSYS_CHANNEL2_PORTC_PIN2_gc = (0x42<<0) ; Port C Pin 2
  EVSYS_CHANNEL2_PORTC_PIN3_gc = (0x43<<0) ; Port C Pin 3
  EVSYS_CHANNEL2_PORTA_PIN0_gc = (0x48<<0) ; Port A Pin 0
  EVSYS_CHANNEL2_PORTA_PIN1_gc = (0x49<<0) ; Port A Pin 1
  EVSYS_CHANNEL2_PORTA_PIN2_gc = (0x4A<<0) ; Port A Pin 2
  EVSYS_CHANNEL2_PORTA_PIN3_gc = (0x4B<<0) ; Port A Pin 3
  EVSYS_CHANNEL2_PORTA_PIN4_gc = (0x4C<<0) ; Port A Pin 4
  EVSYS_CHANNEL2_PORTA_PIN5_gc = (0x4D<<0) ; Port A Pin 5
  EVSYS_CHANNEL2_PORTA_PIN6_gc = (0x4E<<0) ; Port A Pin 6
  EVSYS_CHANNEL2_PORTA_PIN7_gc = (0x4F<<0) ; Port A Pin 7
  EVSYS_CHANNEL2_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL2_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL2_SPI0_SCK_gc = (0x68<<0) ; SPI 0 Sclock
  EVSYS_CHANNEL2_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte underflow
  EVSYS_CHANNEL2_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte underflow
  EVSYS_CHANNEL2_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL2_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL2_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL2_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL2_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL2_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL2_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  
  ; Channel 3 generator select
  EVSYS_CHANNEL3_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL3_UPDI_gc = (0x01<<0)  ; Unified Program and Debug Interface
  EVSYS_CHANNEL3_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL3_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL3_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL3_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL3_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL3_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL3_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL3_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL3_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL3_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL3_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL3_ADC0_RES_gc = (0x24<<0) ; ADC 0 Result ready event
  EVSYS_CHANNEL3_ADC0_SAMP_gc = (0x25<<0) ; ADC 0 Sample ready event
  EVSYS_CHANNEL3_ADC0_WCMP_gc = (0x26<<0) ; ADC 0 Window compare match event
  EVSYS_CHANNEL3_PORTC_PIN0_gc = (0x40<<0) ; Port C Pin 0
  EVSYS_CHANNEL3_PORTC_PIN1_gc = (0x41<<0) ; Port C Pin 1
  EVSYS_CHANNEL3_PORTC_PIN2_gc = (0x42<<0) ; Port C Pin 2
  EVSYS_CHANNEL3_PORTC_PIN3_gc = (0x43<<0) ; Port C Pin 3
  EVSYS_CHANNEL3_PORTA_PIN0_gc = (0x48<<0) ; Port A Pin 0
  EVSYS_CHANNEL3_PORTA_PIN1_gc = (0x49<<0) ; Port A Pin 1
  EVSYS_CHANNEL3_PORTA_PIN2_gc = (0x4A<<0) ; Port A Pin 2
  EVSYS_CHANNEL3_PORTA_PIN3_gc = (0x4B<<0) ; Port A Pin 3
  EVSYS_CHANNEL3_PORTA_PIN4_gc = (0x4C<<0) ; Port A Pin 4
  EVSYS_CHANNEL3_PORTA_PIN5_gc = (0x4D<<0) ; Port A Pin 5
  EVSYS_CHANNEL3_PORTA_PIN6_gc = (0x4E<<0) ; Port A Pin 6
  EVSYS_CHANNEL3_PORTA_PIN7_gc = (0x4F<<0) ; Port A Pin 7
  EVSYS_CHANNEL3_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL3_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL3_SPI0_SCK_gc = (0x68<<0) ; SPI 0 Sclock
  EVSYS_CHANNEL3_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte underflow
  EVSYS_CHANNEL3_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte underflow
  EVSYS_CHANNEL3_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL3_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL3_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL3_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL3_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL3_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL3_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  
  ; Channel 4 generator select
  EVSYS_CHANNEL4_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL4_UPDI_gc = (0x01<<0)  ; Unified Program and Debug Interface
  EVSYS_CHANNEL4_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL4_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL4_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL4_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL4_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL4_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL4_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL4_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL4_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL4_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL4_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL4_ADC0_RES_gc = (0x24<<0) ; ADC 0 Result ready event
  EVSYS_CHANNEL4_ADC0_SAMP_gc = (0x25<<0) ; ADC 0 Sample ready event
  EVSYS_CHANNEL4_ADC0_WCMP_gc = (0x26<<0) ; ADC 0 Window compare match event
  EVSYS_CHANNEL4_PORTB_PIN0_gc = (0x40<<0) ; Port B Pin 0
  EVSYS_CHANNEL4_PORTB_PIN1_gc = (0x41<<0) ; Port B Pin 1
  EVSYS_CHANNEL4_PORTB_PIN2_gc = (0x42<<0) ; Port B Pin 2
  EVSYS_CHANNEL4_PORTB_PIN3_gc = (0x43<<0) ; Port B Pin 3
  EVSYS_CHANNEL4_PORTB_PIN4_gc = (0x44<<0) ; Port B Pin 4
  EVSYS_CHANNEL4_PORTB_PIN5_gc = (0x45<<0) ; Port B Pin 5
  EVSYS_CHANNEL4_PORTC_PIN0_gc = (0x48<<0) ; Port C Pin 0
  EVSYS_CHANNEL4_PORTC_PIN1_gc = (0x49<<0) ; Port C Pin 1
  EVSYS_CHANNEL4_PORTC_PIN2_gc = (0x4A<<0) ; Port C Pin 2
  EVSYS_CHANNEL4_PORTC_PIN3_gc = (0x4B<<0) ; Port C Pin 3
  EVSYS_CHANNEL4_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL4_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL4_SPI0_SCK_gc = (0x68<<0) ; SPI 0 Sclock
  EVSYS_CHANNEL4_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte underflow
  EVSYS_CHANNEL4_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte underflow
  EVSYS_CHANNEL4_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL4_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL4_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL4_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL4_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL4_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL4_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  
  ; Channel 5 generator select
  EVSYS_CHANNEL5_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL5_UPDI_gc = (0x01<<0)  ; Unified Program and Debug Interface
  EVSYS_CHANNEL5_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL5_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL5_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL5_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL5_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL5_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL5_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL5_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL5_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL5_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL5_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL5_ADC0_RES_gc = (0x24<<0) ; ADC 0 Result ready event
  EVSYS_CHANNEL5_ADC0_SAMP_gc = (0x25<<0) ; ADC 0 Sample ready event
  EVSYS_CHANNEL5_ADC0_WCMP_gc = (0x26<<0) ; ADC 0 Window compare match event
  EVSYS_CHANNEL5_PORTB_PIN0_gc = (0x40<<0) ; Port B Pin 0
  EVSYS_CHANNEL5_PORTB_PIN1_gc = (0x41<<0) ; Port B Pin 1
  EVSYS_CHANNEL5_PORTB_PIN2_gc = (0x42<<0) ; Port B Pin 2
  EVSYS_CHANNEL5_PORTB_PIN3_gc = (0x43<<0) ; Port B Pin 3
  EVSYS_CHANNEL5_PORTB_PIN4_gc = (0x44<<0) ; Port B Pin 4
  EVSYS_CHANNEL5_PORTB_PIN5_gc = (0x45<<0) ; Port B Pin 5
  EVSYS_CHANNEL5_PORTC_PIN0_gc = (0x48<<0) ; Port C Pin 0
  EVSYS_CHANNEL5_PORTC_PIN1_gc = (0x49<<0) ; Port C Pin 1
  EVSYS_CHANNEL5_PORTC_PIN2_gc = (0x4A<<0) ; Port C Pin 2
  EVSYS_CHANNEL5_PORTC_PIN3_gc = (0x4B<<0) ; Port C Pin 3
  EVSYS_CHANNEL5_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL5_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL5_SPI0_SCK_gc = (0x68<<0) ; SPI 0 Sclock
  EVSYS_CHANNEL5_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte underflow
  EVSYS_CHANNEL5_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte underflow
  EVSYS_CHANNEL5_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL5_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL5_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL5_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL5_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL5_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL5_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  
  ; Software event on channel select
  EVSYS_SWEVENTA_CH0_gc = (0x01<<0)   ; Software event on channel 0
  EVSYS_SWEVENTA_CH1_gc = (0x02<<0)   ; Software event on channel 1
  EVSYS_SWEVENTA_CH2_gc = (0x04<<0)   ; Software event on channel 2
  EVSYS_SWEVENTA_CH3_gc = (0x08<<0)   ; Software event on channel 3
  EVSYS_SWEVENTA_CH4_gc = (0x10<<0)   ; Software event on channel 4
  EVSYS_SWEVENTA_CH5_gc = (0x20<<0)   ; Software event on channel 5
  
  ; Channel selector
  EVSYS_USER_OFF_gc = (0x00<<0)       ; Off
  EVSYS_USER_CHANNEL0_gc = (0x01<<0)  ; Connect user to event channel 0
  EVSYS_USER_CHANNEL1_gc = (0x02<<0)  ; Connect user to event channel 1
  EVSYS_USER_CHANNEL2_gc = (0x03<<0)  ; Connect user to event channel 2
  EVSYS_USER_CHANNEL3_gc = (0x04<<0)  ; Connect user to event channel 3
  EVSYS_USER_CHANNEL4_gc = (0x05<<0)  ; Connect user to event channel 4
  EVSYS_USER_CHANNEL5_gc = (0x06<<0)  ; Connect user to event channel 5
  
  
  ;*************************************************************************
  ;** FUSE - Fuses
  ;*************************************************************************
  
  ; FUSE_WDTCFG masks
  FUSE_PERIOD_gm = 0x0F               ; Watchdog Timeout Period group mask
  FUSE_PERIOD_gp = 0                  ; Watchdog Timeout Period group position
  FUSE_PERIOD_0_bm = (1<<0)           ; Watchdog Timeout Period bit 0 mask
  FUSE_PERIOD_0_bp = 0                ; Watchdog Timeout Period bit 0 position
  FUSE_PERIOD_1_bm = (1<<1)           ; Watchdog Timeout Period bit 1 mask
  FUSE_PERIOD_1_bp = 1                ; Watchdog Timeout Period bit 1 position
  FUSE_PERIOD_2_bm = (1<<2)           ; Watchdog Timeout Period bit 2 mask
  FUSE_PERIOD_2_bp = 2                ; Watchdog Timeout Period bit 2 position
  FUSE_PERIOD_3_bm = (1<<3)           ; Watchdog Timeout Period bit 3 mask
  FUSE_PERIOD_3_bp = 3                ; Watchdog Timeout Period bit 3 position
  FUSE_WINDOW_gm = 0xF0               ; Watchdog Window Timeout Period group mask
  FUSE_WINDOW_gp = 4                  ; Watchdog Window Timeout Period group position
  FUSE_WINDOW_0_bm = (1<<4)           ; Watchdog Window Timeout Period bit 0 mask
  FUSE_WINDOW_0_bp = 4                ; Watchdog Window Timeout Period bit 0 position
  FUSE_WINDOW_1_bm = (1<<5)           ; Watchdog Window Timeout Period bit 1 mask
  FUSE_WINDOW_1_bp = 5                ; Watchdog Window Timeout Period bit 1 position
  FUSE_WINDOW_2_bm = (1<<6)           ; Watchdog Window Timeout Period bit 2 mask
  FUSE_WINDOW_2_bp = 6                ; Watchdog Window Timeout Period bit 2 position
  FUSE_WINDOW_3_bm = (1<<7)           ; Watchdog Window Timeout Period bit 3 mask
  FUSE_WINDOW_3_bp = 7                ; Watchdog Window Timeout Period bit 3 position
  
  ; FUSE_BODCFG masks
  FUSE_SLEEP_gm = 0x03                ; BOD Operation in Sleep Mode group mask
  FUSE_SLEEP_gp = 0                   ; BOD Operation in Sleep Mode group position
  FUSE_SLEEP_0_bm = (1<<0)            ; BOD Operation in Sleep Mode bit 0 mask
  FUSE_SLEEP_0_bp = 0                 ; BOD Operation in Sleep Mode bit 0 position
  FUSE_SLEEP_1_bm = (1<<1)            ; BOD Operation in Sleep Mode bit 1 mask
  FUSE_SLEEP_1_bp = 1                 ; BOD Operation in Sleep Mode bit 1 position
  FUSE_ACTIVE_gm = 0x0C               ; BOD Operation in Active Mode group mask
  FUSE_ACTIVE_gp = 2                  ; BOD Operation in Active Mode group position
  FUSE_ACTIVE_0_bm = (1<<2)           ; BOD Operation in Active Mode bit 0 mask
  FUSE_ACTIVE_0_bp = 2                ; BOD Operation in Active Mode bit 0 position
  FUSE_ACTIVE_1_bm = (1<<3)           ; BOD Operation in Active Mode bit 1 mask
  FUSE_ACTIVE_1_bp = 3                ; BOD Operation in Active Mode bit 1 position
  FUSE_SAMPFREQ_bm = 0x10             ; BOD Sample Frequency bit mask
  FUSE_SAMPFREQ_bp = 4                ; BOD Sample Frequency bit position
  FUSE_LVL_gm = 0xE0                  ; BOD Level group mask
  FUSE_LVL_gp = 5                     ; BOD Level group position
  FUSE_LVL_0_bm = (1<<5)              ; BOD Level bit 0 mask
  FUSE_LVL_0_bp = 5                   ; BOD Level bit 0 position
  FUSE_LVL_1_bm = (1<<6)              ; BOD Level bit 1 mask
  FUSE_LVL_1_bp = 6                   ; BOD Level bit 1 position
  FUSE_LVL_2_bm = (1<<7)              ; BOD Level bit 2 mask
  FUSE_LVL_2_bp = 7                   ; BOD Level bit 2 position
  
  ; FUSE_OSCCFG masks
  FUSE_FREQSEL_gm = 0x03              ; Frequency Select group mask
  FUSE_FREQSEL_gp = 0                 ; Frequency Select group position
  FUSE_FREQSEL_0_bm = (1<<0)          ; Frequency Select bit 0 mask
  FUSE_FREQSEL_0_bp = 0               ; Frequency Select bit 0 position
  FUSE_FREQSEL_1_bm = (1<<1)          ; Frequency Select bit 1 mask
  FUSE_FREQSEL_1_bp = 1               ; Frequency Select bit 1 position
  FUSE_OSCLOCK_bm = 0x80              ; Oscillator Lock bit mask
  FUSE_OSCLOCK_bp = 7                 ; Oscillator Lock bit position
  
  ; FUSE_SYSCFG0 masks
  FUSE_EESAVE_bm = 0x01               ; EEPROM Save bit mask
  FUSE_EESAVE_bp = 0                  ; EEPROM Save bit position
  FUSE_RSTPINCFG_gm = 0x0C            ; Reset Pin Configuration group mask
  FUSE_RSTPINCFG_gp = 2               ; Reset Pin Configuration group position
  FUSE_RSTPINCFG_0_bm = (1<<2)        ; Reset Pin Configuration bit 0 mask
  FUSE_RSTPINCFG_0_bp = 2             ; Reset Pin Configuration bit 0 position
  FUSE_RSTPINCFG_1_bm = (1<<3)        ; Reset Pin Configuration bit 1 mask
  FUSE_RSTPINCFG_1_bp = 3             ; Reset Pin Configuration bit 1 position
  FUSE_TOUTDIS_bm = 0x10              ; Time-Out Disable bit mask
  FUSE_TOUTDIS_bp = 4                 ; Time-Out Disable bit position
  FUSE_CRCSRC_gm = 0xC0               ; CRC Source group mask
  FUSE_CRCSRC_gp = 6                  ; CRC Source group position
  FUSE_CRCSRC_0_bm = (1<<6)           ; CRC Source bit 0 mask
  FUSE_CRCSRC_0_bp = 6                ; CRC Source bit 0 position
  FUSE_CRCSRC_1_bm = (1<<7)           ; CRC Source bit 1 mask
  FUSE_CRCSRC_1_bp = 7                ; CRC Source bit 1 position
  
  ; FUSE_SYSCFG1 masks
  FUSE_SUT_gm = 0x07                  ; Startup Time group mask
  FUSE_SUT_gp = 0                     ; Startup Time group position
  FUSE_SUT_0_bm = (1<<0)              ; Startup Time bit 0 mask
  FUSE_SUT_0_bp = 0                   ; Startup Time bit 0 position
  FUSE_SUT_1_bm = (1<<1)              ; Startup Time bit 1 mask
  FUSE_SUT_1_bp = 1                   ; Startup Time bit 1 position
  FUSE_SUT_2_bm = (1<<2)              ; Startup Time bit 2 mask
  FUSE_SUT_2_bp = 2                   ; Startup Time bit 2 position
  
  ; BOD Operation in Active Mode select
  FUSE_ACTIVE_DIS_gc = (0x00<<2)      ; Disabled
  FUSE_ACTIVE_ENABLED_gc = (0x01<<2)  ; Enabled
  FUSE_ACTIVE_SAMPLED_gc = (0x02<<2)  ; Sampled
  FUSE_ACTIVE_ENWAKE_gc = (0x03<<2)   ; Enabled with wake-up halted until BOD is ready
  
  ; BOD Level select
  FUSE_LVL_BODLEVEL0_gc = (0x00<<5)   ; 1.8 V
  FUSE_LVL_BODLEVEL2_gc = (0x02<<5)   ; 2.6 V
  FUSE_LVL_BODLEVEL7_gc = (0x07<<5)   ; 4.2 V
  
  ; BOD Sample Frequency select
  FUSE_SAMPFREQ_1KHZ_gc = (0x00<<4)   ; 1kHz sampling frequency
  FUSE_SAMPFREQ_125HZ_gc = (0x01<<4)  ; 125Hz sampling frequency
  
  ; BOD Operation in Sleep Mode select
  FUSE_SLEEP_DIS_gc = (0x00<<0)       ; Disabled
  FUSE_SLEEP_ENABLED_gc = (0x01<<0)   ; Enabled
  FUSE_SLEEP_SAMPLED_gc = (0x02<<0)   ; Sampled
  
  ; Frequency Select
  FUSE_FREQSEL_16MHZ_gc = (0x01<<0)   ; 16 MHz
  FUSE_FREQSEL_20MHZ_gc = (0x02<<0)   ; 20 MHz
  
  ; CRC Source select
  FUSE_CRCSRC_FLASH_gc = (0x00<<6)    ; The CRC is performed on the entire Flash (boot, application code and application data section).
  FUSE_CRCSRC_BOOT_gc = (0x01<<6)     ; The CRC is performed on the boot section of Flash
  FUSE_CRCSRC_BOOTAPP_gc = (0x02<<6)  ; The CRC is performed on the boot and application code section of Flash
  FUSE_CRCSRC_NOCRC_gc = (0x03<<6)    ; Disable CRC.
  
  ; Reset Pin Configuration select
  FUSE_RSTPINCFG_GPIO_gc = (0x00<<2)  ; GPIO mode
  FUSE_RSTPINCFG_UPDI_gc = (0x01<<2)  ; UPDI mode
  FUSE_RSTPINCFG_RST_gc = (0x02<<2)   ; Reset mode
  FUSE_RSTPINCFG_PDIRST_gc = (0x03<<2) ; PDI on PDI pad, reset on alternative reset pad
  
  ; Startup Time select
  FUSE_SUT_0MS_gc = (0x00<<0)         ; 0 ms
  FUSE_SUT_1MS_gc = (0x01<<0)         ; 1 ms
  FUSE_SUT_2MS_gc = (0x02<<0)         ; 2 ms
  FUSE_SUT_4MS_gc = (0x03<<0)         ; 4 ms
  FUSE_SUT_8MS_gc = (0x04<<0)         ; 8 ms
  FUSE_SUT_16MS_gc = (0x05<<0)        ; 16 ms
  FUSE_SUT_32MS_gc = (0x06<<0)        ; 32 ms
  FUSE_SUT_64MS_gc = (0x07<<0)        ; 64 ms
  
  ; Watchdog Timeout Period select
  FUSE_PERIOD_OFF_gc = (0x00<<0)      ; Off
  FUSE_PERIOD_8CLK_gc = (0x01<<0)     ; 8 cycles (8ms)
  FUSE_PERIOD_16CLK_gc = (0x02<<0)    ; 16 cycles (16ms)
  FUSE_PERIOD_32CLK_gc = (0x03<<0)    ; 32 cycles (32ms)
  FUSE_PERIOD_64CLK_gc = (0x04<<0)    ; 64 cycles (64ms)
  FUSE_PERIOD_128CLK_gc = (0x05<<0)   ; 128 cycles (0.128s)
  FUSE_PERIOD_256CLK_gc = (0x06<<0)   ; 256 cycles (0.256s)
  FUSE_PERIOD_512CLK_gc = (0x07<<0)   ; 512 cycles (0.512s)
  FUSE_PERIOD_1KCLK_gc = (0x08<<0)    ; 1K cycles (1.0s)
  FUSE_PERIOD_2KCLK_gc = (0x09<<0)    ; 2K cycles (2.0s)
  FUSE_PERIOD_4KCLK_gc = (0x0A<<0)    ; 4K cycles (4.1s)
  FUSE_PERIOD_8KCLK_gc = (0x0B<<0)    ; 8K cycles (8.2s)
  
  ; Watchdog Window Timeout Period select
  FUSE_WINDOW_OFF_gc = (0x00<<4)      ; Off
  FUSE_WINDOW_8CLK_gc = (0x01<<4)     ; 8 cycles (8ms)
  FUSE_WINDOW_16CLK_gc = (0x02<<4)    ; 16 cycles (16ms)
  FUSE_WINDOW_32CLK_gc = (0x03<<4)    ; 32 cycles (32ms)
  FUSE_WINDOW_64CLK_gc = (0x04<<4)    ; 64 cycles (64ms)
  FUSE_WINDOW_128CLK_gc = (0x05<<4)   ; 128 cycles (0.128s)
  FUSE_WINDOW_256CLK_gc = (0x06<<4)   ; 256 cycles (0.256s)
  FUSE_WINDOW_512CLK_gc = (0x07<<4)   ; 512 cycles (0.512s)
  FUSE_WINDOW_1KCLK_gc = (0x08<<4)    ; 1K cycles (1.0s)
  FUSE_WINDOW_2KCLK_gc = (0x09<<4)    ; 2K cycles (2.0s)
  FUSE_WINDOW_4KCLK_gc = (0x0A<<4)    ; 4K cycles (4.1s)
  FUSE_WINDOW_8KCLK_gc = (0x0B<<4)    ; 8K cycles (8.2s)
  
  
  ;*************************************************************************
  ;** GPIO - General Purpose I/O Register
  ;*************************************************************************
  
  
  ;*************************************************************************
  ;** LOCKBIT - Lockbit
  ;*************************************************************************
  
  ; LOCKBIT_LOCKBIT masks
  LOCKBIT_LB_gm = 0xFF                ; Lock Bits group mask
  LOCKBIT_LB_gp = 0                   ; Lock Bits group position
  LOCKBIT_LB_0_bm = (1<<0)            ; Lock Bits bit 0 mask
  LOCKBIT_LB_0_bp = 0                 ; Lock Bits bit 0 position
  LOCKBIT_LB_1_bm = (1<<1)            ; Lock Bits bit 1 mask
  LOCKBIT_LB_1_bp = 1                 ; Lock Bits bit 1 position
  LOCKBIT_LB_2_bm = (1<<2)            ; Lock Bits bit 2 mask
  LOCKBIT_LB_2_bp = 2                 ; Lock Bits bit 2 position
  LOCKBIT_LB_3_bm = (1<<3)            ; Lock Bits bit 3 mask
  LOCKBIT_LB_3_bp = 3                 ; Lock Bits bit 3 position
  LOCKBIT_LB_4_bm = (1<<4)            ; Lock Bits bit 4 mask
  LOCKBIT_LB_4_bp = 4                 ; Lock Bits bit 4 position
  LOCKBIT_LB_5_bm = (1<<5)            ; Lock Bits bit 5 mask
  LOCKBIT_LB_5_bp = 5                 ; Lock Bits bit 5 position
  LOCKBIT_LB_6_bm = (1<<6)            ; Lock Bits bit 6 mask
  LOCKBIT_LB_6_bp = 6                 ; Lock Bits bit 6 position
  LOCKBIT_LB_7_bm = (1<<7)            ; Lock Bits bit 7 mask
  LOCKBIT_LB_7_bp = 7                 ; Lock Bits bit 7 position
  
  ; Lock Bits select
  LOCKBIT_LB_RWLOCK_gc = (0x3A<<0)    ; Read and write lock
  LOCKBIT_LB_NOLOCK_gc = (0xC5<<0)    ; No locks
  
  
  ;*************************************************************************
  ;** NVMCTRL - Non-volatile Memory Controller
  ;*************************************************************************
  
  ; NVMCTRL_CTRLA masks
  NVMCTRL_CMD_gm = 0x07               ; Command group mask
  NVMCTRL_CMD_gp = 0                  ; Command group position
  NVMCTRL_CMD_0_bm = (1<<0)           ; Command bit 0 mask
  NVMCTRL_CMD_0_bp = 0                ; Command bit 0 position
  NVMCTRL_CMD_1_bm = (1<<1)           ; Command bit 1 mask
  NVMCTRL_CMD_1_bp = 1                ; Command bit 1 position
  NVMCTRL_CMD_2_bm = (1<<2)           ; Command bit 2 mask
  NVMCTRL_CMD_2_bp = 2                ; Command bit 2 position
  
  ; NVMCTRL_CTRLB masks
  NVMCTRL_APCWP_bm = 0x01             ; Application code write protect bit mask
  NVMCTRL_APCWP_bp = 0                ; Application code write protect bit position
  NVMCTRL_BOOTLOCK_bm = 0x02          ; Boot Lock bit mask
  NVMCTRL_BOOTLOCK_bp = 1             ; Boot Lock bit position
  
  ; NVMCTRL_STATUS masks
  NVMCTRL_FBUSY_bm = 0x01             ; Flash busy bit mask
  NVMCTRL_FBUSY_bp = 0                ; Flash busy bit position
  NVMCTRL_EEBUSY_bm = 0x02            ; EEPROM busy bit mask
  NVMCTRL_EEBUSY_bp = 1               ; EEPROM busy bit position
  NVMCTRL_WRERROR_bm = 0x04           ; Write error bit mask
  NVMCTRL_WRERROR_bp = 2              ; Write error bit position
  
  ; NVMCTRL_INTCTRL masks
  NVMCTRL_EEREADY_bm = 0x01           ; EEPROM Ready bit mask
  NVMCTRL_EEREADY_bp = 0              ; EEPROM Ready bit position
  
  ; NVMCTRL_INTFLAGS masks
  ; Masks for NVMCTRL_EEREADY already defined
  
  ; Command select
  NVMCTRL_CMD_NONE_gc = (0x00<<0)     ; No Command
  NVMCTRL_CMD_PAGEWRITE_gc = (0x01<<0) ; Write page
  NVMCTRL_CMD_PAGEERASE_gc = (0x02<<0) ; Erase page
  NVMCTRL_CMD_PAGEERASEWRITE_gc = (0x03<<0) ; Erase and write page
  NVMCTRL_CMD_PAGEBUFCLR_gc = (0x04<<0) ; Page buffer clear
  NVMCTRL_CMD_CHIPERASE_gc = (0x05<<0) ; Chip erase
  NVMCTRL_CMD_EEERASE_gc = (0x06<<0)  ; EEPROM erase
  NVMCTRL_CMD_FUSEWRITE_gc = (0x07<<0) ; Write fuse (PDI only)
  
  
  ;*************************************************************************
  ;** PORT - I/O Ports
  ;*************************************************************************
  
  ; PORT_INTFLAGS masks
  PORT_INT_gm = 0xFF                  ; Pin Interrupt group mask
  PORT_INT_gp = 0                     ; Pin Interrupt group position
  PORT_INT_0_bm = (1<<0)              ; Pin Interrupt bit 0 mask
  PORT_INT_0_bp = 0                   ; Pin Interrupt bit 0 position
  PORT_INT_1_bm = (1<<1)              ; Pin Interrupt bit 1 mask
  PORT_INT_1_bp = 1                   ; Pin Interrupt bit 1 position
  PORT_INT_2_bm = (1<<2)              ; Pin Interrupt bit 2 mask
  PORT_INT_2_bp = 2                   ; Pin Interrupt bit 2 position
  PORT_INT_3_bm = (1<<3)              ; Pin Interrupt bit 3 mask
  PORT_INT_3_bp = 3                   ; Pin Interrupt bit 3 position
  PORT_INT_4_bm = (1<<4)              ; Pin Interrupt bit 4 mask
  PORT_INT_4_bp = 4                   ; Pin Interrupt bit 4 position
  PORT_INT_5_bm = (1<<5)              ; Pin Interrupt bit 5 mask
  PORT_INT_5_bp = 5                   ; Pin Interrupt bit 5 position
  PORT_INT_6_bm = (1<<6)              ; Pin Interrupt bit 6 mask
  PORT_INT_6_bp = 6                   ; Pin Interrupt bit 6 position
  PORT_INT_7_bm = (1<<7)              ; Pin Interrupt bit 7 mask
  PORT_INT_7_bp = 7                   ; Pin Interrupt bit 7 position
  
  ; PORT_PORTCTRL masks
  PORT_SRL_bm = 0x01                  ; Slew Rate Limit Enable bit mask
  PORT_SRL_bp = 0                     ; Slew Rate Limit Enable bit position
  
  ; PORT_PIN0CTRL masks
  PORT_ISC_gm = 0x07                  ; Input/Sense Configuration group mask
  PORT_ISC_gp = 0                     ; Input/Sense Configuration group position
  PORT_ISC_0_bm = (1<<0)              ; Input/Sense Configuration bit 0 mask
  PORT_ISC_0_bp = 0                   ; Input/Sense Configuration bit 0 position
  PORT_ISC_1_bm = (1<<1)              ; Input/Sense Configuration bit 1 mask
  PORT_ISC_1_bp = 1                   ; Input/Sense Configuration bit 1 position
  PORT_ISC_2_bm = (1<<2)              ; Input/Sense Configuration bit 2 mask
  PORT_ISC_2_bp = 2                   ; Input/Sense Configuration bit 2 position
  PORT_PULLUPEN_bm = 0x08             ; Pullup enable bit mask
  PORT_PULLUPEN_bp = 3                ; Pullup enable bit position
  PORT_INVEN_bm = 0x80                ; Inverted I/O Enable bit mask
  PORT_INVEN_bp = 7                   ; Inverted I/O Enable bit position
  
  ; PORT_PIN1CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN2CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN3CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN4CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN5CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN6CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN7CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INVEN already defined
  
  ; Input/Sense Configuration select
  PORT_ISC_INTDISABLE_gc = (0x00<<0)  ; Interrupt disabled but input buffer enabled
  PORT_ISC_BOTHEDGES_gc = (0x01<<0)   ; Sense Both Edges
  PORT_ISC_RISING_gc = (0x02<<0)      ; Sense Rising Edge
  PORT_ISC_FALLING_gc = (0x03<<0)     ; Sense Falling Edge
  PORT_ISC_INPUT_DISABLE_gc = (0x04<<0) ; Digital Input Buffer disabled
  PORT_ISC_LEVEL_gc = (0x05<<0)       ; Sense low Level
  
  
  ;*************************************************************************
  ;** PORTMUX - Port Multiplexer
  ;*************************************************************************
  
  ; PORTMUX_EVSYSROUTEA masks
  PORTMUX_EVOUTA_bm = 0x01            ; Event Output A bit mask
  PORTMUX_EVOUTA_bp = 0               ; Event Output A bit position
  PORTMUX_EVOUTB_bm = 0x02            ; Event Output B bit mask
  PORTMUX_EVOUTB_bp = 1               ; Event Output B bit position
  PORTMUX_EVOUTC_bm = 0x04            ; Event Output C bit mask
  PORTMUX_EVOUTC_bp = 2               ; Event Output C bit position
  
  ; PORTMUX_CCLROUTEA masks
  PORTMUX_LUT0_bm = 0x01              ; CCL LUT0 bit mask
  PORTMUX_LUT0_bp = 0                 ; CCL LUT0 bit position
  PORTMUX_LUT1_bm = 0x02              ; CCL LUT1 bit mask
  PORTMUX_LUT1_bp = 1                 ; CCL LUT1 bit position
  PORTMUX_LUT2_bm = 0x04              ; CCL LUT2 bit mask
  PORTMUX_LUT2_bp = 2                 ; CCL LUT2 bit position
  PORTMUX_LUT3_bm = 0x08              ; CCL LUT3 bit mask
  PORTMUX_LUT3_bp = 3                 ; CCL LUT3 bit position
  
  ; PORTMUX_USARTROUTEA masks
  PORTMUX_USART0_gm = 0x03            ; Port Multiplexer USART0 group mask
  PORTMUX_USART0_gp = 0               ; Port Multiplexer USART0 group position
  PORTMUX_USART0_0_bm = (1<<0)        ; Port Multiplexer USART0 bit 0 mask
  PORTMUX_USART0_0_bp = 0             ; Port Multiplexer USART0 bit 0 position
  PORTMUX_USART0_1_bm = (1<<1)        ; Port Multiplexer USART0 bit 1 mask
  PORTMUX_USART0_1_bp = 1             ; Port Multiplexer USART0 bit 1 position
  PORTMUX_USART1_gm = 0x0C            ; Port Multiplexer USART1 group mask
  PORTMUX_USART1_gp = 2               ; Port Multiplexer USART1 group position
  PORTMUX_USART1_0_bm = (1<<2)        ; Port Multiplexer USART1 bit 0 mask
  PORTMUX_USART1_0_bp = 2             ; Port Multiplexer USART1 bit 0 position
  PORTMUX_USART1_1_bm = (1<<3)        ; Port Multiplexer USART1 bit 1 mask
  PORTMUX_USART1_1_bp = 3             ; Port Multiplexer USART1 bit 1 position
  
  ; PORTMUX_SPIROUTEA masks
  PORTMUX_SPI0_gm = 0x03              ; Port Multiplexer SPI0 group mask
  PORTMUX_SPI0_gp = 0                 ; Port Multiplexer SPI0 group position
  PORTMUX_SPI0_0_bm = (1<<0)          ; Port Multiplexer SPI0 bit 0 mask
  PORTMUX_SPI0_0_bp = 0               ; Port Multiplexer SPI0 bit 0 position
  PORTMUX_SPI0_1_bm = (1<<1)          ; Port Multiplexer SPI0 bit 1 mask
  PORTMUX_SPI0_1_bp = 1               ; Port Multiplexer SPI0 bit 1 position
  
  ; PORTMUX_TCAROUTEA masks
  PORTMUX_TCA00_bm = 0x01             ; Port Multiplexer TCA0 Output 0 bit mask
  PORTMUX_TCA00_bp = 0                ; Port Multiplexer TCA0 Output 0 bit position
  PORTMUX_TCA01_bm = 0x02             ; Port Multiplexer TCA0 Output 1 bit mask
  PORTMUX_TCA01_bp = 1                ; Port Multiplexer TCA0 Output 1 bit position
  PORTMUX_TCA02_bm = 0x04             ; Port Multiplexer TCA0 Output 2 bit mask
  PORTMUX_TCA02_bp = 2                ; Port Multiplexer TCA0 Output 2 bit position
  PORTMUX_TCA03_bm = 0x08             ; Port Multiplexer TCA0 Output 3 bit mask
  PORTMUX_TCA03_bp = 3                ; Port Multiplexer TCA0 Output 3 bit position
  PORTMUX_TCA04_bm = 0x10             ; Port Multiplexer TCA0 Output 4 bit mask
  PORTMUX_TCA04_bp = 4                ; Port Multiplexer TCA0 Output 4 bit position
  PORTMUX_TCA05_bm = 0x20             ; Port Multiplexer TCA0 Output 5 bit mask
  PORTMUX_TCA05_bp = 5                ; Port Multiplexer TCA0 Output 5 bit position
  
  ; PORTMUX_TCBROUTEA masks
  PORTMUX_TCB0_bm = 0x01              ; Port Multiplexer TCB0 bit mask
  PORTMUX_TCB0_bp = 0                 ; Port Multiplexer TCB0 bit position
  PORTMUX_TCB1_bm = 0x02              ; Port Multiplexer TCB1 bit mask
  PORTMUX_TCB1_bp = 1                 ; Port Multiplexer TCB1 bit position
  
  ; CCL LUT0 select
  PORTMUX_LUT0_DEFAULT_gc = (0x00<<0) ; Out: PA4 In: PA0, PA1, PA2
  PORTMUX_LUT0_ALT1_gc = (0x01<<0)    ; Out: PB4 In: PA0, PA1, PA2
  
  ; CCL LUT1 select
  PORTMUX_LUT1_DEFAULT_gc = (0x00<<1) ; Out: PA7 In: PC3, PC4, PC5
  PORTMUX_LUT1_ALT1_gc = (0x01<<1)    ; Out: PC1 In: PC3, PC4, PC5
  
  ; CCL LUT2 select
  PORTMUX_LUT2_DEFAULT_gc = (0x00<<2) ; Out: PB3 In: PB0, PB1, PB2
  
  ; CCL LUT3 select
  PORTMUX_LUT3_ALT1_gc = (0x01<<3)    ; Out: PA5 In: PC0, PC1, PC2
  
  ; Event Output A select
  PORTMUX_EVOUTA_DEFAULT_gc = (0x00<<0) ; EVOUT on PA2
  PORTMUX_EVOUTA_ALT1_gc = (0x01<<0)  ; EVOUT on PA7
  
  ; Event Output B select
  PORTMUX_EVOUTB_DEFAULT_gc = (0x00<<1) ; EVOUT on PB2
  
  ; Event Output C select
  PORTMUX_EVOUTC_DEFAULT_gc = (0x00<<2) ; EVOUT on PC2
  
  ; Port Multiplexer SPI0 select
  PORTMUX_SPI0_DEFAULT_gc = (0x00<<0) ; PA0, PA1, PA2, PA3
  PORTMUX_SPI0_ALT1_gc = (0x01<<0)    ; PC2, PC1, PC0, PC3
  PORTMUX_SPI0_NONE_gc = (0x03<<0)    ; Not connected to any pins
  
  ; Port Multiplexer TCA0 Output 0 select
  PORTMUX_TCA00_DEFAULT_gc = (0x00<<0) ; WO0 on PB0
  PORTMUX_TCA00_ALT1_gc = (0x01<<0)   ; WO0 on PB3
  
  ; Port Multiplexer TCA0 Output 1 select
  PORTMUX_TCA01_DEFAULT_gc = (0x00<<1) ; WO1 on PB1
  PORTMUX_TCA01_ALT1_gc = (0x01<<1)   ; WO1 on PB4
  
  ; Port Multiplexer TCA0 Output 2 select
  PORTMUX_TCA02_DEFAULT_gc = (0x00<<2) ; WO2 on PB2
  PORTMUX_TCA02_ALT1_gc = (0x01<<2)   ; WO2 on PB5
  
  ; Port Multiplexer TCA0 Output 3 select
  PORTMUX_TCA03_DEFAULT_gc = (0x00<<3) ; WO3 on PA3
  PORTMUX_TCA03_ALT1_gc = (0x01<<3)   ; WO3 on PC3
  
  ; Port Multiplexer TCA0 Output 4 select
  PORTMUX_TCA04_DEFAULT_gc = (0x00<<4) ; WO4 on PA4
  
  ; Port Multiplexer TCA0 Output 5 select
  PORTMUX_TCA05_DEFAULT_gc = (0x00<<5) ; WO5 on PA5
  
  ; Port Multiplexer TCB0 select
  PORTMUX_TCB0_DEFAULT_gc = (0x00<<0) ; WO on PA5
  PORTMUX_TCB0_ALT1_gc = (0x01<<0)    ; WO on PC0
  
  ; Port Multiplexer TCB1 select
  PORTMUX_TCB1_DEFAULT_gc = (0x00<<1) ; WO on PA3
  
  ; Port Multiplexer USART0 select
  PORTMUX_USART0_DEFAULT_gc = (0x00<<0) ; USART0 on PB[3:0]
  PORTMUX_USART0_ALT1_gc = (0x01<<0)  ; USART0 on PA[4:1]
  PORTMUX_USART0_NONE_gc = (0x03<<0)  ; Not connected to any pins
  
  ; Port Multiplexer USART1 select
  PORTMUX_USART1_DEFAULT_gc = (0x00<<2) ; USART1 on PA[4:1]
  PORTMUX_USART1_ALT1_gc = (0x01<<2)  ; USART1 on PC[3:0]
  PORTMUX_USART1_NONE_gc = (0x03<<2)  ; Not connected to any pins
  
  
  ;*************************************************************************
  ;** RSTCTRL - Reset controller
  ;*************************************************************************
  
  ; RSTCTRL_RSTFR masks
  RSTCTRL_PORF_bm = 0x01              ; Power on Reset flag bit mask
  RSTCTRL_PORF_bp = 0                 ; Power on Reset flag bit position
  RSTCTRL_BORF_bm = 0x02              ; Brown out detector Reset flag bit mask
  RSTCTRL_BORF_bp = 1                 ; Brown out detector Reset flag bit position
  RSTCTRL_EXTRF_bm = 0x04             ; External Reset flag bit mask
  RSTCTRL_EXTRF_bp = 2                ; External Reset flag bit position
  RSTCTRL_WDRF_bm = 0x08              ; Watch dog Reset flag bit mask
  RSTCTRL_WDRF_bp = 3                 ; Watch dog Reset flag bit position
  RSTCTRL_SWRF_bm = 0x10              ; Software Reset flag bit mask
  RSTCTRL_SWRF_bp = 4                 ; Software Reset flag bit position
  RSTCTRL_UPDIRF_bm = 0x20            ; UPDI Reset flag bit mask
  RSTCTRL_UPDIRF_bp = 5               ; UPDI Reset flag bit position
  
  ; RSTCTRL_SWRR masks
  RSTCTRL_SWRE_bm = 0x01              ; Software reset enable bit mask
  RSTCTRL_SWRE_bp = 0                 ; Software reset enable bit position
  
  
  ;*************************************************************************
  ;** RTC - Real-Time Counter
  ;*************************************************************************
  
  ; RTC_CTRLA masks
  RTC_RTCEN_bm = 0x01                 ; Enable bit mask
  RTC_RTCEN_bp = 0                    ; Enable bit position
  RTC_CORREN_bm = 0x04                ; Correction enable bit mask
  RTC_CORREN_bp = 2                   ; Correction enable bit position
  RTC_PRESCALER_gm = 0x78             ; Prescaling Factor group mask
  RTC_PRESCALER_gp = 3                ; Prescaling Factor group position
  RTC_PRESCALER_0_bm = (1<<3)         ; Prescaling Factor bit 0 mask
  RTC_PRESCALER_0_bp = 3              ; Prescaling Factor bit 0 position
  RTC_PRESCALER_1_bm = (1<<4)         ; Prescaling Factor bit 1 mask
  RTC_PRESCALER_1_bp = 4              ; Prescaling Factor bit 1 position
  RTC_PRESCALER_2_bm = (1<<5)         ; Prescaling Factor bit 2 mask
  RTC_PRESCALER_2_bp = 5              ; Prescaling Factor bit 2 position
  RTC_PRESCALER_3_bm = (1<<6)         ; Prescaling Factor bit 3 mask
  RTC_PRESCALER_3_bp = 6              ; Prescaling Factor bit 3 position
  RTC_RUNSTDBY_bm = 0x80              ; Run In Standby bit mask
  RTC_RUNSTDBY_bp = 7                 ; Run In Standby bit position
  
  ; RTC_STATUS masks
  RTC_CTRLABUSY_bm = 0x01             ; CTRLA Synchronization Busy Flag bit mask
  RTC_CTRLABUSY_bp = 0                ; CTRLA Synchronization Busy Flag bit position
  RTC_CNTBUSY_bm = 0x02               ; Count Synchronization Busy Flag bit mask
  RTC_CNTBUSY_bp = 1                  ; Count Synchronization Busy Flag bit position
  RTC_PERBUSY_bm = 0x04               ; Period Synchronization Busy Flag bit mask
  RTC_PERBUSY_bp = 2                  ; Period Synchronization Busy Flag bit position
  RTC_CMPBUSY_bm = 0x08               ; Comparator Synchronization Busy Flag bit mask
  RTC_CMPBUSY_bp = 3                  ; Comparator Synchronization Busy Flag bit position
  
  ; RTC_INTCTRL masks
  RTC_OVF_bm = 0x01                   ; Overflow Interrupt enable bit mask
  RTC_OVF_bp = 0                      ; Overflow Interrupt enable bit position
  RTC_CMP_bm = 0x02                   ; Compare Match Interrupt enable bit mask
  RTC_CMP_bp = 1                      ; Compare Match Interrupt enable bit position
  
  ; RTC_INTFLAGS masks
  ; Masks for RTC_OVF already defined
  ; Masks for RTC_CMP already defined
  
  ; RTC_DBGCTRL masks
  RTC_DBGRUN_bm = 0x01                ; Run in debug bit mask
  RTC_DBGRUN_bp = 0                   ; Run in debug bit position
  
  ; RTC_CALIB masks
  RTC_ERROR_gm = 0x7F                 ; Error Correction Value group mask
  RTC_ERROR_gp = 0                    ; Error Correction Value group position
  RTC_ERROR_0_bm = (1<<0)             ; Error Correction Value bit 0 mask
  RTC_ERROR_0_bp = 0                  ; Error Correction Value bit 0 position
  RTC_ERROR_1_bm = (1<<1)             ; Error Correction Value bit 1 mask
  RTC_ERROR_1_bp = 1                  ; Error Correction Value bit 1 position
  RTC_ERROR_2_bm = (1<<2)             ; Error Correction Value bit 2 mask
  RTC_ERROR_2_bp = 2                  ; Error Correction Value bit 2 position
  RTC_ERROR_3_bm = (1<<3)             ; Error Correction Value bit 3 mask
  RTC_ERROR_3_bp = 3                  ; Error Correction Value bit 3 position
  RTC_ERROR_4_bm = (1<<4)             ; Error Correction Value bit 4 mask
  RTC_ERROR_4_bp = 4                  ; Error Correction Value bit 4 position
  RTC_ERROR_5_bm = (1<<5)             ; Error Correction Value bit 5 mask
  RTC_ERROR_5_bp = 5                  ; Error Correction Value bit 5 position
  RTC_ERROR_6_bm = (1<<6)             ; Error Correction Value bit 6 mask
  RTC_ERROR_6_bp = 6                  ; Error Correction Value bit 6 position
  RTC_SIGN_bm = 0x80                  ; Error Correction Sign Bit bit mask
  RTC_SIGN_bp = 7                     ; Error Correction Sign Bit bit position
  
  ; RTC_CLKSEL masks
  RTC_CLKSEL_gm = 0x03                ; Clock Select group mask
  RTC_CLKSEL_gp = 0                   ; Clock Select group position
  RTC_CLKSEL_0_bm = (1<<0)            ; Clock Select bit 0 mask
  RTC_CLKSEL_0_bp = 0                 ; Clock Select bit 0 position
  RTC_CLKSEL_1_bm = (1<<1)            ; Clock Select bit 1 mask
  RTC_CLKSEL_1_bp = 1                 ; Clock Select bit 1 position
  
  ; RTC_PITCTRLA masks
  RTC_PITEN_bm = 0x01                 ; Enable bit mask
  RTC_PITEN_bp = 0                    ; Enable bit position
  RTC_PERIOD_gm = 0x78                ; Period group mask
  RTC_PERIOD_gp = 3                   ; Period group position
  RTC_PERIOD_0_bm = (1<<3)            ; Period bit 0 mask
  RTC_PERIOD_0_bp = 3                 ; Period bit 0 position
  RTC_PERIOD_1_bm = (1<<4)            ; Period bit 1 mask
  RTC_PERIOD_1_bp = 4                 ; Period bit 1 position
  RTC_PERIOD_2_bm = (1<<5)            ; Period bit 2 mask
  RTC_PERIOD_2_bp = 5                 ; Period bit 2 position
  RTC_PERIOD_3_bm = (1<<6)            ; Period bit 3 mask
  RTC_PERIOD_3_bp = 6                 ; Period bit 3 position
  
  ; RTC_PITSTATUS masks
  RTC_CTRLBUSY_bm = 0x01              ; CTRLA Synchronization Busy Flag bit mask
  RTC_CTRLBUSY_bp = 0                 ; CTRLA Synchronization Busy Flag bit position
  
  ; RTC_PITINTCTRL masks
  RTC_PI_bm = 0x01                    ; Periodic Interrupt bit mask
  RTC_PI_bp = 0                       ; Periodic Interrupt bit position
  
  ; RTC_PITINTFLAGS masks
  ; Masks for RTC_PI already defined
  
  ; RTC_PITDBGCTRL masks
  ; Masks for RTC_DBGRUN already defined
  
  ; Clock Select
  RTC_CLKSEL_INT32K_gc = (0x00<<0)    ; Internal 32kHz OSC
  RTC_CLKSEL_INT1K_gc = (0x01<<0)     ; Internal 1kHz OSC
  RTC_CLKSEL_TOSC32K_gc = (0x02<<0)   ; 32KHz Crystal OSC
  RTC_CLKSEL_EXTCLK_gc = (0x03<<0)    ; External Clock
  
  ; Prescaling Factor select
  RTC_PRESCALER_DIV1_gc = (0x00<<3)   ; RTC Clock / 1
  RTC_PRESCALER_DIV2_gc = (0x01<<3)   ; RTC Clock / 2
  RTC_PRESCALER_DIV4_gc = (0x02<<3)   ; RTC Clock / 4
  RTC_PRESCALER_DIV8_gc = (0x03<<3)   ; RTC Clock / 8
  RTC_PRESCALER_DIV16_gc = (0x04<<3)  ; RTC Clock / 16
  RTC_PRESCALER_DIV32_gc = (0x05<<3)  ; RTC Clock / 32
  RTC_PRESCALER_DIV64_gc = (0x06<<3)  ; RTC Clock / 64
  RTC_PRESCALER_DIV128_gc = (0x07<<3) ; RTC Clock / 128
  RTC_PRESCALER_DIV256_gc = (0x08<<3) ; RTC Clock / 256
  RTC_PRESCALER_DIV512_gc = (0x09<<3) ; RTC Clock / 512
  RTC_PRESCALER_DIV1024_gc = (0x0A<<3) ; RTC Clock / 1024
  RTC_PRESCALER_DIV2048_gc = (0x0B<<3) ; RTC Clock / 2048
  RTC_PRESCALER_DIV4096_gc = (0x0C<<3) ; RTC Clock / 4096
  RTC_PRESCALER_DIV8192_gc = (0x0D<<3) ; RTC Clock / 8192
  RTC_PRESCALER_DIV16384_gc = (0x0E<<3) ; RTC Clock / 16384
  RTC_PRESCALER_DIV32768_gc = (0x0F<<3) ; RTC Clock / 32768
  
  ; Period select
  RTC_PERIOD_OFF_gc = (0x00<<3)       ; Off
  RTC_PERIOD_CYC4_gc = (0x01<<3)      ; RTC Clock Cycles 4
  RTC_PERIOD_CYC8_gc = (0x02<<3)      ; RTC Clock Cycles 8
  RTC_PERIOD_CYC16_gc = (0x03<<3)     ; RTC Clock Cycles 16
  RTC_PERIOD_CYC32_gc = (0x04<<3)     ; RTC Clock Cycles 32
  RTC_PERIOD_CYC64_gc = (0x05<<3)     ; RTC Clock Cycles 64
  RTC_PERIOD_CYC128_gc = (0x06<<3)    ; RTC Clock Cycles 128
  RTC_PERIOD_CYC256_gc = (0x07<<3)    ; RTC Clock Cycles 256
  RTC_PERIOD_CYC512_gc = (0x08<<3)    ; RTC Clock Cycles 512
  RTC_PERIOD_CYC1024_gc = (0x09<<3)   ; RTC Clock Cycles 1024
  RTC_PERIOD_CYC2048_gc = (0x0A<<3)   ; RTC Clock Cycles 2048
  RTC_PERIOD_CYC4096_gc = (0x0B<<3)   ; RTC Clock Cycles 4096
  RTC_PERIOD_CYC8192_gc = (0x0C<<3)   ; RTC Clock Cycles 8192
  RTC_PERIOD_CYC16384_gc = (0x0D<<3)  ; RTC Clock Cycles 16384
  RTC_PERIOD_CYC32768_gc = (0x0E<<3)  ; RTC Clock Cycles 32768
  
  
  ;*************************************************************************
  ;** SIGROW - Signature row
  ;*************************************************************************
  
  
  ;*************************************************************************
  ;** SLPCTRL - Sleep Controller
  ;*************************************************************************
  
  ; SLPCTRL_CTRLA masks
  SLPCTRL_SEN_bm = 0x01               ; Sleep enable bit mask
  SLPCTRL_SEN_bp = 0                  ; Sleep enable bit position
  SLPCTRL_SMODE_gm = 0x06             ; Sleep mode group mask
  SLPCTRL_SMODE_gp = 1                ; Sleep mode group position
  SLPCTRL_SMODE_0_bm = (1<<1)         ; Sleep mode bit 0 mask
  SLPCTRL_SMODE_0_bp = 1              ; Sleep mode bit 0 position
  SLPCTRL_SMODE_1_bm = (1<<2)         ; Sleep mode bit 1 mask
  SLPCTRL_SMODE_1_bp = 2              ; Sleep mode bit 1 position
  
  ; Sleep mode select
  SLPCTRL_SMODE_IDLE_gc = (0x00<<1)   ; Idle mode
  SLPCTRL_SMODE_STDBY_gc = (0x01<<1)  ; Standby Mode
  SLPCTRL_SMODE_PDOWN_gc = (0x02<<1)  ; Power-down Mode
  
  
  ;*************************************************************************
  ;** SPI - Serial Peripheral Interface
  ;*************************************************************************
  
  ; SPI_CTRLA masks
  SPI_ENABLE_bm = 0x01                ; Enable Module bit mask
  SPI_ENABLE_bp = 0                   ; Enable Module bit position
  SPI_PRESC_gm = 0x06                 ; Prescaler group mask
  SPI_PRESC_gp = 1                    ; Prescaler group position
  SPI_PRESC_0_bm = (1<<1)             ; Prescaler bit 0 mask
  SPI_PRESC_0_bp = 1                  ; Prescaler bit 0 position
  SPI_PRESC_1_bm = (1<<2)             ; Prescaler bit 1 mask
  SPI_PRESC_1_bp = 2                  ; Prescaler bit 1 position
  SPI_CLK2X_bm = 0x10                 ; Enable Double Speed bit mask
  SPI_CLK2X_bp = 4                    ; Enable Double Speed bit position
  SPI_MASTER_bm = 0x20                ; Host Operation Enable bit mask
  SPI_MASTER_bp = 5                   ; Host Operation Enable bit position
  SPI_DORD_bm = 0x40                  ; Data Order Setting bit mask
  SPI_DORD_bp = 6                     ; Data Order Setting bit position
  
  ; SPI_CTRLB masks
  SPI_MODE_gm = 0x03                  ; SPI Mode group mask
  SPI_MODE_gp = 0                     ; SPI Mode group position
  SPI_MODE_0_bm = (1<<0)              ; SPI Mode bit 0 mask
  SPI_MODE_0_bp = 0                   ; SPI Mode bit 0 position
  SPI_MODE_1_bm = (1<<1)              ; SPI Mode bit 1 mask
  SPI_MODE_1_bp = 1                   ; SPI Mode bit 1 position
  SPI_SSD_bm = 0x04                   ; SPI Select Disable bit mask
  SPI_SSD_bp = 2                      ; SPI Select Disable bit position
  SPI_BUFWR_bm = 0x40                 ; Buffer Mode Wait for Receive bit mask
  SPI_BUFWR_bp = 6                    ; Buffer Mode Wait for Receive bit position
  SPI_BUFEN_bm = 0x80                 ; Buffer Mode Enable bit mask
  SPI_BUFEN_bp = 7                    ; Buffer Mode Enable bit position
  
  ; SPI_INTCTRL masks
  SPI_IE_bm = 0x01                    ; Interrupt Enable bit mask
  SPI_IE_bp = 0                       ; Interrupt Enable bit position
  SPI_SSIE_bm = 0x10                  ; SPI Select Trigger Interrupt Enable bit mask
  SPI_SSIE_bp = 4                     ; SPI Select Trigger Interrupt Enable bit position
  SPI_DREIE_bm = 0x20                 ; Data Register Empty Interrupt Enable bit mask
  SPI_DREIE_bp = 5                    ; Data Register Empty Interrupt Enable bit position
  SPI_TXCIE_bm = 0x40                 ; Transfer Complete Interrupt Enable bit mask
  SPI_TXCIE_bp = 6                    ; Transfer Complete Interrupt Enable bit position
  SPI_RXCIE_bm = 0x80                 ; Receive Complete Interrupt Enable bit mask
  SPI_RXCIE_bp = 7                    ; Receive Complete Interrupt Enable bit position
  
  ; SPI_INTFLAGS masks
  SPI_BUFOVF_bm = 0x01                ; Buffer Overflow bit mask
  SPI_BUFOVF_bp = 0                   ; Buffer Overflow bit position
  SPI_SSIF_bm = 0x10                  ; SPI Select Trigger Interrupt Flag bit mask
  SPI_SSIF_bp = 4                     ; SPI Select Trigger Interrupt Flag bit position
  SPI_DREIF_bm = 0x20                 ; Data Register Empty Interrupt Flag bit mask
  SPI_DREIF_bp = 5                    ; Data Register Empty Interrupt Flag bit position
  SPI_TXCIF_bm = 0x40                 ; Transfer Complete Interrupt Flag bit mask
  SPI_TXCIF_bp = 6                    ; Transfer Complete Interrupt Flag bit position
  SPI_WRCOL_bm = 0x40                 ; Write Collision bit mask
  SPI_WRCOL_bp = 6                    ; Write Collision bit position
  SPI_RXCIF_bm = 0x80                 ; Receive Complete Interrupt Flag bit mask
  SPI_RXCIF_bp = 7                    ; Receive Complete Interrupt Flag bit position
  SPI_IF_bm = 0x80                    ; Interrupt Flag bit mask
  SPI_IF_bp = 7                       ; Interrupt Flag bit position
  
  ; Prescaler select
  SPI_PRESC_DIV4_gc = (0x00<<1)       ; System Clock / 4
  SPI_PRESC_DIV16_gc = (0x01<<1)      ; System Clock / 16
  SPI_PRESC_DIV64_gc = (0x02<<1)      ; System Clock / 64
  SPI_PRESC_DIV128_gc = (0x03<<1)     ; System Clock / 128
  
  ; SPI Mode select
  SPI_MODE_0_gc = (0x00<<0)           ; SPI Mode 0
  SPI_MODE_1_gc = (0x01<<0)           ; SPI Mode 1
  SPI_MODE_2_gc = (0x02<<0)           ; SPI Mode 2
  SPI_MODE_3_gc = (0x03<<0)           ; SPI Mode 3
  
  
  ;*************************************************************************
  ;** SYSCFG - System Configuration Registers
  ;*************************************************************************
  
  
  ;*************************************************************************
  ;** TCA - 16-bit Timer/Counter Type A
  ;*************************************************************************
  
  ; TCA_SINGLE_CTRLA masks
  TCA_SINGLE_ENABLE_bm = 0x01         ; Module Enable bit mask
  TCA_SINGLE_ENABLE_bp = 0            ; Module Enable bit position
  TCA_SINGLE_CLKSEL_gm = 0x0E         ; Clock Selection group mask
  TCA_SINGLE_CLKSEL_gp = 1            ; Clock Selection group position
  TCA_SINGLE_CLKSEL_0_bm = (1<<1)     ; Clock Selection bit 0 mask
  TCA_SINGLE_CLKSEL_0_bp = 1          ; Clock Selection bit 0 position
  TCA_SINGLE_CLKSEL_1_bm = (1<<2)     ; Clock Selection bit 1 mask
  TCA_SINGLE_CLKSEL_1_bp = 2          ; Clock Selection bit 1 position
  TCA_SINGLE_CLKSEL_2_bm = (1<<3)     ; Clock Selection bit 2 mask
  TCA_SINGLE_CLKSEL_2_bp = 3          ; Clock Selection bit 2 position
  TCA_SINGLE_RUNSTDBY_bm = 0x80       ; Run in Standby bit mask
  TCA_SINGLE_RUNSTDBY_bp = 7          ; Run in Standby bit position
  
  ; TCA_SINGLE_CTRLB masks
  TCA_SINGLE_WGMODE_gm = 0x07         ; Waveform generation mode group mask
  TCA_SINGLE_WGMODE_gp = 0            ; Waveform generation mode group position
  TCA_SINGLE_WGMODE_0_bm = (1<<0)     ; Waveform generation mode bit 0 mask
  TCA_SINGLE_WGMODE_0_bp = 0          ; Waveform generation mode bit 0 position
  TCA_SINGLE_WGMODE_1_bm = (1<<1)     ; Waveform generation mode bit 1 mask
  TCA_SINGLE_WGMODE_1_bp = 1          ; Waveform generation mode bit 1 position
  TCA_SINGLE_WGMODE_2_bm = (1<<2)     ; Waveform generation mode bit 2 mask
  TCA_SINGLE_WGMODE_2_bp = 2          ; Waveform generation mode bit 2 position
  TCA_SINGLE_ALUPD_bm = 0x08          ; Auto Lock Update bit mask
  TCA_SINGLE_ALUPD_bp = 3             ; Auto Lock Update bit position
  TCA_SINGLE_CMP0EN_bm = 0x10         ; Compare 0 Enable bit mask
  TCA_SINGLE_CMP0EN_bp = 4            ; Compare 0 Enable bit position
  TCA_SINGLE_CMP1EN_bm = 0x20         ; Compare 1 Enable bit mask
  TCA_SINGLE_CMP1EN_bp = 5            ; Compare 1 Enable bit position
  TCA_SINGLE_CMP2EN_bm = 0x40         ; Compare 2 Enable bit mask
  TCA_SINGLE_CMP2EN_bp = 6            ; Compare 2 Enable bit position
  
  ; TCA_SINGLE_CTRLC masks
  TCA_SINGLE_CMP0OV_bm = 0x01         ; Compare 0 Waveform Output Value bit mask
  TCA_SINGLE_CMP0OV_bp = 0            ; Compare 0 Waveform Output Value bit position
  TCA_SINGLE_CMP1OV_bm = 0x02         ; Compare 1 Waveform Output Value bit mask
  TCA_SINGLE_CMP1OV_bp = 1            ; Compare 1 Waveform Output Value bit position
  TCA_SINGLE_CMP2OV_bm = 0x04         ; Compare 2 Waveform Output Value bit mask
  TCA_SINGLE_CMP2OV_bp = 2            ; Compare 2 Waveform Output Value bit position
  
  ; TCA_SINGLE_CTRLD masks
  TCA_SINGLE_SPLITM_bm = 0x01         ; Split Mode Enable bit mask
  TCA_SINGLE_SPLITM_bp = 0            ; Split Mode Enable bit position
  
  ; TCA_SINGLE_CTRLECLR masks
  TCA_SINGLE_DIR_bm = 0x01            ; Direction bit mask
  TCA_SINGLE_DIR_bp = 0               ; Direction bit position
  TCA_SINGLE_LUPD_bm = 0x02           ; Lock Update bit mask
  TCA_SINGLE_LUPD_bp = 1              ; Lock Update bit position
  TCA_SINGLE_CMD_gm = 0x0C            ; Command group mask
  TCA_SINGLE_CMD_gp = 2               ; Command group position
  TCA_SINGLE_CMD_0_bm = (1<<2)        ; Command bit 0 mask
  TCA_SINGLE_CMD_0_bp = 2             ; Command bit 0 position
  TCA_SINGLE_CMD_1_bm = (1<<3)        ; Command bit 1 mask
  TCA_SINGLE_CMD_1_bp = 3             ; Command bit 1 position
  
  ; TCA_SINGLE_CTRLESET masks
  ; Masks for TCA_SINGLE_DIR already defined
  ; Masks for TCA_SINGLE_LUPD already defined
  ; Masks for TCA_SINGLE_CMD already defined
  
  ; TCA_SINGLE_CTRLFCLR masks
  TCA_SINGLE_PERBV_bm = 0x01          ; Period Buffer Valid bit mask
  TCA_SINGLE_PERBV_bp = 0             ; Period Buffer Valid bit position
  TCA_SINGLE_CMP0BV_bm = 0x02         ; Compare 0 Buffer Valid bit mask
  TCA_SINGLE_CMP0BV_bp = 1            ; Compare 0 Buffer Valid bit position
  TCA_SINGLE_CMP1BV_bm = 0x04         ; Compare 1 Buffer Valid bit mask
  TCA_SINGLE_CMP1BV_bp = 2            ; Compare 1 Buffer Valid bit position
  TCA_SINGLE_CMP2BV_bm = 0x08         ; Compare 2 Buffer Valid bit mask
  TCA_SINGLE_CMP2BV_bp = 3            ; Compare 2 Buffer Valid bit position
  
  ; TCA_SINGLE_CTRLFSET masks
  ; Masks for TCA_SINGLE_PERBV already defined
  ; Masks for TCA_SINGLE_CMP0BV already defined
  ; Masks for TCA_SINGLE_CMP1BV already defined
  ; Masks for TCA_SINGLE_CMP2BV already defined
  
  ; TCA_SINGLE_EVCTRL masks
  TCA_SINGLE_CNTAEI_bm = 0x01         ; Count on Event Input A bit mask
  TCA_SINGLE_CNTAEI_bp = 0            ; Count on Event Input A bit position
  TCA_SINGLE_EVACTA_gm = 0x0E         ; Event Action A group mask
  TCA_SINGLE_EVACTA_gp = 1            ; Event Action A group position
  TCA_SINGLE_EVACTA_0_bm = (1<<1)     ; Event Action A bit 0 mask
  TCA_SINGLE_EVACTA_0_bp = 1          ; Event Action A bit 0 position
  TCA_SINGLE_EVACTA_1_bm = (1<<2)     ; Event Action A bit 1 mask
  TCA_SINGLE_EVACTA_1_bp = 2          ; Event Action A bit 1 position
  TCA_SINGLE_EVACTA_2_bm = (1<<3)     ; Event Action A bit 2 mask
  TCA_SINGLE_EVACTA_2_bp = 3          ; Event Action A bit 2 position
  TCA_SINGLE_CNTBEI_bm = 0x10         ; Count on Event Input B bit mask
  TCA_SINGLE_CNTBEI_bp = 4            ; Count on Event Input B bit position
  TCA_SINGLE_EVACTB_gm = 0xE0         ; Event Action B group mask
  TCA_SINGLE_EVACTB_gp = 5            ; Event Action B group position
  TCA_SINGLE_EVACTB_0_bm = (1<<5)     ; Event Action B bit 0 mask
  TCA_SINGLE_EVACTB_0_bp = 5          ; Event Action B bit 0 position
  TCA_SINGLE_EVACTB_1_bm = (1<<6)     ; Event Action B bit 1 mask
  TCA_SINGLE_EVACTB_1_bp = 6          ; Event Action B bit 1 position
  TCA_SINGLE_EVACTB_2_bm = (1<<7)     ; Event Action B bit 2 mask
  TCA_SINGLE_EVACTB_2_bp = 7          ; Event Action B bit 2 position
  
  ; TCA_SINGLE_INTCTRL masks
  TCA_SINGLE_OVF_bm = 0x01            ; Overflow Interrupt bit mask
  TCA_SINGLE_OVF_bp = 0               ; Overflow Interrupt bit position
  TCA_SINGLE_CMP0_bm = 0x10           ; Compare 0 Interrupt bit mask
  TCA_SINGLE_CMP0_bp = 4              ; Compare 0 Interrupt bit position
  TCA_SINGLE_CMP1_bm = 0x20           ; Compare 1 Interrupt bit mask
  TCA_SINGLE_CMP1_bp = 5              ; Compare 1 Interrupt bit position
  TCA_SINGLE_CMP2_bm = 0x40           ; Compare 2 Interrupt bit mask
  TCA_SINGLE_CMP2_bp = 6              ; Compare 2 Interrupt bit position
  
  ; TCA_SINGLE_INTFLAGS masks
  ; Masks for TCA_SINGLE_OVF already defined
  ; Masks for TCA_SINGLE_CMP0 already defined
  ; Masks for TCA_SINGLE_CMP1 already defined
  ; Masks for TCA_SINGLE_CMP2 already defined
  
  ; TCA_SINGLE_DBGCTRL masks
  TCA_SINGLE_DBGRUN_bm = 0x01         ; Debug Run bit mask
  TCA_SINGLE_DBGRUN_bp = 0            ; Debug Run bit position
  
  ; Masks for CTRLA already defined
  ; Masks for CTRLB already defined
  ; Masks for CTRLC already defined
  ; Masks for CTRLD already defined
  ; Masks for CTRLECLR already defined
  ; Masks for CTRLESET already defined
  ; Masks for INTCTRL already defined
  ; Masks for INTFLAGS already defined
  ; Masks for DBGCTRL already defined
  ; TCA_SPLIT_CTRLA masks
  TCA_SPLIT_ENABLE_bm = 0x01          ; Module Enable bit mask
  TCA_SPLIT_ENABLE_bp = 0             ; Module Enable bit position
  TCA_SPLIT_CLKSEL_gm = 0x0E          ; Clock Selection group mask
  TCA_SPLIT_CLKSEL_gp = 1             ; Clock Selection group position
  TCA_SPLIT_CLKSEL_0_bm = (1<<1)      ; Clock Selection bit 0 mask
  TCA_SPLIT_CLKSEL_0_bp = 1           ; Clock Selection bit 0 position
  TCA_SPLIT_CLKSEL_1_bm = (1<<2)      ; Clock Selection bit 1 mask
  TCA_SPLIT_CLKSEL_1_bp = 2           ; Clock Selection bit 1 position
  TCA_SPLIT_CLKSEL_2_bm = (1<<3)      ; Clock Selection bit 2 mask
  TCA_SPLIT_CLKSEL_2_bp = 3           ; Clock Selection bit 2 position
  TCA_SPLIT_RUNSTDBY_bm = 0x80        ; Run in Standby bit mask
  TCA_SPLIT_RUNSTDBY_bp = 7           ; Run in Standby bit position
  
  ; TCA_SPLIT_CTRLB masks
  TCA_SPLIT_LCMP0EN_bm = 0x01         ; Low Compare 0 Enable bit mask
  TCA_SPLIT_LCMP0EN_bp = 0            ; Low Compare 0 Enable bit position
  TCA_SPLIT_LCMP1EN_bm = 0x02         ; Low Compare 1 Enable bit mask
  TCA_SPLIT_LCMP1EN_bp = 1            ; Low Compare 1 Enable bit position
  TCA_SPLIT_LCMP2EN_bm = 0x04         ; Low Compare 2 Enable bit mask
  TCA_SPLIT_LCMP2EN_bp = 2            ; Low Compare 2 Enable bit position
  TCA_SPLIT_HCMP0EN_bm = 0x10         ; High Compare 0 Enable bit mask
  TCA_SPLIT_HCMP0EN_bp = 4            ; High Compare 0 Enable bit position
  TCA_SPLIT_HCMP1EN_bm = 0x20         ; High Compare 1 Enable bit mask
  TCA_SPLIT_HCMP1EN_bp = 5            ; High Compare 1 Enable bit position
  TCA_SPLIT_HCMP2EN_bm = 0x40         ; High Compare 2 Enable bit mask
  TCA_SPLIT_HCMP2EN_bp = 6            ; High Compare 2 Enable bit position
  
  ; TCA_SPLIT_CTRLC masks
  TCA_SPLIT_LCMP0OV_bm = 0x01         ; Low Compare 0 Output Value bit mask
  TCA_SPLIT_LCMP0OV_bp = 0            ; Low Compare 0 Output Value bit position
  TCA_SPLIT_LCMP1OV_bm = 0x02         ; Low Compare 1 Output Value bit mask
  TCA_SPLIT_LCMP1OV_bp = 1            ; Low Compare 1 Output Value bit position
  TCA_SPLIT_LCMP2OV_bm = 0x04         ; Low Compare 2 Output Value bit mask
  TCA_SPLIT_LCMP2OV_bp = 2            ; Low Compare 2 Output Value bit position
  TCA_SPLIT_HCMP0OV_bm = 0x10         ; High Compare 0 Output Value bit mask
  TCA_SPLIT_HCMP0OV_bp = 4            ; High Compare 0 Output Value bit position
  TCA_SPLIT_HCMP1OV_bm = 0x20         ; High Compare 1 Output Value bit mask
  TCA_SPLIT_HCMP1OV_bp = 5            ; High Compare 1 Output Value bit position
  TCA_SPLIT_HCMP2OV_bm = 0x40         ; High Compare 2 Output Value bit mask
  TCA_SPLIT_HCMP2OV_bp = 6            ; High Compare 2 Output Value bit position
  
  ; TCA_SPLIT_CTRLD masks
  TCA_SPLIT_SPLITM_bm = 0x01          ; Split Mode Enable bit mask
  TCA_SPLIT_SPLITM_bp = 0             ; Split Mode Enable bit position
  
  ; TCA_SPLIT_CTRLECLR masks
  TCA_SPLIT_CMDEN_gm = 0x03           ; Command Enable group mask
  TCA_SPLIT_CMDEN_gp = 0              ; Command Enable group position
  TCA_SPLIT_CMDEN_0_bm = (1<<0)       ; Command Enable bit 0 mask
  TCA_SPLIT_CMDEN_0_bp = 0            ; Command Enable bit 0 position
  TCA_SPLIT_CMDEN_1_bm = (1<<1)       ; Command Enable bit 1 mask
  TCA_SPLIT_CMDEN_1_bp = 1            ; Command Enable bit 1 position
  TCA_SPLIT_CMD_gm = 0x0C             ; Command group mask
  TCA_SPLIT_CMD_gp = 2                ; Command group position
  TCA_SPLIT_CMD_0_bm = (1<<2)         ; Command bit 0 mask
  TCA_SPLIT_CMD_0_bp = 2              ; Command bit 0 position
  TCA_SPLIT_CMD_1_bm = (1<<3)         ; Command bit 1 mask
  TCA_SPLIT_CMD_1_bp = 3              ; Command bit 1 position
  
  ; TCA_SPLIT_CTRLESET masks
  ; Masks for TCA_SPLIT_CMDEN already defined
  ; Masks for TCA_SPLIT_CMD already defined
  
  ; TCA_SPLIT_INTCTRL masks
  TCA_SPLIT_LUNF_bm = 0x01            ; Low Underflow Interrupt Enable bit mask
  TCA_SPLIT_LUNF_bp = 0               ; Low Underflow Interrupt Enable bit position
  TCA_SPLIT_HUNF_bm = 0x02            ; High Underflow Interrupt Enable bit mask
  TCA_SPLIT_HUNF_bp = 1               ; High Underflow Interrupt Enable bit position
  TCA_SPLIT_LCMP0_bm = 0x10           ; Low Compare 0 Interrupt Enable bit mask
  TCA_SPLIT_LCMP0_bp = 4              ; Low Compare 0 Interrupt Enable bit position
  TCA_SPLIT_LCMP1_bm = 0x20           ; Low Compare 1 Interrupt Enable bit mask
  TCA_SPLIT_LCMP1_bp = 5              ; Low Compare 1 Interrupt Enable bit position
  TCA_SPLIT_LCMP2_bm = 0x40           ; Low Compare 2 Interrupt Enable bit mask
  TCA_SPLIT_LCMP2_bp = 6              ; Low Compare 2 Interrupt Enable bit position
  
  ; TCA_SPLIT_INTFLAGS masks
  ; Masks for TCA_SPLIT_LUNF already defined
  ; Masks for TCA_SPLIT_HUNF already defined
  ; Masks for TCA_SPLIT_LCMP0 already defined
  ; Masks for TCA_SPLIT_LCMP1 already defined
  ; Masks for TCA_SPLIT_LCMP2 already defined
  
  ; TCA_SPLIT_DBGCTRL masks
  TCA_SPLIT_DBGRUN_bm = 0x01          ; Debug Run bit mask
  TCA_SPLIT_DBGRUN_bp = 0             ; Debug Run bit position
  
  ; Clock Selection
  TCA_SINGLE_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock
  TCA_SINGLE_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2
  TCA_SINGLE_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4
  TCA_SINGLE_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8
  TCA_SINGLE_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16
  TCA_SINGLE_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64
  TCA_SINGLE_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256
  TCA_SINGLE_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024
  
  ; Waveform generation mode select
  TCA_SINGLE_WGMODE_NORMAL_gc = (0x00<<0) ; Normal Mode
  TCA_SINGLE_WGMODE_FRQ_gc = (0x01<<0) ; Frequency Generation Mode
  TCA_SINGLE_WGMODE_SINGLESLOPE_gc = (0x03<<0) ; Single Slope PWM
  TCA_SINGLE_WGMODE_DSTOP_gc = (0x05<<0) ; Dual Slope PWM, overflow on TOP
  TCA_SINGLE_WGMODE_DSBOTH_gc = (0x06<<0) ; Dual Slope PWM, overflow on TOP and BOTTOM
  TCA_SINGLE_WGMODE_DSBOTTOM_gc = (0x07<<0) ; Dual Slope PWM, overflow on BOTTOM
  
  ; Command select
  TCA_SINGLE_CMD_NONE_gc = (0x00<<2)  ; No Command
  TCA_SINGLE_CMD_UPDATE_gc = (0x01<<2) ; Force Update
  TCA_SINGLE_CMD_RESTART_gc = (0x02<<2) ; Force Restart
  TCA_SINGLE_CMD_RESET_gc = (0x03<<2) ; Force Hard Reset
  
  ; Direction select
  TCA_SINGLE_DIR_UP_gc = (0x00<<0)    ; Count up
  TCA_SINGLE_DIR_DOWN_gc = (0x01<<0)  ; Count down
  
  ; Event Action A select
  TCA_SINGLE_EVACTA_CNT_POSEDGE_gc = (0x00<<1) ; Count on positive edge event
  TCA_SINGLE_EVACTA_CNT_ANYEDGE_gc = (0x01<<1) ; Count on any edge event
  TCA_SINGLE_EVACTA_CNT_HIGHLVL_gc = (0x02<<1) ; Count on prescaled clock while event line is 1.
  TCA_SINGLE_EVACTA_UPDOWN_gc = (0x03<<1) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.
  
  ; Event Action B select
  TCA_SINGLE_EVACTB_NONE_gc = (0x00<<5) ; No Action
  TCA_SINGLE_EVACTB_UPDOWN_gc = (0x03<<5) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.
  TCA_SINGLE_EVACTB_RESTART_POSEDGE_gc = (0x04<<5) ; Restart counter at positive edge event
  TCA_SINGLE_EVACTB_RESTART_ANYEDGE_gc = (0x05<<5) ; Restart counter on any edge event
  TCA_SINGLE_EVACTB_RESTART_HIGHLVL_gc = (0x06<<5) ; Restart counter while event line is 1.
  
  ; Clock Selection
  TCA_SPLIT_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock
  TCA_SPLIT_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2
  TCA_SPLIT_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4
  TCA_SPLIT_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8
  TCA_SPLIT_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16
  TCA_SPLIT_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64
  TCA_SPLIT_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256
  TCA_SPLIT_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024
  
  ; Command select
  TCA_SPLIT_CMD_NONE_gc = (0x00<<2)   ; No Command
  TCA_SPLIT_CMD_UPDATE_gc = (0x01<<2) ; Force Update
  TCA_SPLIT_CMD_RESTART_gc = (0x02<<2) ; Force Restart
  TCA_SPLIT_CMD_RESET_gc = (0x03<<2)  ; Force Hard Reset
  
  ; Command Enable select
  TCA_SPLIT_CMDEN_NONE_gc = (0x00<<0) ; None
  TCA_SPLIT_CMDEN_BOTH_gc = (0x03<<0) ; Both low byte and high byte counter
  
  
  ;*************************************************************************
  ;** TCB - 16-bit Timer Type B
  ;*************************************************************************
  
  ; TCB_CTRLA masks
  TCB_ENABLE_bm = 0x01                ; Enable bit mask
  TCB_ENABLE_bp = 0                   ; Enable bit position
  TCB_CLKSEL_gm = 0x0E                ; Clock Select group mask
  TCB_CLKSEL_gp = 1                   ; Clock Select group position
  TCB_CLKSEL_0_bm = (1<<1)            ; Clock Select bit 0 mask
  TCB_CLKSEL_0_bp = 1                 ; Clock Select bit 0 position
  TCB_CLKSEL_1_bm = (1<<2)            ; Clock Select bit 1 mask
  TCB_CLKSEL_1_bp = 2                 ; Clock Select bit 1 position
  TCB_CLKSEL_2_bm = (1<<3)            ; Clock Select bit 2 mask
  TCB_CLKSEL_2_bp = 3                 ; Clock Select bit 2 position
  TCB_SYNCUPD_bm = 0x10               ; Synchronize Update bit mask
  TCB_SYNCUPD_bp = 4                  ; Synchronize Update bit position
  TCB_CASCADE_bm = 0x20               ; Cascade two timers bit mask
  TCB_CASCADE_bp = 5                  ; Cascade two timers bit position
  TCB_RUNSTDBY_bm = 0x40              ; Run Standby bit mask
  TCB_RUNSTDBY_bp = 6                 ; Run Standby bit position
  
  ; TCB_CTRLB masks
  TCB_CNTMODE_gm = 0x07               ; Timer Mode group mask
  TCB_CNTMODE_gp = 0                  ; Timer Mode group position
  TCB_CNTMODE_0_bm = (1<<0)           ; Timer Mode bit 0 mask
  TCB_CNTMODE_0_bp = 0                ; Timer Mode bit 0 position
  TCB_CNTMODE_1_bm = (1<<1)           ; Timer Mode bit 1 mask
  TCB_CNTMODE_1_bp = 1                ; Timer Mode bit 1 position
  TCB_CNTMODE_2_bm = (1<<2)           ; Timer Mode bit 2 mask
  TCB_CNTMODE_2_bp = 2                ; Timer Mode bit 2 position
  TCB_CCMPEN_bm = 0x10                ; Pin Output Enable bit mask
  TCB_CCMPEN_bp = 4                   ; Pin Output Enable bit position
  TCB_CCMPINIT_bm = 0x20              ; Pin Initial State bit mask
  TCB_CCMPINIT_bp = 5                 ; Pin Initial State bit position
  TCB_ASYNC_bm = 0x40                 ; Asynchronous Enable bit mask
  TCB_ASYNC_bp = 6                    ; Asynchronous Enable bit position
  
  ; TCB_EVCTRL masks
  TCB_CAPTEI_bm = 0x01                ; Event Input Enable bit mask
  TCB_CAPTEI_bp = 0                   ; Event Input Enable bit position
  TCB_EDGE_bm = 0x10                  ; Event Edge bit mask
  TCB_EDGE_bp = 4                     ; Event Edge bit position
  TCB_FILTER_bm = 0x40                ; Input Capture Noise Cancellation Filter bit mask
  TCB_FILTER_bp = 6                   ; Input Capture Noise Cancellation Filter bit position
  
  ; TCB_INTCTRL masks
  TCB_CAPT_bm = 0x01                  ; Capture or Timeout bit mask
  TCB_CAPT_bp = 0                     ; Capture or Timeout bit position
  TCB_OVF_bm = 0x02                   ; Overflow bit mask
  TCB_OVF_bp = 1                      ; Overflow bit position
  
  ; TCB_INTFLAGS masks
  ; Masks for TCB_CAPT already defined
  ; Masks for TCB_OVF already defined
  
  ; TCB_STATUS masks
  TCB_RUN_bm = 0x01                   ; Run bit mask
  TCB_RUN_bp = 0                      ; Run bit position
  
  ; TCB_DBGCTRL masks
  TCB_DBGRUN_bm = 0x01                ; Debug Run bit mask
  TCB_DBGRUN_bp = 0                   ; Debug Run bit position
  
  ; Clock Select
  TCB_CLKSEL_DIV1_gc = (0x00<<1)      ; CLK_PER
  TCB_CLKSEL_DIV2_gc = (0x01<<1)      ; CLK_PER/2
  TCB_CLKSEL_TCA0_gc = (0x02<<1)      ; Use CLK_TCA from TCA0
  TCB_CLKSEL_EVENT_gc = (0x07<<1)     ; Count on event edge
  
  ; Timer Mode select
  TCB_CNTMODE_INT_gc = (0x00<<0)      ; Periodic Interrupt
  TCB_CNTMODE_TIMEOUT_gc = (0x01<<0)  ; Periodic Timeout
  TCB_CNTMODE_CAPT_gc = (0x02<<0)     ; Input Capture Event
  TCB_CNTMODE_FRQ_gc = (0x03<<0)      ; Input Capture Frequency measurement
  TCB_CNTMODE_PW_gc = (0x04<<0)       ; Input Capture Pulse-Width measurement
  TCB_CNTMODE_FRQPW_gc = (0x05<<0)    ; Input Capture Frequency and Pulse-Width measurement
  TCB_CNTMODE_SINGLE_gc = (0x06<<0)   ; Single Shot
  TCB_CNTMODE_PWM8_gc = (0x07<<0)     ; 8-bit PWM
  
  
  ;*************************************************************************
  ;** TWI - Two-Wire Interface
  ;*************************************************************************
  
  ; TWI_CTRLA masks
  TWI_FMPEN_bm = 0x02                 ; Fast-mode Plus Enable bit mask
  TWI_FMPEN_bp = 1                    ; Fast-mode Plus Enable bit position
  TWI_SDAHOLD_gm = 0x0C               ; SDA Hold Time group mask
  TWI_SDAHOLD_gp = 2                  ; SDA Hold Time group position
  TWI_SDAHOLD_0_bm = (1<<2)           ; SDA Hold Time bit 0 mask
  TWI_SDAHOLD_0_bp = 2                ; SDA Hold Time bit 0 position
  TWI_SDAHOLD_1_bm = (1<<3)           ; SDA Hold Time bit 1 mask
  TWI_SDAHOLD_1_bp = 3                ; SDA Hold Time bit 1 position
  TWI_SDASETUP_bm = 0x10              ; SDA Setup Time bit mask
  TWI_SDASETUP_bp = 4                 ; SDA Setup Time bit position
  
  ; TWI_DBGCTRL masks
  TWI_DBGRUN_bm = 0x01                ; Debug Run bit mask
  TWI_DBGRUN_bp = 0                   ; Debug Run bit position
  
  ; TWI_MCTRLA masks
  TWI_ENABLE_bm = 0x01                ; Enable TWI Host bit mask
  TWI_ENABLE_bp = 0                   ; Enable TWI Host bit position
  TWI_SMEN_bm = 0x02                  ; Smart Mode Enable bit mask
  TWI_SMEN_bp = 1                     ; Smart Mode Enable bit position
  TWI_TIMEOUT_gm = 0x0C               ; Inactive Bus Timeout group mask
  TWI_TIMEOUT_gp = 2                  ; Inactive Bus Timeout group position
  TWI_TIMEOUT_0_bm = (1<<2)           ; Inactive Bus Timeout bit 0 mask
  TWI_TIMEOUT_0_bp = 2                ; Inactive Bus Timeout bit 0 position
  TWI_TIMEOUT_1_bm = (1<<3)           ; Inactive Bus Timeout bit 1 mask
  TWI_TIMEOUT_1_bp = 3                ; Inactive Bus Timeout bit 1 position
  TWI_QCEN_bm = 0x10                  ; Quick Command Enable bit mask
  TWI_QCEN_bp = 4                     ; Quick Command Enable bit position
  TWI_WIEN_bm = 0x40                  ; Write Interrupt Enable bit mask
  TWI_WIEN_bp = 6                     ; Write Interrupt Enable bit position
  TWI_RIEN_bm = 0x80                  ; Read Interrupt Enable bit mask
  TWI_RIEN_bp = 7                     ; Read Interrupt Enable bit position
  
  ; TWI_MCTRLB masks
  TWI_MCMD_gm = 0x03                  ; Command group mask
  TWI_MCMD_gp = 0                     ; Command group position
  TWI_MCMD_0_bm = (1<<0)              ; Command bit 0 mask
  TWI_MCMD_0_bp = 0                   ; Command bit 0 position
  TWI_MCMD_1_bm = (1<<1)              ; Command bit 1 mask
  TWI_MCMD_1_bp = 1                   ; Command bit 1 position
  TWI_ACKACT_bm = 0x04                ; Acknowledge Action bit mask
  TWI_ACKACT_bp = 2                   ; Acknowledge Action bit position
  TWI_FLUSH_bm = 0x08                 ; Flush bit mask
  TWI_FLUSH_bp = 3                    ; Flush bit position
  
  ; TWI_MSTATUS masks
  TWI_BUSSTATE_gm = 0x03              ; Bus State group mask
  TWI_BUSSTATE_gp = 0                 ; Bus State group position
  TWI_BUSSTATE_0_bm = (1<<0)          ; Bus State bit 0 mask
  TWI_BUSSTATE_0_bp = 0               ; Bus State bit 0 position
  TWI_BUSSTATE_1_bm = (1<<1)          ; Bus State bit 1 mask
  TWI_BUSSTATE_1_bp = 1               ; Bus State bit 1 position
  TWI_BUSERR_bm = 0x04                ; Bus Error bit mask
  TWI_BUSERR_bp = 2                   ; Bus Error bit position
  TWI_ARBLOST_bm = 0x08               ; Arbitration Lost bit mask
  TWI_ARBLOST_bp = 3                  ; Arbitration Lost bit position
  TWI_RXACK_bm = 0x10                 ; Received Acknowledge bit mask
  TWI_RXACK_bp = 4                    ; Received Acknowledge bit position
  TWI_CLKHOLD_bm = 0x20               ; Clock Hold bit mask
  TWI_CLKHOLD_bp = 5                  ; Clock Hold bit position
  TWI_WIF_bm = 0x40                   ; Write Interrupt Flag bit mask
  TWI_WIF_bp = 6                      ; Write Interrupt Flag bit position
  TWI_RIF_bm = 0x80                   ; Read Interrupt Flag bit mask
  TWI_RIF_bp = 7                      ; Read Interrupt Flag bit position
  
  ; TWI_SCTRLA masks
  ; Masks for TWI_ENABLE already defined
  ; Masks for TWI_SMEN already defined
  TWI_PMEN_bm = 0x04                  ; Permissive Mode Enable bit mask
  TWI_PMEN_bp = 2                     ; Permissive Mode Enable bit position
  TWI_PIEN_bm = 0x20                  ; Stop Interrupt Enable bit mask
  TWI_PIEN_bp = 5                     ; Stop Interrupt Enable bit position
  TWI_APIEN_bm = 0x40                 ; Address/Stop Interrupt Enable bit mask
  TWI_APIEN_bp = 6                    ; Address/Stop Interrupt Enable bit position
  TWI_DIEN_bm = 0x80                  ; Data Interrupt Enable bit mask
  TWI_DIEN_bp = 7                     ; Data Interrupt Enable bit position
  
  ; TWI_SCTRLB masks
  TWI_SCMD_gm = 0x03                  ; Command group mask
  TWI_SCMD_gp = 0                     ; Command group position
  TWI_SCMD_0_bm = (1<<0)              ; Command bit 0 mask
  TWI_SCMD_0_bp = 0                   ; Command bit 0 position
  TWI_SCMD_1_bm = (1<<1)              ; Command bit 1 mask
  TWI_SCMD_1_bp = 1                   ; Command bit 1 position
  ; Masks for TWI_ACKACT already defined
  
  ; TWI_SSTATUS masks
  TWI_AP_bm = 0x01                    ; Client Address or Stop bit mask
  TWI_AP_bp = 0                       ; Client Address or Stop bit position
  TWI_DIR_bm = 0x02                   ; Read/Write Direction bit mask
  TWI_DIR_bp = 1                      ; Read/Write Direction bit position
  ; Masks for TWI_BUSERR already defined
  TWI_COLL_bm = 0x08                  ; Collision bit mask
  TWI_COLL_bp = 3                     ; Collision bit position
  ; Masks for TWI_RXACK already defined
  ; Masks for TWI_CLKHOLD already defined
  TWI_APIF_bm = 0x40                  ; Address/Stop Interrupt Flag bit mask
  TWI_APIF_bp = 6                     ; Address/Stop Interrupt Flag bit position
  TWI_DIF_bm = 0x80                   ; Data Interrupt Flag bit mask
  TWI_DIF_bp = 7                      ; Data Interrupt Flag bit position
  
  ; TWI_SADDRMASK masks
  TWI_ADDREN_bm = 0x01                ; Address Enable bit mask
  TWI_ADDREN_bp = 0                   ; Address Enable bit position
  TWI_ADDRMASK_gm = 0xFE              ; Address Mask group mask
  TWI_ADDRMASK_gp = 1                 ; Address Mask group position
  TWI_ADDRMASK_0_bm = (1<<1)          ; Address Mask bit 0 mask
  TWI_ADDRMASK_0_bp = 1               ; Address Mask bit 0 position
  TWI_ADDRMASK_1_bm = (1<<2)          ; Address Mask bit 1 mask
  TWI_ADDRMASK_1_bp = 2               ; Address Mask bit 1 position
  TWI_ADDRMASK_2_bm = (1<<3)          ; Address Mask bit 2 mask
  TWI_ADDRMASK_2_bp = 3               ; Address Mask bit 2 position
  TWI_ADDRMASK_3_bm = (1<<4)          ; Address Mask bit 3 mask
  TWI_ADDRMASK_3_bp = 4               ; Address Mask bit 3 position
  TWI_ADDRMASK_4_bm = (1<<5)          ; Address Mask bit 4 mask
  TWI_ADDRMASK_4_bp = 5               ; Address Mask bit 4 position
  TWI_ADDRMASK_5_bm = (1<<6)          ; Address Mask bit 5 mask
  TWI_ADDRMASK_5_bp = 6               ; Address Mask bit 5 position
  TWI_ADDRMASK_6_bm = (1<<7)          ; Address Mask bit 6 mask
  TWI_ADDRMASK_6_bp = 7               ; Address Mask bit 6 position
  
  ; SDA Hold Time select
  TWI_SDAHOLD_OFF_gc = (0x00<<2)      ; SDA hold time off
  TWI_SDAHOLD_50NS_gc = (0x01<<2)     ; Typical 50ns hold time
  TWI_SDAHOLD_300NS_gc = (0x02<<2)    ; Typical 300ns hold time
  TWI_SDAHOLD_500NS_gc = (0x03<<2)    ; Typical 500ns hold time
  
  ; SDA Setup Time select
  TWI_SDASETUP_4CYC_gc = (0x00<<4)    ; SDA setup time is 4 clock cycles
  TWI_SDASETUP_8CYC_gc = (0x01<<4)    ; SDA setup time is 8 clock cycles
  
  ; Inactive Bus Timeout select
  TWI_TIMEOUT_DISABLED_gc = (0x00<<2) ; Bus Timeout Disabled
  TWI_TIMEOUT_50US_gc = (0x01<<2)     ; 50 Microseconds
  TWI_TIMEOUT_100US_gc = (0x02<<2)    ; 100 Microseconds
  TWI_TIMEOUT_200US_gc = (0x03<<2)    ; 200 Microseconds
  
  ; Acknowledge Action select
  TWI_ACKACT_ACK_gc = (0x00<<2)       ; Send ACK
  TWI_ACKACT_NACK_gc = (0x01<<2)      ; Send NACK
  
  ; Command select
  TWI_MCMD_NOACT_gc = (0x00<<0)       ; No Action
  TWI_MCMD_REPSTART_gc = (0x01<<0)    ; Issue Repeated Start Condition
  TWI_MCMD_RECVTRANS_gc = (0x02<<0)   ; Receive or Transmit Data, depending on DIR
  TWI_MCMD_STOP_gc = (0x03<<0)        ; Issue Stop Condition
  
  ; Bus State select
  TWI_BUSSTATE_UNKNOWN_gc = (0x00<<0) ; Unknown Bus State
  TWI_BUSSTATE_IDLE_gc = (0x01<<0)    ; Bus is Idle
  TWI_BUSSTATE_OWNER_gc = (0x02<<0)   ; This Module Controls The Bus
  TWI_BUSSTATE_BUSY_gc = (0x03<<0)    ; The Bus is Busy
  
  ; Command select
  TWI_SCMD_NOACT_gc = (0x00<<0)       ; No Action
  TWI_SCMD_COMPTRANS_gc = (0x02<<0)   ; Used To Complete a Transaction
  TWI_SCMD_RESPONSE_gc = (0x03<<0)    ; Used in Response to Address/Data Interrupt
  
  ; Client Address or Stop select
  TWI_AP_STOP_gc = (0x00<<0)          ; Stop condition generated APIF
  TWI_AP_ADR_gc = (0x01<<0)           ; Address detection generated APIF
  
  
  ;*************************************************************************
  ;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter
  ;*************************************************************************
  
  ; USART_RXDATAL masks
  USART_DATA_gm = 0xFF                ; RX Data group mask
  USART_DATA_gp = 0                   ; RX Data group position
  USART_DATA_0_bm = (1<<0)            ; RX Data bit 0 mask
  USART_DATA_0_bp = 0                 ; RX Data bit 0 position
  USART_DATA_1_bm = (1<<1)            ; RX Data bit 1 mask
  USART_DATA_1_bp = 1                 ; RX Data bit 1 position
  USART_DATA_2_bm = (1<<2)            ; RX Data bit 2 mask
  USART_DATA_2_bp = 2                 ; RX Data bit 2 position
  USART_DATA_3_bm = (1<<3)            ; RX Data bit 3 mask
  USART_DATA_3_bp = 3                 ; RX Data bit 3 position
  USART_DATA_4_bm = (1<<4)            ; RX Data bit 4 mask
  USART_DATA_4_bp = 4                 ; RX Data bit 4 position
  USART_DATA_5_bm = (1<<5)            ; RX Data bit 5 mask
  USART_DATA_5_bp = 5                 ; RX Data bit 5 position
  USART_DATA_6_bm = (1<<6)            ; RX Data bit 6 mask
  USART_DATA_6_bp = 6                 ; RX Data bit 6 position
  USART_DATA_7_bm = (1<<7)            ; RX Data bit 7 mask
  USART_DATA_7_bp = 7                 ; RX Data bit 7 position
  
  ; USART_RXDATAH masks
  USART_DATA8_bm = 0x01               ; Receiver Data Register bit mask
  USART_DATA8_bp = 0                  ; Receiver Data Register bit position
  USART_PERR_bm = 0x02                ; Parity Error bit mask
  USART_PERR_bp = 1                   ; Parity Error bit position
  USART_FERR_bm = 0x04                ; Frame Error bit mask
  USART_FERR_bp = 2                   ; Frame Error bit position
  USART_BUFOVF_bm = 0x40              ; Buffer Overflow bit mask
  USART_BUFOVF_bp = 6                 ; Buffer Overflow bit position
  USART_RXCIF_bm = 0x80               ; Receive Complete Interrupt Flag bit mask
  USART_RXCIF_bp = 7                  ; Receive Complete Interrupt Flag bit position
  
  ; USART_TXDATAL masks
  ; Masks for USART_DATA already defined
  
  ; USART_TXDATAH masks
  ; Masks for USART_DATA8 already defined
  
  ; USART_STATUS masks
  USART_WFB_bm = 0x01                 ; Wait For Break bit mask
  USART_WFB_bp = 0                    ; Wait For Break bit position
  USART_BDF_bm = 0x02                 ; Break Detected Flag bit mask
  USART_BDF_bp = 1                    ; Break Detected Flag bit position
  USART_ISFIF_bm = 0x08               ; Inconsistent Sync Field Interrupt Flag bit mask
  USART_ISFIF_bp = 3                  ; Inconsistent Sync Field Interrupt Flag bit position
  USART_RXSIF_bm = 0x10               ; Receive Start Interrupt bit mask
  USART_RXSIF_bp = 4                  ; Receive Start Interrupt bit position
  USART_DREIF_bm = 0x20               ; Data Register Empty Flag bit mask
  USART_DREIF_bp = 5                  ; Data Register Empty Flag bit position
  USART_TXCIF_bm = 0x40               ; Transmit Interrupt Flag bit mask
  USART_TXCIF_bp = 6                  ; Transmit Interrupt Flag bit position
  ; Masks for USART_RXCIF already defined
  
  ; USART_CTRLA masks
  USART_RS485_bm = 0x01               ; RS485 Mode internal transmitter bit mask
  USART_RS485_bp = 0                  ; RS485 Mode internal transmitter bit position
  USART_ABEIE_bm = 0x04               ; Auto-baud Error Interrupt Enable bit mask
  USART_ABEIE_bp = 2                  ; Auto-baud Error Interrupt Enable bit position
  USART_LBME_bm = 0x08                ; Loop-back Mode Enable bit mask
  USART_LBME_bp = 3                   ; Loop-back Mode Enable bit position
  USART_RXSIE_bm = 0x10               ; Receiver Start Frame Interrupt Enable bit mask
  USART_RXSIE_bp = 4                  ; Receiver Start Frame Interrupt Enable bit position
  USART_DREIE_bm = 0x20               ; Data Register Empty Interrupt Enable bit mask
  USART_DREIE_bp = 5                  ; Data Register Empty Interrupt Enable bit position
  USART_TXCIE_bm = 0x40               ; Transmit Complete Interrupt Enable bit mask
  USART_TXCIE_bp = 6                  ; Transmit Complete Interrupt Enable bit position
  USART_RXCIE_bm = 0x80               ; Receive Complete Interrupt Enable bit mask
  USART_RXCIE_bp = 7                  ; Receive Complete Interrupt Enable bit position
  
  ; USART_CTRLB masks
  USART_MPCM_bm = 0x01                ; Multi-processor Communication Mode bit mask
  USART_MPCM_bp = 0                   ; Multi-processor Communication Mode bit position
  USART_RXMODE_gm = 0x06              ; Receiver Mode group mask
  USART_RXMODE_gp = 1                 ; Receiver Mode group position
  USART_RXMODE_0_bm = (1<<1)          ; Receiver Mode bit 0 mask
  USART_RXMODE_0_bp = 1               ; Receiver Mode bit 0 position
  USART_RXMODE_1_bm = (1<<2)          ; Receiver Mode bit 1 mask
  USART_RXMODE_1_bp = 2               ; Receiver Mode bit 1 position
  USART_ODME_bm = 0x08                ; Open Drain Mode Enable bit mask
  USART_ODME_bp = 3                   ; Open Drain Mode Enable bit position
  USART_SFDEN_bm = 0x10               ; Start Frame Detection Enable bit mask
  USART_SFDEN_bp = 4                  ; Start Frame Detection Enable bit position
  USART_TXEN_bm = 0x40                ; Transmitter Enable bit mask
  USART_TXEN_bp = 6                   ; Transmitter Enable bit position
  USART_RXEN_bm = 0x80                ; Reciever enable bit mask
  USART_RXEN_bp = 7                   ; Reciever enable bit position
  
  ; USART_CTRLC masks
  USART_UCPHA_bm = 0x02               ; SPI Host Mode, Clock Phase bit mask
  USART_UCPHA_bp = 1                  ; SPI Host Mode, Clock Phase bit position
  USART_UDORD_bm = 0x04               ; SPI Host Mode, Data Order bit mask
  USART_UDORD_bp = 2                  ; SPI Host Mode, Data Order bit position
  USART_CHSIZE_gm = 0x07              ; Character Size group mask
  USART_CHSIZE_gp = 0                 ; Character Size group position
  USART_CHSIZE_0_bm = (1<<0)          ; Character Size bit 0 mask
  USART_CHSIZE_0_bp = 0               ; Character Size bit 0 position
  USART_CHSIZE_1_bm = (1<<1)          ; Character Size bit 1 mask
  USART_CHSIZE_1_bp = 1               ; Character Size bit 1 position
  USART_CHSIZE_2_bm = (1<<2)          ; Character Size bit 2 mask
  USART_CHSIZE_2_bp = 2               ; Character Size bit 2 position
  USART_SBMODE_bm = 0x08              ; Stop Bit Mode bit mask
  USART_SBMODE_bp = 3                 ; Stop Bit Mode bit position
  USART_PMODE_gm = 0x30               ; Parity Mode group mask
  USART_PMODE_gp = 4                  ; Parity Mode group position
  USART_PMODE_0_bm = (1<<4)           ; Parity Mode bit 0 mask
  USART_PMODE_0_bp = 4                ; Parity Mode bit 0 position
  USART_PMODE_1_bm = (1<<5)           ; Parity Mode bit 1 mask
  USART_PMODE_1_bp = 5                ; Parity Mode bit 1 position
  USART_CMODE_gm = 0xC0               ; Communication Mode group mask
  USART_CMODE_gp = 6                  ; Communication Mode group position
  USART_CMODE_0_bm = (1<<6)           ; Communication Mode bit 0 mask
  USART_CMODE_0_bp = 6                ; Communication Mode bit 0 position
  USART_CMODE_1_bm = (1<<7)           ; Communication Mode bit 1 mask
  USART_CMODE_1_bp = 7                ; Communication Mode bit 1 position
  
  ; USART_CTRLD masks
  USART_ABW_gm = 0xC0                 ; Auto Baud Window group mask
  USART_ABW_gp = 6                    ; Auto Baud Window group position
  USART_ABW_0_bm = (1<<6)             ; Auto Baud Window bit 0 mask
  USART_ABW_0_bp = 6                  ; Auto Baud Window bit 0 position
  USART_ABW_1_bm = (1<<7)             ; Auto Baud Window bit 1 mask
  USART_ABW_1_bp = 7                  ; Auto Baud Window bit 1 position
  
  ; USART_DBGCTRL masks
  USART_DBGRUN_bm = 0x01              ; Debug Run bit mask
  USART_DBGRUN_bp = 0                 ; Debug Run bit position
  
  ; USART_EVCTRL masks
  USART_IREI_bm = 0x01                ; IrDA Event Input Enable bit mask
  USART_IREI_bp = 0                   ; IrDA Event Input Enable bit position
  
  ; USART_TXPLCTRL masks
  USART_TXPL_gm = 0xFF                ; Transmit pulse length group mask
  USART_TXPL_gp = 0                   ; Transmit pulse length group position
  USART_TXPL_0_bm = (1<<0)            ; Transmit pulse length bit 0 mask
  USART_TXPL_0_bp = 0                 ; Transmit pulse length bit 0 position
  USART_TXPL_1_bm = (1<<1)            ; Transmit pulse length bit 1 mask
  USART_TXPL_1_bp = 1                 ; Transmit pulse length bit 1 position
  USART_TXPL_2_bm = (1<<2)            ; Transmit pulse length bit 2 mask
  USART_TXPL_2_bp = 2                 ; Transmit pulse length bit 2 position
  USART_TXPL_3_bm = (1<<3)            ; Transmit pulse length bit 3 mask
  USART_TXPL_3_bp = 3                 ; Transmit pulse length bit 3 position
  USART_TXPL_4_bm = (1<<4)            ; Transmit pulse length bit 4 mask
  USART_TXPL_4_bp = 4                 ; Transmit pulse length bit 4 position
  USART_TXPL_5_bm = (1<<5)            ; Transmit pulse length bit 5 mask
  USART_TXPL_5_bp = 5                 ; Transmit pulse length bit 5 position
  USART_TXPL_6_bm = (1<<6)            ; Transmit pulse length bit 6 mask
  USART_TXPL_6_bp = 6                 ; Transmit pulse length bit 6 position
  USART_TXPL_7_bm = (1<<7)            ; Transmit pulse length bit 7 mask
  USART_TXPL_7_bp = 7                 ; Transmit pulse length bit 7 position
  
  ; USART_RXPLCTRL masks
  USART_RXPL_gm = 0x7F                ; Receiver Pulse Lenght group mask
  USART_RXPL_gp = 0                   ; Receiver Pulse Lenght group position
  USART_RXPL_0_bm = (1<<0)            ; Receiver Pulse Lenght bit 0 mask
  USART_RXPL_0_bp = 0                 ; Receiver Pulse Lenght bit 0 position
  USART_RXPL_1_bm = (1<<1)            ; Receiver Pulse Lenght bit 1 mask
  USART_RXPL_1_bp = 1                 ; Receiver Pulse Lenght bit 1 position
  USART_RXPL_2_bm = (1<<2)            ; Receiver Pulse Lenght bit 2 mask
  USART_RXPL_2_bp = 2                 ; Receiver Pulse Lenght bit 2 position
  USART_RXPL_3_bm = (1<<3)            ; Receiver Pulse Lenght bit 3 mask
  USART_RXPL_3_bp = 3                 ; Receiver Pulse Lenght bit 3 position
  USART_RXPL_4_bm = (1<<4)            ; Receiver Pulse Lenght bit 4 mask
  USART_RXPL_4_bp = 4                 ; Receiver Pulse Lenght bit 4 position
  USART_RXPL_5_bm = (1<<5)            ; Receiver Pulse Lenght bit 5 mask
  USART_RXPL_5_bp = 5                 ; Receiver Pulse Lenght bit 5 position
  USART_RXPL_6_bm = (1<<6)            ; Receiver Pulse Lenght bit 6 mask
  USART_RXPL_6_bp = 6                 ; Receiver Pulse Lenght bit 6 position
  
  ; RS485 Mode internal transmitter select
  USART_RS485_DISABLE_gc = (0x00<<0)  ; RS485 Mode disabled
  USART_RS485_ENABLE_gc = (0x01<<0)   ; RS485 Mode enabled
  
  ; Receiver Mode select
  USART_RXMODE_NORMAL_gc = (0x00<<1)  ; Normal mode
  USART_RXMODE_CLK2X_gc = (0x01<<1)   ; CLK2x mode
  USART_RXMODE_GENAUTO_gc = (0x02<<1) ; Generic autobaud mode
  USART_RXMODE_LINAUTO_gc = (0x03<<1) ; LIN constrained autobaud mode
  
  ; Communication Mode select
  USART_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode
  USART_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode
  USART_CMODE_IRCOM_gc = (0x02<<6)    ; Infrared Communication
  USART_CMODE_MSPI_gc = (0x03<<6)     ; SPI Host Mode
  
  ; Character Size select
  USART_NORMAL_CHSIZE_5BIT_gc = (0x00<<0) ; Character size: 5 bit
  USART_NORMAL_CHSIZE_6BIT_gc = (0x01<<0) ; Character size: 6 bit
  USART_NORMAL_CHSIZE_7BIT_gc = (0x02<<0) ; Character size: 7 bit
  USART_NORMAL_CHSIZE_8BIT_gc = (0x03<<0) ; Character size: 8 bit
  USART_NORMAL_CHSIZE_9BITL_gc = (0x06<<0) ; Character size: 9 bit read low byte first
  USART_NORMAL_CHSIZE_9BITH_gc = (0x07<<0) ; Character size: 9 bit read high byte first
  
  ; Parity Mode select
  USART_NORMAL_PMODE_DISABLED_gc = (0x00<<4) ; No Parity
  USART_NORMAL_PMODE_EVEN_gc = (0x02<<4) ; Even Parity
  USART_NORMAL_PMODE_ODD_gc = (0x03<<4) ; Odd Parity
  
  ; Stop Bit Mode select
  USART_NORMAL_SBMODE_1BIT_gc = (0x00<<3) ; 1 stop bit
  USART_NORMAL_SBMODE_2BIT_gc = (0x01<<3) ; 2 stop bits
  
  ; Auto Baud Window select
  USART_ABW_WDW0_gc = (0x00<<6)       ; 18% tolerance
  USART_ABW_WDW1_gc = (0x01<<6)       ; 15% tolerance
  USART_ABW_WDW2_gc = (0x02<<6)       ; 21% tolerance
  USART_ABW_WDW3_gc = (0x03<<6)       ; 25% tolerance
  
  
  ;*************************************************************************
  ;** USERROW - User Row
  ;*************************************************************************
  
  
  ;*************************************************************************
  ;** VPORT - Virtual Ports
  ;*************************************************************************
  
  ; VPORT_INTFLAGS masks
  VPORT_INT_gm = 0xFF                 ; Pin Interrupt group mask
  VPORT_INT_gp = 0                    ; Pin Interrupt group position
  VPORT_INT_0_bm = (1<<0)             ; Pin Interrupt bit 0 mask
  VPORT_INT_0_bp = 0                  ; Pin Interrupt bit 0 position
  VPORT_INT_1_bm = (1<<1)             ; Pin Interrupt bit 1 mask
  VPORT_INT_1_bp = 1                  ; Pin Interrupt bit 1 position
  VPORT_INT_2_bm = (1<<2)             ; Pin Interrupt bit 2 mask
  VPORT_INT_2_bp = 2                  ; Pin Interrupt bit 2 position
  VPORT_INT_3_bm = (1<<3)             ; Pin Interrupt bit 3 mask
  VPORT_INT_3_bp = 3                  ; Pin Interrupt bit 3 position
  VPORT_INT_4_bm = (1<<4)             ; Pin Interrupt bit 4 mask
  VPORT_INT_4_bp = 4                  ; Pin Interrupt bit 4 position
  VPORT_INT_5_bm = (1<<5)             ; Pin Interrupt bit 5 mask
  VPORT_INT_5_bp = 5                  ; Pin Interrupt bit 5 position
  VPORT_INT_6_bm = (1<<6)             ; Pin Interrupt bit 6 mask
  VPORT_INT_6_bp = 6                  ; Pin Interrupt bit 6 position
  VPORT_INT_7_bm = (1<<7)             ; Pin Interrupt bit 7 mask
  VPORT_INT_7_bp = 7                  ; Pin Interrupt bit 7 position
  
  
  ;*************************************************************************
  ;** VREF - Voltage reference
  ;*************************************************************************
  
  ; VREF_CTRLA masks
  VREF_AC0REFSEL_gm = 0x07            ; AC0 reference select group mask
  VREF_AC0REFSEL_gp = 0               ; AC0 reference select group position
  VREF_AC0REFSEL_0_bm = (1<<0)        ; AC0 reference select bit 0 mask
  VREF_AC0REFSEL_0_bp = 0             ; AC0 reference select bit 0 position
  VREF_AC0REFSEL_1_bm = (1<<1)        ; AC0 reference select bit 1 mask
  VREF_AC0REFSEL_1_bp = 1             ; AC0 reference select bit 1 position
  VREF_AC0REFSEL_2_bm = (1<<2)        ; AC0 reference select bit 2 mask
  VREF_AC0REFSEL_2_bp = 2             ; AC0 reference select bit 2 position
  
  ; VREF_CTRLB masks
  VREF_AC0REFEN_bm = 0x01             ; AC0 DACREF reference enable bit mask
  VREF_AC0REFEN_bp = 0                ; AC0 DACREF reference enable bit position
  VREF_ADC0REFEN_bm = 0x02            ; ADC0 reference enable bit mask
  VREF_ADC0REFEN_bp = 1               ; ADC0 reference enable bit position
  VREF_NVMREFEN_bm = 0x04             ; NVM reference enable bit mask
  VREF_NVMREFEN_bp = 2                ; NVM reference enable bit position
  
  ; AC0 reference select
  VREF_AC0REFSEL_1V024_gc = (0x00<<0) ; Voltage reference at 1.024V
  VREF_AC0REFSEL_2V048_gc = (0x01<<0) ; Voltage reference at 2.048V
  VREF_AC0REFSEL_2V5_gc = (0x02<<0)   ; Voltage reference at 2.5V
  VREF_AC0REFSEL_4V096_gc = (0x03<<0) ; Voltage reference at 4.096V
  VREF_AC0REFSEL_AVDD_gc = (0x07<<0)  ; voltage reference at supply
  
  
  ;*************************************************************************
  ;** WDT - Watch-Dog Timer
  ;*************************************************************************
  
  ; WDT_CTRLA masks
  WDT_PERIOD_gm = 0x0F                ; Period group mask
  WDT_PERIOD_gp = 0                   ; Period group position
  WDT_PERIOD_0_bm = (1<<0)            ; Period bit 0 mask
  WDT_PERIOD_0_bp = 0                 ; Period bit 0 position
  WDT_PERIOD_1_bm = (1<<1)            ; Period bit 1 mask
  WDT_PERIOD_1_bp = 1                 ; Period bit 1 position
  WDT_PERIOD_2_bm = (1<<2)            ; Period bit 2 mask
  WDT_PERIOD_2_bp = 2                 ; Period bit 2 position
  WDT_PERIOD_3_bm = (1<<3)            ; Period bit 3 mask
  WDT_PERIOD_3_bp = 3                 ; Period bit 3 position
  WDT_WINDOW_gm = 0xF0                ; Window group mask
  WDT_WINDOW_gp = 4                   ; Window group position
  WDT_WINDOW_0_bm = (1<<4)            ; Window bit 0 mask
  WDT_WINDOW_0_bp = 4                 ; Window bit 0 position
  WDT_WINDOW_1_bm = (1<<5)            ; Window bit 1 mask
  WDT_WINDOW_1_bp = 5                 ; Window bit 1 position
  WDT_WINDOW_2_bm = (1<<6)            ; Window bit 2 mask
  WDT_WINDOW_2_bp = 6                 ; Window bit 2 position
  WDT_WINDOW_3_bm = (1<<7)            ; Window bit 3 mask
  WDT_WINDOW_3_bp = 7                 ; Window bit 3 position
  
  ; WDT_STATUS masks
  WDT_SYNCBUSY_bm = 0x01              ; Syncronization busy bit mask
  WDT_SYNCBUSY_bp = 0                 ; Syncronization busy bit position
  WDT_LOCK_bm = 0x80                  ; Lock enable bit mask
  WDT_LOCK_bp = 7                     ; Lock enable bit position
  
  ; Period select
  WDT_PERIOD_OFF_gc = (0x00<<0)       ; Off
  WDT_PERIOD_8CLK_gc = (0x01<<0)      ; 8 cycles (8ms)
  WDT_PERIOD_16CLK_gc = (0x02<<0)     ; 16 cycles (16ms)
  WDT_PERIOD_32CLK_gc = (0x03<<0)     ; 32 cycles (32ms)
  WDT_PERIOD_64CLK_gc = (0x04<<0)     ; 64 cycles (64ms)
  WDT_PERIOD_128CLK_gc = (0x05<<0)    ; 128 cycles (0.128s)
  WDT_PERIOD_256CLK_gc = (0x06<<0)    ; 256 cycles (0.256s)
  WDT_PERIOD_512CLK_gc = (0x07<<0)    ; 512 cycles (0.512s)
  WDT_PERIOD_1KCLK_gc = (0x08<<0)     ; 1K cycles (1.0s)
  WDT_PERIOD_2KCLK_gc = (0x09<<0)     ; 2K cycles (2.0s)
  WDT_PERIOD_4KCLK_gc = (0x0A<<0)     ; 4K cycles (4.1s)
  WDT_PERIOD_8KCLK_gc = (0x0B<<0)     ; 8K cycles (8.2s)
  
  ; Window select
  WDT_WINDOW_OFF_gc = (0x00<<4)       ; Off
  WDT_WINDOW_8CLK_gc = (0x01<<4)      ; 8 cycles (8ms)
  WDT_WINDOW_16CLK_gc = (0x02<<4)     ; 16 cycles (16ms)
  WDT_WINDOW_32CLK_gc = (0x03<<4)     ; 32 cycles (32ms)
  WDT_WINDOW_64CLK_gc = (0x04<<4)     ; 64 cycles (64ms)
  WDT_WINDOW_128CLK_gc = (0x05<<4)    ; 128 cycles (0.128s)
  WDT_WINDOW_256CLK_gc = (0x06<<4)    ; 256 cycles (0.256s)
  WDT_WINDOW_512CLK_gc = (0x07<<4)    ; 512 cycles (0.512s)
  WDT_WINDOW_1KCLK_gc = (0x08<<4)     ; 1K cycles (1.0s)
  WDT_WINDOW_2KCLK_gc = (0x09<<4)     ; 2K cycles (2.0s)
  WDT_WINDOW_4KCLK_gc = (0x0A<<4)     ; 4K cycles (4.1s)
  WDT_WINDOW_8KCLK_gc = (0x0B<<4)     ; 8K cycles (8.2s)
  
  
  
  

[Registers]
'For specific details of the registers see the microcontroller datasheet
'The first parameter is the GCBASIC register name used in user code to expose the specific register
 AC0_CTRLA,1664
 AC0_MUXCTRLA,1666
 AC0_DACREF,1668
 AC0_INTCTRL,1670
 AC0_STATUS,1671
 ADC0_CTRLA,1536
 ADC0_CTRLB,1537
 ADC0_CTRLC,1538
 ADC0_CTRLD,1539
 ADC0_INTCTRL,1540
 ADC0_INTFLAGS,1541
 ADC0_STATUS,1542
 ADC0_DBGCTRL,1543
 ADC0_CTRLE,1544
 ADC0_CTRLF,1545
 ADC0_COMMAND,1546
 ADC0_PGACTRL,1547
 ADC0_MUXPOS,1548
 ADC0_MUXNEG,1549
 ADC0_RESULT,1552
 ADC0_RESULT0,1552
 ADC0_RESULT1,1553
 ADC0_RESULT2,1554
 ADC0_RESULT3,1555
 ADC0_SAMPLE,1556
 ADC0_SAMPLEL,1556
 ADC0_SAMPLEH,1557
 ADC0_TEMP0,1560
 ADC0_TEMP1,1561
 ADC0_TEMP2,1562
 ADC0_WINLT,1564
 ADC0_WINLTL,1564
 ADC0_WINLTH,1565
 ADC0_WINHT,1566
 ADC0_WINHTL,1566
 ADC0_WINHTH,1567
 BOD_CTRLA,128
 BOD_CTRLB,129
 BOD_VLMCTRLA,136
 BOD_INTCTRL,137
 BOD_INTFLAGS,138
 BOD_STATUS,139
 CCL_CTRLA,448
 CCL_SEQCTRL0,449
 CCL_SEQCTRL1,450
 CCL_INTCTRL0,453
 CCL_INTFLAGS,455
 CCL_LUT0CTRLA,456
 CCL_LUT0CTRLB,457
 CCL_LUT0CTRLC,458
 CCL_TRUTH0,459
 CCL_LUT1CTRLA,460
 CCL_LUT1CTRLB,461
 CCL_LUT1CTRLC,462
 CCL_TRUTH1,463
 CCL_LUT2CTRLA,464
 CCL_LUT2CTRLB,465
 CCL_LUT2CTRLC,466
 CCL_TRUTH2,467
 CCL_LUT3CTRLA,468
 CCL_LUT3CTRLB,469
 CCL_LUT3CTRLC,470
 CCL_TRUTH3,471
 CLKCTRL_MCLKCTRLA,96
 CLKCTRL_MCLKCTRLB,97
 CLKCTRL_MCLKLOCK,98
 CLKCTRL_MCLKSTATUS,99
 CLKCTRL_OSC20MCTRLA,112
 CLKCTRL_OSC20MCALIBA,113
 CLKCTRL_OSC20MCALIBB,114
 CLKCTRL_OSC32KCTRLA,120
 CLKCTRL_XOSC32KCTRLA,124
 CPU_CCP,52
 CPU_SP,61
; .equ CPU_SPL = 0x003D                    ; Stack Pointer low byte a duplicate or resevered register or ALIAS_
; .equ CPU_SPH = 0x003E                    ; Stack Pointer hi byte a duplicate or resevered register or ALIAS_
 CPU_SREG,63
 CPUINT_CTRLA,272
 CPUINT_STATUS,273
 CPUINT_LVL0PRI,274
 CPUINT_LVL1VEC,275
 CRCSCAN_CTRLA,288
 CRCSCAN_CTRLB,289
 CRCSCAN_STATUS,290
 EVSYS_SWEVENTA,384
 EVSYS_CHANNEL0,400
 EVSYS_CHANNEL1,401
 EVSYS_CHANNEL2,402
 EVSYS_CHANNEL3,403
 EVSYS_CHANNEL4,404
 EVSYS_CHANNEL5,405
 EVSYS_USERCCLLUT0A,416
 EVSYS_USERCCLLUT0B,417
 EVSYS_USERCCLLUT1A,418
 EVSYS_USERCCLLUT1B,419
 EVSYS_USERCCLLUT2A,420
 EVSYS_USERCCLLUT2B,421
 EVSYS_USERCCLLUT3A,422
 EVSYS_USERCCLLUT3B,423
 EVSYS_USERADC0START,424
 EVSYS_USEREVSYSEVOUTA,425
 EVSYS_USEREVSYSEVOUTB,426
 EVSYS_USEREVSYSEVOUTC,427
 EVSYS_USERUSART0IRDA,428
 EVSYS_USERUSART1IRDA,429
 EVSYS_USERTCA0CNTA,430
 EVSYS_USERTCA0CNTB,431
 EVSYS_USERTCB0CAPT,432
 EVSYS_USERTCB0COUNT,433
 EVSYS_USERTCB1CAPT,434
 EVSYS_USERTCB1COUNT,435
 FUSE_WDTCFG,4736
 FUSE_BODCFG,4737
 FUSE_OSCCFG,4738
 FUSE_SYSCFG0,4741
 FUSE_SYSCFG1,4742
 FUSE_APPEND,4743
 FUSE_BOOTEND,4744
 GPIO_GPIOR0,28
 GPIO_GPIOR1,29
 GPIO_GPIOR2,30
 GPIO_GPIOR3,31
 LOCKBIT_LOCKBIT,4746
 NVMCTRL_CTRLA,4096
 NVMCTRL_CTRLB,4097
 NVMCTRL_STATUS,4098
 NVMCTRL_INTCTRL,4099
 NVMCTRL_INTFLAGS,4100
 NVMCTRL_DATA,4102
 NVMCTRL_DATAL,4102
 NVMCTRL_DATAH,4103
 NVMCTRL_ADDR,4104
 NVMCTRL_ADDRL,4104
 NVMCTRL_ADDRH,4105
 PORTA_DIR,1024
 PORTA_DIRSET,1025
 PORTA_DIRCLR,1026
 PORTA_DIRTGL,1027
 PORTA_OUT,1028
 PORTA_OUTSET,1029
 PORTA_OUTCLR,1030
 PORTA_OUTTGL,1031
 PORTA_IN,1032
 PORTA_INTFLAGS,1033
 PORTA_PORTCTRL,1034
 PORTA_PIN0CTRL,1040
 PORTA_PIN1CTRL,1041
 PORTA_PIN2CTRL,1042
 PORTA_PIN3CTRL,1043
 PORTA_PIN4CTRL,1044
 PORTA_PIN5CTRL,1045
 PORTA_PIN6CTRL,1046
 PORTA_PIN7CTRL,1047
 PORTB_DIR,1056
 PORTB_DIRSET,1057
 PORTB_DIRCLR,1058
 PORTB_DIRTGL,1059
 PORTB_OUT,1060
 PORTB_OUTSET,1061
 PORTB_OUTCLR,1062
 PORTB_OUTTGL,1063
 PORTB_IN,1064
 PORTB_INTFLAGS,1065
 PORTB_PORTCTRL,1066
 PORTB_PIN0CTRL,1072
 PORTB_PIN1CTRL,1073
 PORTB_PIN2CTRL,1074
 PORTB_PIN3CTRL,1075
 PORTB_PIN4CTRL,1076
 PORTB_PIN5CTRL,1077
 PORTB_PIN6CTRL,1078
 PORTB_PIN7CTRL,1079
 PORTC_DIR,1088
 PORTC_DIRSET,1089
 PORTC_DIRCLR,1090
 PORTC_DIRTGL,1091
 PORTC_OUT,1092
 PORTC_OUTSET,1093
 PORTC_OUTCLR,1094
 PORTC_OUTTGL,1095
 PORTC_IN,1096
 PORTC_INTFLAGS,1097
 PORTC_PORTCTRL,1098
 PORTC_PIN0CTRL,1104
 PORTC_PIN1CTRL,1105
 PORTC_PIN2CTRL,1106
 PORTC_PIN3CTRL,1107
 PORTC_PIN4CTRL,1108
 PORTC_PIN5CTRL,1109
 PORTC_PIN6CTRL,1110
 PORTC_PIN7CTRL,1111
 PORTMUX_EVSYSROUTEA,1504
 PORTMUX_CCLROUTEA,1505
 PORTMUX_USARTROUTEA,1506
 PORTMUX_SPIROUTEA,1507
 PORTMUX_TCAROUTEA,1508
 PORTMUX_TCBROUTEA,1509
 RSTCTRL_RSTFR,64
 RSTCTRL_SWRR,65
 RTC_CTRLA,320
 RTC_STATUS,321
 RTC_INTCTRL,322
 RTC_INTFLAGS,323
 RTC_TEMP,324
 RTC_DBGCTRL,325
 RTC_CALIB,326
 RTC_CLKSEL,327
 RTC_CNT,328
 RTC_CNTL,328
 RTC_CNTH,329
 RTC_PER,330
 RTC_PERL,330
 RTC_PERH,331
; .equ RTC_CMP = 0x014C                    ; Compare a duplicate or resevered register or ALIAS_
; .equ RTC_CMPL = 0x014C                   ; Compare low byte a duplicate or resevered register or ALIAS_
; .equ RTC_CMPH = 0x014D                   ; Compare hi byte a duplicate or resevered register or ALIAS_
 RTC_PITCTRLA,336
 RTC_PITSTATUS,337
 RTC_PITINTCTRL,338
 RTC_PITINTFLAGS,339
 RTC_PITDBGCTRL,341
 SIGROW_DEVICEID0,4352
 SIGROW_DEVICEID1,4353
 SIGROW_DEVICEID2,4354
 SIGROW_SERNUM0,4355
 SIGROW_SERNUM1,4356
 SIGROW_SERNUM2,4357
 SIGROW_SERNUM3,4358
 SIGROW_SERNUM4,4359
 SIGROW_SERNUM5,4360
 SIGROW_SERNUM6,4361
 SIGROW_SERNUM7,4362
 SIGROW_SERNUM8,4363
 SIGROW_SERNUM9,4364
 SIGROW_OSCCAL16M0,4376
 SIGROW_OSCCAL16M1,4377
 SIGROW_OSCCAL20M0,4378
 SIGROW_OSCCAL20M1,4379
 SIGROW_TEMPSENSE0,4384
 SIGROW_TEMPSENSE1,4385
 SLPCTRL_CTRLA,80
 SPI0_CTRLA,2240
 SPI0_CTRLB,2241
 SPI0_INTCTRL,2242
 SPI0_INTFLAGS,2243
 SPI0_DATA,2244
 SYSCFG_REVID,3841
 TCA0_SINGLE_CTRLA,2560
 TCA0_SPLIT_CTRLA,2560
 TCA0_SINGLE_CTRLB,2561
 TCA0_SPLIT_CTRLB,2561
 TCA0_SINGLE_CTRLC,2562
 TCA0_SPLIT_CTRLC,2562
 TCA0_SINGLE_CTRLD,2563
 TCA0_SPLIT_CTRLD,2563
 TCA0_SINGLE_CTRLECLR,2564
 TCA0_SPLIT_CTRLECLR,2564
 TCA0_SINGLE_CTRLESET,2565
 TCA0_SPLIT_CTRLESET,2565
 TCA0_SINGLE_CTRLFCLR,2566
 TCA0_SINGLE_CTRLFSET,2567
 TCA0_SINGLE_EVCTRL,2569
 TCA0_SINGLE_INTCTRL,2570
 TCA0_SPLIT_INTCTRL,2570
 TCA0_SINGLE_INTFLAGS,2571
 TCA0_SPLIT_INTFLAGS,2571
 TCA0_SINGLE_DBGCTRL,2574
 TCA0_SPLIT_DBGCTRL,2574
 TCA0_SINGLE_TEMP,2575
 TCA0_SINGLE_CNT,2592
 TCA0_SINGLE_CNTL,2592
 TCA0_SINGLE_CNTH,2593
 TCA0_SPLIT_LCNT,2592
 TCA0_SPLIT_HCNT,2593
 TCA0_SINGLE_PER,2598
 TCA0_SINGLE_PERL,2598
 TCA0_SINGLE_PERH,2599
 TCA0_SPLIT_LPER,2598
 TCA0_SPLIT_HPER,2599
 TCA0_SINGLE_CMP0,2600
 TCA0_SINGLE_CMP0L,2600
 TCA0_SINGLE_CMP0H,2601
 TCA0_SPLIT_LCMP0,2600
 TCA0_SPLIT_HCMP0,2601
 TCA0_SINGLE_CMP1,2602
 TCA0_SINGLE_CMP1L,2602
 TCA0_SINGLE_CMP1H,2603
 TCA0_SPLIT_LCMP1,2602
 TCA0_SPLIT_HCMP1,2603
 TCA0_SINGLE_CMP2,2604
 TCA0_SINGLE_CMP2L,2604
 TCA0_SINGLE_CMP2H,2605
 TCA0_SPLIT_LCMP2,2604
 TCA0_SPLIT_HCMP2,2605
 TCA0_SINGLE_PERBUF,2614
 TCA0_SINGLE_PERBUFL,2614
 TCA0_SINGLE_PERBUFH,2615
 TCA0_SINGLE_CMP0BUF,2616
 TCA0_SINGLE_CMP0BUFL,2616
 TCA0_SINGLE_CMP0BUFH,2617
 TCA0_SINGLE_CMP1BUF,2618
 TCA0_SINGLE_CMP1BUFL,2618
 TCA0_SINGLE_CMP1BUFH,2619
 TCA0_SINGLE_CMP2BUF,2620
 TCA0_SINGLE_CMP2BUFL,2620
 TCA0_SINGLE_CMP2BUFH,2621
 TCB0_CTRLA,2688
 TCB0_CTRLB,2689
 TCB0_EVCTRL,2692
 TCB0_INTCTRL,2693
 TCB0_INTFLAGS,2694
 TCB0_STATUS,2695
 TCB0_DBGCTRL,2696
 TCB0_TEMP,2697
 TCB0_CNT,2698
 TCB0_CNTL,2698
 TCB0_CNTH,2699
 TCB0_CCMP,2700
 TCB0_CCMPL,2700
 TCB0_CCMPH,2701
 TCB1_CTRLA,2704
 TCB1_CTRLB,2705
 TCB1_EVCTRL,2708
 TCB1_INTCTRL,2709
 TCB1_INTFLAGS,2710
 TCB1_STATUS,2711
 TCB1_DBGCTRL,2712
 TCB1_TEMP,2713
 TCB1_CNT,2714
 TCB1_CNTL,2714
 TCB1_CNTH,2715
 TCB1_CCMP,2716
 TCB1_CCMPL,2716
 TCB1_CCMPH,2717
 TWI0_CTRLA,2208
 TWI0_DBGCTRL,2210
 TWI0_MCTRLA,2211
 TWI0_MCTRLB,2212
 TWI0_MSTATUS,2213
 TWI0_MBAUD,2214
 TWI0_MADDR,2215
 TWI0_MDATA,2216
 TWI0_SCTRLA,2217
 TWI0_SCTRLB,2218
 TWI0_SSTATUS,2219
 TWI0_SADDR,2220
 TWI0_SDATA,2221
 TWI0_SADDRMASK,2222
 USART0_RXDATAL,2048
 USART0_RXDATAH,2049
 USART0_TXDATAL,2050
 USART0_TXDATAH,2051
 USART0_STATUS,2052
 USART0_CTRLA,2053
 USART0_CTRLB,2054
 USART0_CTRLC,2055
 USART0_BAUD,2056
 USART0_BAUDL,2056
 USART0_BAUDH,2057
 USART0_CTRLD,2058
 USART0_DBGCTRL,2059
 USART0_EVCTRL,2060
 USART0_TXPLCTRL,2061
 USART0_RXPLCTRL,2062
 USART1_RXDATAL,2080
 USART1_RXDATAH,2081
 USART1_TXDATAL,2082
 USART1_TXDATAH,2083
 USART1_STATUS,2084
 USART1_CTRLA,2085
 USART1_CTRLB,2086
 USART1_CTRLC,2087
 USART1_BAUD,2088
 USART1_BAUDL,2088
 USART1_BAUDH,2089
 USART1_CTRLD,2090
 USART1_DBGCTRL,2091
 USART1_EVCTRL,2092
 USART1_TXPLCTRL,2093
 USART1_RXPLCTRL,2094
 USERROW_USERROW0,4864
 USERROW_USERROW1,4865
 USERROW_USERROW2,4866
 USERROW_USERROW3,4867
 USERROW_USERROW4,4868
 USERROW_USERROW5,4869
 USERROW_USERROW6,4870
 USERROW_USERROW7,4871
 USERROW_USERROW8,4872
 USERROW_USERROW9,4873
 USERROW_USERROW10,4874
 USERROW_USERROW11,4875
 USERROW_USERROW12,4876
 USERROW_USERROW13,4877
 USERROW_USERROW14,4878
 USERROW_USERROW15,4879
 USERROW_USERROW16,4880
 USERROW_USERROW17,4881
 USERROW_USERROW18,4882
 USERROW_USERROW19,4883
 USERROW_USERROW20,4884
 USERROW_USERROW21,4885
 USERROW_USERROW22,4886
 USERROW_USERROW23,4887
 USERROW_USERROW24,4888
 USERROW_USERROW25,4889
 USERROW_USERROW26,4890
 USERROW_USERROW27,4891
 USERROW_USERROW28,4892
 USERROW_USERROW29,4893
 USERROW_USERROW30,4894
 USERROW_USERROW31,4895
 VPORTA_DIR,0
 VPORTA_OUT,1
 VPORTA_IN,2
 VPORTA_INTFLAGS,3
 VPORTB_DIR,4
 VPORTB_OUT,5
 VPORTB_IN,6
 VPORTB_INTFLAGS,7
 VPORTC_DIR,8
 VPORTC_OUT,9
 VPORTC_IN,10
 VPORTC_INTFLAGS,11
 VREF_CTRLA,160
 VREF_CTRLB,161
 WDT_CTRLA,256
 WDT_STATUS,257

[Bits]
'For details of the bits (relative to a register in terms of registerbits) see the microcontroller datasheet
'The first parameter is the GCBASIC bit name used in user code to expose the specific registerbit
 ' Required for GCBASIC operations
  I,SREG,7
  T,SREG,6
  H,SREG,5
  S,SREG,4
  V,SREG,3
  N,SREG,2
  Z,SREG,1
  C,SREG,0
AC_ENABLE,AC,0			'  Enable bit position
AC_LPMODE,AC,3			'  Low Power Mode bit position
AC_OUTEN,AC,6			'  Output Buffer Enable bit position
AC_RUNSTDBY,AC,7			'  Run in Standby Mode bit position
AC_INVERT,AC,7			'  Invert AC Output bit position
AC_CMP,AC,0			'  Analog Comparator 0 Interrupt Enable bit position
AC_STATE,AC,4			'  Analog Comparator State bit position
ADC_ENABLE,ADC,0			'  ADC Enable bit position
ADC_LOWLAT,ADC,5			'  ADC Low latency mode bit position
ADC_RUNSTDBY,ADC,7			'  Run standby mode bit position
ADC_WINSRC,ADC,3			'  Window Mode Source bit position
ADC_RESRDY,ADC,0			'  Result Ready Interrupt Enable bit position
ADC_SAMPRDY,ADC,1			'  Sample Ready Interrupt Enable bit position
ADC_WCMP,ADC,2			'  Window Comparator Interrupt Enable bit position
ADC_RESOVR,ADC,3			'  Result Overwritten Interrupt Enable bit position
ADC_SAMPOVR,ADC,4			'  Sample Overwritten Interrupt Enable bit position
ADC_TRIGOVR,ADC,5			'  Trigger Overrun Interrupt Enable bit position
ADC_ADCBUSY,ADC,0			'  ADC Busy bit position
ADC_DBGRUN,ADC,0			'  Debug run bit position
ADC_LEFTADJ,ADC,4			'  Left adjust bit position
ADC_FREERUN,ADC,5			'  Free running mode bit position
ADC_DIFF,ADC,7			'  Differential mode bit position
ADC_PGAEN,ADC,0			'  PGA Enable bit position
BOD_SAMPFREQ,BOD,4			'  Sample frequency bit position
BOD_VLMIE,BOD,0			'  voltage level monitor interrrupt enable bit position
BOD_VLMIF,BOD,0			'  Voltage level monitor interrupt flag bit position
BOD_VLMS,BOD,0			'  Voltage level monitor status bit position
CCL_ENABLE,CCL,0			'  Enable bit position
CCL_RUNSTDBY,CCL,6			'  Run in Standby bit position
CCL_OUTEN,CCL,6			'  Output Enable bit position
CCL_EDGEDET,CCL,7			'  Edge Detection Enable bit position
CLKCTRL_CLKOUT,CLKCTRL,7			'  System clock out bit position
CLKCTRL_PEN,CLKCTRL,0			'  Prescaler enable bit position
CLKCTRL_LOCKEN,CLKCTRL,0			'  lock ebable bit position
CLKCTRL_SOSC,CLKCTRL,0			'  System Oscillator changing bit position
CLKCTRL_OSC20MS,CLKCTRL,4			'  20MHz oscillator status bit position
CLKCTRL_OSC32KS,CLKCTRL,5			'  32KHz oscillator status bit position
CLKCTRL_XOSC32KS,CLKCTRL,6			'  32.768 kHz Crystal Oscillator status bit position
CLKCTRL_EXTS,CLKCTRL,7			'  External Clock status bit position
CLKCTRL_RUNSTDBY,CLKCTRL,1			'  Run standby bit position
CLKCTRL_LOCK,CLKCTRL,7			'  Lock bit position
CLKCTRL_ENABLE,CLKCTRL,0			'  Enable bit position
CLKCTRL_SEL,CLKCTRL,2			'  Select bit position
CPU_C,CPU,0			'  Carry Flag bit position
CPU_Z,CPU,1			'  Zero Flag bit position
CPU_N,CPU,2			'  Negative Flag bit position
CPU_V,CPU,3			'  Two's Complement Overflow Flag bit position
CPU_S,CPU,4			'  N Exclusive Or V Flag bit position
CPU_H,CPU,5			'  Half Carry Flag bit position
CPU_T,CPU,6			'  Transfer Bit bit position
CPU_I,CPU,7			'  Global Interrupt Enable Flag bit position
CPUINT_LVL0RR,CPUINT,0			'  Round-robin Scheduling Enable bit position
CPUINT_CVT,CPUINT,5			'  Compact Vector Table bit position
CPUINT_IVSEL,CPUINT,6			'  Interrupt Vector Select bit position
CPUINT_LVL0EX,CPUINT,0			'  Level 0 Interrupt Executing bit position
CPUINT_LVL1EX,CPUINT,1			'  Level 1 Interrupt Executing bit position
CPUINT_NMIEX,CPUINT,7			'  Non-maskable Interrupt Executing bit position
CRCSCAN_ENABLE,CRCSCAN,0			'  Enable CRC scan bit position
CRCSCAN_NMIEN,CRCSCAN,1			'  Enable NMI Trigger bit position
CRCSCAN_RESET,CRCSCAN,7			'  Reset CRC scan bit position
CRCSCAN_BUSY,CRCSCAN,0			'  CRC Busy bit position
CRCSCAN_OK,CRCSCAN,1			'  CRC Ok bit position
FUSE_SAMPFREQ,FUSE,4			'  BOD Sample Frequency bit position
FUSE_OSCLOCK,FUSE,7			'  Oscillator Lock bit position
FUSE_EESAVE,FUSE,0			'  EEPROM Save bit position
FUSE_TOUTDIS,FUSE,4			'  Time-Out Disable bit position
NVMCTRL_APCWP,NVMCTRL,0			'  Application code write protect bit position
NVMCTRL_BOOTLOCK,NVMCTRL,1			'  Boot Lock bit position
NVMCTRL_FBUSY,NVMCTRL,0			'  Flash busy bit position
NVMCTRL_EEBUSY,NVMCTRL,1			'  EEPROM busy bit position
NVMCTRL_WRERROR,NVMCTRL,2			'  Write error bit position
NVMCTRL_EEREADY,NVMCTRL,0			'  EEPROM Ready bit position
PORT_SRL,PORT,0			'  Slew Rate Limit Enable bit position
PORT_PULLUPEN,PORT,3			'  Pullup enable bit position
PORT_INVEN,PORT,7			'  Inverted I/O Enable bit position
PORTMUX_EVOUTA,PORTMUX,0			'  Event Output A bit position
PORTMUX_EVOUTB,PORTMUX,1			'  Event Output B bit position
PORTMUX_EVOUTC,PORTMUX,2			'  Event Output C bit position
PORTMUX_LUT0,PORTMUX,0			'  CCL LUT0 bit position
PORTMUX_LUT1,PORTMUX,1			'  CCL LUT1 bit position
PORTMUX_LUT2,PORTMUX,2			'  CCL LUT2 bit position
PORTMUX_LUT3,PORTMUX,3			'  CCL LUT3 bit position
PORTMUX_TCA00,PORTMUX,0			'  Port Multiplexer TCA0 Output 0 bit position
PORTMUX_TCA01,PORTMUX,1			'  Port Multiplexer TCA0 Output 1 bit position
PORTMUX_TCA02,PORTMUX,2			'  Port Multiplexer TCA0 Output 2 bit position
PORTMUX_TCA03,PORTMUX,3			'  Port Multiplexer TCA0 Output 3 bit position
PORTMUX_TCA04,PORTMUX,4			'  Port Multiplexer TCA0 Output 4 bit position
PORTMUX_TCA05,PORTMUX,5			'  Port Multiplexer TCA0 Output 5 bit position
PORTMUX_TCB0,PORTMUX,0			'  Port Multiplexer TCB0 bit position
PORTMUX_TCB1,PORTMUX,1			'  Port Multiplexer TCB1 bit position
RSTCTRL_PORF,RSTCTRL,0			'  Power on Reset flag bit position
RSTCTRL_BORF,RSTCTRL,1			'  Brown out detector Reset flag bit position
RSTCTRL_EXTRF,RSTCTRL,2			'  External Reset flag bit position
RSTCTRL_WDRF,RSTCTRL,3			'  Watch dog Reset flag bit position
RSTCTRL_SWRF,RSTCTRL,4			'  Software Reset flag bit position
RSTCTRL_UPDIRF,RSTCTRL,5			'  UPDI Reset flag bit position
RSTCTRL_SWRE,RSTCTRL,0			'  Software reset enable bit position
RTC_RTCEN,RTC,0			'  Enable bit position
RTC_CORREN,RTC,2			'  Correction enable bit position
RTC_RUNSTDBY,RTC,7			'  Run In Standby bit position
RTC_CTRLABUSY,RTC,0			'  CTRLA Synchronization Busy Flag bit position
RTC_CNTBUSY,RTC,1			'  Count Synchronization Busy Flag bit position
RTC_PERBUSY,RTC,2			'  Period Synchronization Busy Flag bit position
RTC_CMPBUSY,RTC,3			'  Comparator Synchronization Busy Flag bit position
RTC_OVF,RTC,0			'  Overflow Interrupt enable bit position
RTC_CMP,RTC,1			'  Compare Match Interrupt enable bit position
RTC_DBGRUN,RTC,0			'  Run in debug bit position
RTC_SIGN,RTC,7			'  Error Correction Sign Bit bit position
RTC_PITEN,RTC,0			'  Enable bit position
RTC_CTRLBUSY,RTC,0			'  CTRLA Synchronization Busy Flag bit position
RTC_PI,RTC,0			'  Periodic Interrupt bit position
SLPCTRL_SEN,SLPCTRL,0			'  Sleep enable bit position
SPI_ENABLE,SPI,0			'  Enable Module bit position
SPI_CLK2X,SPI,4			'  Enable Double Speed bit position
SPI_MASTER,SPI,5			'  Host Operation Enable bit position
SPI_DORD,SPI,6			'  Data Order Setting bit position
SPI_SSD,SPI,2			'  SPI Select Disable bit position
SPI_BUFWR,SPI,6			'  Buffer Mode Wait for Receive bit position
SPI_BUFEN,SPI,7			'  Buffer Mode Enable bit position
SPI_IE,SPI,0			'  Interrupt Enable bit position
SPI_SSIE,SPI,4			'  SPI Select Trigger Interrupt Enable bit position
SPI_DREIE,SPI,5			'  Data Register Empty Interrupt Enable bit position
SPI_TXCIE,SPI,6			'  Transfer Complete Interrupt Enable bit position
SPI_RXCIE,SPI,7			'  Receive Complete Interrupt Enable bit position
SPI_BUFOVF,SPI,0			'  Buffer Overflow bit position
SPI_SSIF,SPI,4			'  SPI Select Trigger Interrupt Flag bit position
SPI_DREIF,SPI,5			'  Data Register Empty Interrupt Flag bit position
SPI_TXCIF,SPI,6			'  Transfer Complete Interrupt Flag bit position
SPI_WRCOL,SPI,6			'  Write Collision bit position
SPI_RXCIF,SPI,7			'  Receive Complete Interrupt Flag bit position
SPI_IF,SPI,7			'  Interrupt Flag bit position
TCA_SINGLE_ENABLE,TCA,0			'  Module Enable bit position
TCA_SINGLE_RUNSTDBY,TCA,7			'  Run in Standby bit position
TCA_SINGLE_ALUPD,TCA,3			'  Auto Lock Update bit position
TCA_SINGLE_CMP0EN,TCA,4			'  Compare 0 Enable bit position
TCA_SINGLE_CMP1EN,TCA,5			'  Compare 1 Enable bit position
TCA_SINGLE_CMP2EN,TCA,6			'  Compare 2 Enable bit position
TCA_SINGLE_CMP0OV,TCA,0			'  Compare 0 Waveform Output Value bit position
TCA_SINGLE_CMP1OV,TCA,1			'  Compare 1 Waveform Output Value bit position
TCA_SINGLE_CMP2OV,TCA,2			'  Compare 2 Waveform Output Value bit position
TCA_SINGLE_SPLITM,TCA,0			'  Split Mode Enable bit position
TCA_SINGLE_DIR,TCA,0			'  Direction bit position
TCA_SINGLE_LUPD,TCA,1			'  Lock Update bit position
TCA_SINGLE_PERBV,TCA,0			'  Period Buffer Valid bit position
TCA_SINGLE_CMP0BV,TCA,1			'  Compare 0 Buffer Valid bit position
TCA_SINGLE_CMP1BV,TCA,2			'  Compare 1 Buffer Valid bit position
TCA_SINGLE_CMP2BV,TCA,3			'  Compare 2 Buffer Valid bit position
TCA_SINGLE_CNTAEI,TCA,0			'  Count on Event Input A bit position
TCA_SINGLE_CNTBEI,TCA,4			'  Count on Event Input B bit position
TCA_SINGLE_OVF,TCA,0			'  Overflow Interrupt bit position
TCA_SINGLE_CMP0,TCA,4			'  Compare 0 Interrupt bit position
TCA_SINGLE_CMP1,TCA,5			'  Compare 1 Interrupt bit position
TCA_SINGLE_CMP2,TCA,6			'  Compare 2 Interrupt bit position
TCA_SINGLE_DBGRUN,TCA,0			'  Debug Run bit position
TCA_SPLIT_ENABLE,for CTRLA already defined,0			'  Module Enable bit position
TCA_SPLIT_RUNSTDBY,for CTRLA already defined,7			'  Run in Standby bit position
TCA_SPLIT_LCMP0EN,TCA,0			'  Low Compare 0 Enable bit position
TCA_SPLIT_LCMP1EN,TCA,1			'  Low Compare 1 Enable bit position
TCA_SPLIT_LCMP2EN,TCA,2			'  Low Compare 2 Enable bit position
TCA_SPLIT_HCMP0EN,TCA,4			'  High Compare 0 Enable bit position
TCA_SPLIT_HCMP1EN,TCA,5			'  High Compare 1 Enable bit position
TCA_SPLIT_HCMP2EN,TCA,6			'  High Compare 2 Enable bit position
TCA_SPLIT_LCMP0OV,TCA,0			'  Low Compare 0 Output Value bit position
TCA_SPLIT_LCMP1OV,TCA,1			'  Low Compare 1 Output Value bit position
TCA_SPLIT_LCMP2OV,TCA,2			'  Low Compare 2 Output Value bit position
TCA_SPLIT_HCMP0OV,TCA,4			'  High Compare 0 Output Value bit position
TCA_SPLIT_HCMP1OV,TCA,5			'  High Compare 1 Output Value bit position
TCA_SPLIT_HCMP2OV,TCA,6			'  High Compare 2 Output Value bit position
TCA_SPLIT_SPLITM,TCA,0			'  Split Mode Enable bit position
TCA_SPLIT_LUNF,TCA,0			'  Low Underflow Interrupt Enable bit position
TCA_SPLIT_HUNF,TCA,1			'  High Underflow Interrupt Enable bit position
TCA_SPLIT_LCMP0,TCA,4			'  Low Compare 0 Interrupt Enable bit position
TCA_SPLIT_LCMP1,TCA,5			'  Low Compare 1 Interrupt Enable bit position
TCA_SPLIT_LCMP2,TCA,6			'  Low Compare 2 Interrupt Enable bit position
TCA_SPLIT_DBGRUN,TCA,0			'  Debug Run bit position
TCB_ENABLE,TCB,0			'  Enable bit position
TCB_SYNCUPD,TCB,4			'  Synchronize Update bit position
TCB_CASCADE,TCB,5			'  Cascade two timers bit position
TCB_RUNSTDBY,TCB,6			'  Run Standby bit position
TCB_CCMPEN,TCB,4			'  Pin Output Enable bit position
TCB_CCMPINIT,TCB,5			'  Pin Initial State bit position
TCB_ASYNC,TCB,6			'  Asynchronous Enable bit position
TCB_CAPTEI,TCB,0			'  Event Input Enable bit position
TCB_EDGE,TCB,4			'  Event Edge bit position
TCB_FILTER,TCB,6			'  Input Capture Noise Cancellation Filter bit position
TCB_CAPT,TCB,0			'  Capture or Timeout bit position
TCB_OVF,TCB,1			'  Overflow bit position
TCB_RUN,TCB,0			'  Run bit position
TCB_DBGRUN,TCB,0			'  Debug Run bit position
TWI_FMPEN,TWI,1			'  Fast-mode Plus Enable bit position
TWI_SDASETUP,TWI,4			'  SDA Setup Time bit position
TWI_DBGRUN,TWI,0			'  Debug Run bit position
TWI_ENABLE,TWI,0			'  Enable TWI Host bit position
TWI_SMEN,TWI,1			'  Smart Mode Enable bit position
TWI_QCEN,TWI,4			'  Quick Command Enable bit position
TWI_WIEN,TWI,6			'  Write Interrupt Enable bit position
TWI_RIEN,TWI,7			'  Read Interrupt Enable bit position
TWI_ACKACT,TWI,2			'  Acknowledge Action bit position
TWI_FLUSH,TWI,3			'  Flush bit position
TWI_BUSERR,TWI,2			'  Bus Error bit position
TWI_ARBLOST,TWI,3			'  Arbitration Lost bit position
TWI_RXACK,TWI,4			'  Received Acknowledge bit position
TWI_CLKHOLD,TWI,5			'  Clock Hold bit position
TWI_WIF,TWI,6			'  Write Interrupt Flag bit position
TWI_RIF,TWI,7			'  Read Interrupt Flag bit position
TWI_PMEN,TWI,2			'  Permissive Mode Enable bit position
TWI_PIEN,TWI,5			'  Stop Interrupt Enable bit position
TWI_APIEN,TWI,6			'  Address/Stop Interrupt Enable bit position
TWI_DIEN,TWI,7			'  Data Interrupt Enable bit position
TWI_AP,TWI,0			'  Client Address or Stop bit position
TWI_DIR,TWI,1			'  Read/Write Direction bit position
TWI_COLL,TWI,3			'  Collision bit position
TWI_APIF,TWI,6			'  Address/Stop Interrupt Flag bit position
TWI_DIF,TWI,7			'  Data Interrupt Flag bit position
TWI_ADDREN,TWI,0			'  Address Enable bit position
USART_DATA8,USART,0			'  Receiver Data Register bit position
USART_PERR,USART,1			'  Parity Error bit position
USART_FERR,USART,2			'  Frame Error bit position
USART_BUFOVF,USART,6			'  Buffer Overflow bit position
USART_RXCIF,USART,7			'  Receive Complete Interrupt Flag bit position
USART_WFB,USART,0			'  Wait For Break bit position
USART_BDF,USART,1			'  Break Detected Flag bit position
USART_ISFIF,USART,3			'  Inconsistent Sync Field Interrupt Flag bit position
USART_RXSIF,USART,4			'  Receive Start Interrupt bit position
USART_DREIF,USART,5			'  Data Register Empty Flag bit position
USART_TXCIF,USART,6			'  Transmit Interrupt Flag bit position
USART_RS485,USART,0			'  RS485 Mode internal transmitter bit position
USART_ABEIE,USART,2			'  Auto-baud Error Interrupt Enable bit position
USART_LBME,USART,3			'  Loop-back Mode Enable bit position
USART_RXSIE,USART,4			'  Receiver Start Frame Interrupt Enable bit position
USART_DREIE,USART,5			'  Data Register Empty Interrupt Enable bit position
USART_TXCIE,USART,6			'  Transmit Complete Interrupt Enable bit position
USART_RXCIE,USART,7			'  Receive Complete Interrupt Enable bit position
USART_MPCM,USART,0			'  Multi-processor Communication Mode bit position
USART_ODME,USART,3			'  Open Drain Mode Enable bit position
USART_SFDEN,USART,4			'  Start Frame Detection Enable bit position
USART_TXEN,USART,6			'  Transmitter Enable bit position
USART_RXEN,USART,7			'  Reciever enable bit position
USART_UCPHA,USART,1			'  SPI Host Mode, Clock Phase bit position
USART_UDORD,USART,2			'  SPI Host Mode, Data Order bit position
USART_SBMODE,USART,3			'  Stop Bit Mode bit position
USART_DBGRUN,USART,0			'  Debug Run bit position
USART_IREI,USART,0			'  IrDA Event Input Enable bit position
VREF_AC0REFEN,VREF,0			'  AC0 DACREF reference enable bit position
VREF_ADC0REFEN,VREF,1			'  ADC0 reference enable bit position
VREF_NVMREFEN,VREF,2			'  NVM reference enable bit position
WDT_SYNCBUSY,WDT,0			'  Syncronization busy bit position
WDT_LOCK,WDT,7			'  Lock enable bit position

[FreeRAM]
'This is the extent of the RAM.  Inclusive of start and end address
3400:4000

[ConfigOps]
'For details of the config options see the microcontroller datasheet
'The first parameter is the configuration field that can be used to expose specific configuration bits
'The other parameters are the configuration field options that can be set
NoConfig-PRG

[Config]
'For details of the config addresses see the microcontroller datasheet
NoConfig-PRG
