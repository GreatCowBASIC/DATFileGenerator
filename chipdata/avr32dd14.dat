;        .DAT sections
;==========================================================================
;
;  Built by GCBASIC converter
;  XC8 processor include for the chip shown below
;
; Microchip IDE version 6.05
; C:\Users\admin\.mchp_packs\index.idx
; C:\Users\admin\.mchp_packs\Microchip\AVR-Dx_DFP\2.6.303\avrasm\inc\AVR32DD14def.inc
; avr chipdata.csv
; C:\Users\admin\.mchp_packs\Microchip\AVR-Dx_DFP\2.6.303\edc\ATAVR32DD14.PIC
; 
;
; Registers not processed: RTC_CMP,SREG,CPU_SPL, CPU_SPH 
; Bits not processed: CPU_RAMPZ
;==========================================================================
;==========================================================================
;
;       Register Definitions
;
;==========================================================================

;----- Register Files -----------------------------------------------------

[ChipData]
';All items in the ChipData section are available to user programs as constants
';The constants have the prefix of Chip: See the details below

'This constant is exposed as ChipWORDS
Prog=16384

'This constant is exposed as ChipEEPROM
EEPROM=256

'This constant is exposed as ChipRAM
RAM=4096

'This constant is exposed as ChipIO - sourced from `avr chipdata.csv`
I/O=11

'This constant is exposed as ChipADC - sourced from `avr chipdata.csv`
ADC=7
ADCPPORTMAP=AVRDxADC7Type2Lookup

'This constant is exposed as ChipMhz
This constant is exposed as ChipMaxMhz  - sourced from `avr chipdata.csv`
MaxMHz=24
'This constant is exposed with only the first parameter (if more than one)
IntOsc=24, 20, 16, 12, 8, 4, 3, 2, 1

'This constant is exposed as ChipPins - sourced from `avr chipdata.csv`
Pins=14

'This constant is exposed as ChipUSART - sourced from `avr chipdata.csv`
USART=2

'These USART constants are exposed with the prefix of CHIP - sourced from `avr chipdata.csv`
USART0TXDefault=PORTA.0
USART1TXDefault=PORTC.0
USART2TXDefault=PORTF.0
USART3TXDefault=PORTB.0
USART3TXDefault=PORTE.0
USART0RXDefault=PORTA.1
USART1RXDefault=PORTC.1
USART2RXDefault=PORTF.1
USART3RXDefault=PORTB.1
USART4RXDefault=PORTE.1

'This constant is exposed as ChipFamily - sourced from `avr chipdata.csv`
Family=140

'This constant is exposed as ChipConfWords
ConfigWords=0

'This constant is exposed as ChipGPR
GPR=32

'This constant is exposed as ChipMaxAddress. This value is the maximum address of the internal SRAM.  SRAM is used for data storage and stack.
MaxAddress=32768

'This constant is exposed as ChipHardwareMult
HardwareMult=y

'This constant is exposed as ChipAVRFamily - sourced from `avr chipdata.csv`
AVRFamily=AVRDD

'This constant is exposed as ChipAVRGCC - sourced from `avr chipdata.csv`
AVRGCC=avrxmega3

'This constant is exposed as ChipAVRDX - sourced from `avr chipdata.csv`
AVRDX=1

'For details of microcontroller specifications see the microcontroller datasheet
_DATAMEM_START = 0x0000
_DATAMEM_SIZE = 0x10000
_DATAMEM_END = (0x0000 + 0x10000 - 1)
_IO_START = 0x0000
_IO_SIZE = 0x103F
_IO_END = (0x0000 + 0x103F - 1)
_LOCKBITS_START = 0x1040
_LOCKBITS_SIZE = 0x0004
_LOCKBITS_END = (0x1040 + 0x0004 - 1)
_LOCKBITS_PAGE_SIZE = 0x01
_FUSES_START = 0x1050
_FUSES_SIZE = 0x0010
_FUSES_END = (0x1050 + 0x0010 - 1)
_FUSES_PAGE_SIZE = 0x01
_USER_SIGNATURES_START = 0x1080
_USER_SIGNATURES_SIZE = 0x0020
_USER_SIGNATURES_END = (0x1080 + 0x0020 - 1)
_USER_SIGNATURES_PAGE_SIZE = 0x20
_SIGNATURES_START = 0x1100
_SIGNATURES_SIZE = 0x0003
_SIGNATURES_END = (0x1100 + 0x0003 - 1)
_SIGNATURES_PAGE_SIZE = 0x80
_PROD_SIGNATURES_START = 0x1103
_PROD_SIGNATURES_SIZE = 0x007D
_PROD_SIGNATURES_END = (0x1103 + 0x007D - 1)
_PROD_SIGNATURES_PAGE_SIZE = 0x80
_EEPROM_START = 0x1400
_EEPROM_SIZE = 0x0100
_EEPROM_END = (0x1400 + 0x0100 - 1)
_EEPROM_PAGE_SIZE = 0x01
_INTERNAL_SRAM_START = 0x7000
_INTERNAL_SRAM_SIZE = 0x1000
_INTERNAL_SRAM_END = (0x7000 + 0x1000 - 1)
_MAPPED_PROGMEM_START = 0x8000
_MAPPED_PROGMEM_SIZE = 0x8000
_MAPPED_PROGMEM_END = (0x8000 + 0x8000 - 1)
_MAPPED_PROGMEM_PAGE_SIZE = 0x200
_PROGMEM_START = 0x0000
_PROGMEM_SIZE = 0x8000
_PROGMEM_END = (0x0000 + 0x8000 - 1)
_PROGMEM_PAGE_SIZE = 0x200

[Pointers]
'This section are the registers used by compilers
XL:26
XH:27
YL:28
YH:29
ZL:30
ZH:31

[Interrupts]
'For specific details of the interrupts see the microcontroller datasheet
'The first parameter is the GCBASIC identifier used in user code to expose the specific interrupt
'
' Specific to AVRDX chips - an explaination - the entries
' GCBASIC friendly name:Source Interrupt Name,vector,register.bit to enable the interrupt,register.bit or !register.bit to clear the interrupt
'   name     interrupt   #    enable reg.bit(s)                  clear reg.bit(s)
' NMIfromCRC:CRCSCAN_NMI,2,CRCSCAN_CTRLA.CRCSCAN_NMIEN_bp,!CRCSCAN_CTRLA.CRCSCAN_RESET_bp
'
' The enable reg.bit(s) can be a single bit or bits will be used to set the register
' The clear reg.bit(s) can be a single bit or bits will be used to set the register
' ! (eqautes to NOT ) inverts the bit
'
; NMI interrupt vectors
		NMI:NMI,2,,
; BOD interrupt vectors
	BOD_VLM:BOD_VLM,4,BOD_INTCTRL.BOD_VLMIE_bp,!BOD_INTFLAGS.BOD_VLMIF_bp
; CLKCTRL interrupt vectors
		CLKCTRL_CFD:CLKCTRL_CFD,6,,
; MVIO interrupt vectors
		MVIO_MVIO:MVIO_MVIO,8,,
; RTC interrupt vectors
	RTCOverflow:RTC_CNT,10,RTC_INTCTRL.RTC_OVF_bp,RTC_INTFLAGS.RTC_OVF_bp
	PITOverflow:RTC_PIT,12,RTC_PITINTCTRL.RTC_PI_bp,RTC_PITINTFLAGS.RTC_PI_bp
; CCL interrupt vectors
	CCL_CCL:CCL_CCL,14,CCL_INTCTRL0.CCL_INTMODE0_gp,!CCL_INTFLAGS.CCL_INT_gp
; PORTA interrupt vectors
	PortAChange:PORTA_PORT,16, PORTA_PORTCTRL.PORT_INT_gm,PORTA_INTFLAGS.PORT_INT_gm
; TCA0 interrupt vectors
	Timer0Overflow:TCA0_LUNF,18,TCA0_SINGLE_INTCTRL.TCA_SINGLE_OVF_bp,!TCA0_SINGLE_INTFLAGS.TCA_SINGLE_OVF_bp
	Timer0Underflow:TCA0_HUNF,20,TCA_SPLIT_HUNF_bp,!TCA0_SPLIT_INTFLAGS.TCA_SPLIT_HUNF_bp 
	Timer0Match0:TCA0_CMP0,22,TCA0_SINGLE_INTCTRL.TCA_SINGLE_CMP0_bp,TCA0_SINGLE_INTFLAGS.TCA_SINGLE_CMP0_bp
	Timer0Match1:TCA0_CMP1,24,TCA0_SINGLE_INTCTRL.TCA_SINGLE_CMP1_bp,TCA0_SINGLE_INTFLAGS.TCA_SINGLE_CMP1_bp
	Timer0Match2:TCA0_CMP2,26,TCA0_SINGLE_INTCTRL.TCA_SINGLE_CMP2_bp,TCA0_SINGLE_INTFLAGS.TCA_SINGLE_CMP0_bp
; TCB0 interrupt vectors
	Timer0Capture:TCB0_INT,28,TCB0_INTCTRL.TCB_CAPT_bp,TCB0_INTFLAGS.TCB_CAPT_bp
; TCB1 interrupt vectors
	Timer1Capture:TCB1_INT,30,TCB1_INTCTRL.TCB_CAPT_bp,TCB1_INTFLAGS.TCB_CAPT_bp
; TCD0 interrupt vectors
		TCD0_OVF:TCD0_OVF,32,,
		TCD0_TRIG:TCD0_TRIG,34,,
; TWI0 interrupt vectors
	TWISlaveReady:TWI0_TWIS,36,TWI0_SCTRLA.TWI_DIEN_bp ,TWI0_SSTATUS.TWI_DIF_bp
	TWIMasterReady:TWI0_TWIM,38,TWI0_MCTRLA.TWI_RIEN_bp,TWI0_MSTATUS.TWI_RIF_bp
; SPI0 interrupt vectors
	SPIReady:SPI0_INT,40,SPI0_INTCTRL.SPI_IE_bp,SPI0_INTFLAGS.SPI_IF_bp
; USART0 interrupt vectors
	Usart0RXReady:USART0_RXC,42, USART0_CTRLA.USART_RXCIE_bp, USART0_STATUS.USART_RXCIF_bp
	UsartTX0Ready:USART0_DRE,44,USART0_CTRLA.USART_DREIE_bp,USART0_STATUS.USART_DREIF_bp
	UsartTX0Sent:USART0_TXC,46,USART0_CTRLA.USART_TXCIE_bp,USART0_STATUS.USART_TXCIF_bp
; PORTD interrupt vectors
	PORTDChange:PORTD_PORT,48,PORTD_PORTCTRL.PORT_INT_gm,PORTD_INTFLAGS.PORT_INT_gm
; AC0 interrupt vectors
	AC0Compare:AC0_AC,50,AC0_INTCTRL.AC_CMP_bp,AC0_STATUS.AC_CMP_bp 
; ADC0 interrupt vectors
		ADC0_RESRDY:ADC0_RESRDY,52,,
	ADC0_WindowCompare:ADC0_WCMP,54,ADC0_INTCTRL.ADC_WCMP_bp,ADC0_INTFLAGS.ADC_WCMP_bp
; ZCD3 interrupt vectors
		ZCD3_ZCD:ZCD3_ZCD,56,,
; PORTC interrupt vectors
	PORTCChange:PORTC_PORT,58,PORTC_PORTCTRL.PORT_INT_gm,PORTC_INTFLAGS.PORT_INT_gm
; TCB2 interrupt vectors
	Timer2Capture:TCB2_INT,60,TCB2_INTCTRL.TCB_CAPT_bp,TCB2_INTFLAGS.TCB_CAPT_bp
; USART1 interrupt vectors
	Usart1RXReady:USART1_RXC,62,USART1_CTRLA.USART_RXCIE_bp,USART1_STATUS.USART_RXCIF_bp
	UsartTX1Ready:USART1_DRE,64,USART1_CTRLA.USART_DREIE_bp,USART1_STATUS.USART_DREIF_bp
	UsartTX1Sent:USART1_TXC,66,USART1_CTRLA.USART_TXCIE_bp,USART1_STATUS.USART_TXCIF_bp
; PORTF interrupt vectors
	PORTFChange:PORTF_PORT,68,PORTF_PORTCTRL.PORT_INT_gm,PORTF_INTFLAGS.PORT_INT_gm
; NVMCTRL interrupt vectors
	;EEREADY Interrupt Flag.  This flag is set continuously as long as the EEPROM is not busy. This flag is cleared by writing a '1' to it.
	NVMCTRLReady:NVMCTRL_EE,70,NVMCTRL_INTCTRL.NVMCTRL_EEREADY_bp ,NVMCTRL_INTFLAGS.NVMCTRL_EEREADY_bp

[AVRAlias]
  'This section is for the AVRDX support
  'The aliasing is megaAVR register = value = AVRDX register
  ' example:          ALIAS_PORTA_DIR = 0 = DDRA
  '
 'Format is Strict: 
  ' There must be two entries per alias, the order is not importand, the relatiionship as shown above is critical.
  ' The value is NOT a register address value. The value MUST be unique
  ' The assignment must be an equal sign `=`
   '
 'How does this all work?
  ' The compiler will look up a megaAVR register ( ignoring any register.bits), and, using the returned number, lookup the AVRDX alias.
  ' DDRA = 0, lookup the AVRDX alias of 0, returns ALIAS_PORTA_DIR
  ' the compiler strips off the `ALIAS_`PORTA_DIR prefix as the register to be used.
  '
 'A deeper dive.
  ' The compiler treats this list of AVRAlias(es) just like the [register] section of this file.
  ' The compiler loads these AVRAlias(es) but with the attribute of .ALIAS set (true).
  ' This means, using the example above, that DDRA is not a real register and it is has the .ALIAS attribute set. 
  ' So, the compiler knows that DDRA for this specific chip and all AVRDX chips that DDRA is actually to be transformed to an AVRDX set of instructiions.

'PortA
ALIAS_PORTA_DIR=0                                      ; 0000             
DDRA=0                                          ; 0000 alias
ALIAS_PORTA_OUT=1                                      ; 0001             
PORTA=1                                         ; 0001 alias         
ALIAS_PORTA_IN=2                                       ; 0002   
PINA=2                                          ; 0002 alias

'PortC
ALIAS_PORTC_DIR=8                                      ; 0008          
DDRC=8                                          ; 0008 alias
ALIAS_PORTC_OUT=9                                      ; 0009
PORTC=9                                         ; 0009 alias
ALIAS_PORTC_IN=10                                      ; 000A
PINC=10                                         ; 000A alias

'PortD
ALIAS_PORTD_DIR=11
DDRD=11
ALIAS_PORTD_OUT=12
PORTD=12
ALIAS_PORTD_IN=13
PIND=13

'PortF
ALIAS_PORTF_DIR=17
DDRF=17
ALIAS_PORTF_OUT=18
PORTF=18
ALIAS_PORTF_IN=19
PINF=19

'Additional Aliases are required
ALIAS_CPU_SPL=61    
CPU_SPL=61    
ALIAS_CPU_SPH=62                                                                                     
CPU_SPH=62 
'Additional lock register alias
ALIAS_CPU_CCP=52                                  ; 0034
CPU_CCP=52                                        ; 0034
'Required register
SREG=63                                           ; 003F alias
ALIAS_SREG=63

[AVRMASKS]
'For details of the see the microcontroller datasheet
  
  
  ;*************************************************************************
  ;** AC - Analog Comparator
  ;*************************************************************************
  
  ; AC_CTRLA masks
  AC_ENABLE_bm = 0x01                 ; Enable bit mask
  AC_ENABLE_bp = 0                    ; Enable bit position
  AC_HYSMODE_gm = 0x06                ; Hysteresis Mode group mask
  AC_HYSMODE_gp = 1                   ; Hysteresis Mode group position
  AC_HYSMODE_0_bm = (1<<1)            ; Hysteresis Mode bit 0 mask
  AC_HYSMODE_0_bp = 1                 ; Hysteresis Mode bit 0 position
  AC_HYSMODE_1_bm = (1<<2)            ; Hysteresis Mode bit 1 mask
  AC_HYSMODE_1_bp = 2                 ; Hysteresis Mode bit 1 position
  AC_POWER_gm = 0x18                  ; Power profile group mask
  AC_POWER_gp = 3                     ; Power profile group position
  AC_POWER_0_bm = (1<<3)              ; Power profile bit 0 mask
  AC_POWER_0_bp = 3                   ; Power profile bit 0 position
  AC_POWER_1_bm = (1<<4)              ; Power profile bit 1 mask
  AC_POWER_1_bp = 4                   ; Power profile bit 1 position
  AC_OUTEN_bm = 0x40                  ; Output Pad Enable bit mask
  AC_OUTEN_bp = 6                     ; Output Pad Enable bit position
  AC_RUNSTDBY_bm = 0x80               ; Run in Standby Mode bit mask
  AC_RUNSTDBY_bp = 7                  ; Run in Standby Mode bit position
  
  ; AC_MUXCTRL masks
  AC_MUXNEG_gm = 0x07                 ; Negative Input MUX Selection group mask
  AC_MUXNEG_gp = 0                    ; Negative Input MUX Selection group position
  AC_MUXNEG_0_bm = (1<<0)             ; Negative Input MUX Selection bit 0 mask
  AC_MUXNEG_0_bp = 0                  ; Negative Input MUX Selection bit 0 position
  AC_MUXNEG_1_bm = (1<<1)             ; Negative Input MUX Selection bit 1 mask
  AC_MUXNEG_1_bp = 1                  ; Negative Input MUX Selection bit 1 position
  AC_MUXNEG_2_bm = (1<<2)             ; Negative Input MUX Selection bit 2 mask
  AC_MUXNEG_2_bp = 2                  ; Negative Input MUX Selection bit 2 position
  AC_MUXPOS_gm = 0x38                 ; Positive Input MUX Selection group mask
  AC_MUXPOS_gp = 3                    ; Positive Input MUX Selection group position
  AC_MUXPOS_0_bm = (1<<3)             ; Positive Input MUX Selection bit 0 mask
  AC_MUXPOS_0_bp = 3                  ; Positive Input MUX Selection bit 0 position
  AC_MUXPOS_1_bm = (1<<4)             ; Positive Input MUX Selection bit 1 mask
  AC_MUXPOS_1_bp = 4                  ; Positive Input MUX Selection bit 1 position
  AC_MUXPOS_2_bm = (1<<5)             ; Positive Input MUX Selection bit 2 mask
  AC_MUXPOS_2_bp = 5                  ; Positive Input MUX Selection bit 2 position
  AC_INITVAL_bm = 0x40                ; AC Output Initial Value bit mask
  AC_INITVAL_bp = 6                   ; AC Output Initial Value bit position
  AC_INVERT_bm = 0x80                 ; Invert AC Output bit mask
  AC_INVERT_bp = 7                    ; Invert AC Output bit position
  
  ; AC_DACREF masks
  AC_DACREF_gm = 0xFF                 ; DACREF group mask
  AC_DACREF_gp = 0                    ; DACREF group position
  AC_DACREF_0_bm = (1<<0)             ; DACREF bit 0 mask
  AC_DACREF_0_bp = 0                  ; DACREF bit 0 position
  AC_DACREF_1_bm = (1<<1)             ; DACREF bit 1 mask
  AC_DACREF_1_bp = 1                  ; DACREF bit 1 position
  AC_DACREF_2_bm = (1<<2)             ; DACREF bit 2 mask
  AC_DACREF_2_bp = 2                  ; DACREF bit 2 position
  AC_DACREF_3_bm = (1<<3)             ; DACREF bit 3 mask
  AC_DACREF_3_bp = 3                  ; DACREF bit 3 position
  AC_DACREF_4_bm = (1<<4)             ; DACREF bit 4 mask
  AC_DACREF_4_bp = 4                  ; DACREF bit 4 position
  AC_DACREF_5_bm = (1<<5)             ; DACREF bit 5 mask
  AC_DACREF_5_bp = 5                  ; DACREF bit 5 position
  AC_DACREF_6_bm = (1<<6)             ; DACREF bit 6 mask
  AC_DACREF_6_bp = 6                  ; DACREF bit 6 position
  AC_DACREF_7_bm = (1<<7)             ; DACREF bit 7 mask
  AC_DACREF_7_bp = 7                  ; DACREF bit 7 position
  
  ; AC_INTCTRL masks
  AC_CMP_bm = 0x01                    ; Interrupt Enable bit mask
  AC_CMP_bp = 0                       ; Interrupt Enable bit position
  AC_INTMODE_gm = 0x30                ; Interrupt Mode group mask
  AC_INTMODE_gp = 4                   ; Interrupt Mode group position
  AC_INTMODE_0_bm = (1<<4)            ; Interrupt Mode bit 0 mask
  AC_INTMODE_0_bp = 4                 ; Interrupt Mode bit 0 position
  AC_INTMODE_1_bm = (1<<5)            ; Interrupt Mode bit 1 mask
  AC_INTMODE_1_bp = 5                 ; Interrupt Mode bit 1 position
  
  ; AC_STATUS masks
  AC_CMPIF_bm = 0x01                  ; Analog Comparator Interrupt Flag bit mask
  AC_CMPIF_bp = 0                     ; Analog Comparator Interrupt Flag bit position
  AC_CMPSTATE_bm = 0x10               ; Analog Comparator State bit mask
  AC_CMPSTATE_bp = 4                  ; Analog Comparator State bit position
  
  ; Hysteresis Mode select
  AC_HYSMODE_NONE_gc = (0x00<<1)      ; No hysteresis
  AC_HYSMODE_SMALL_gc = (0x01<<1)     ; Small hysteresis
  AC_HYSMODE_MEDIUM_gc = (0x02<<1)    ; Medium hysteresis
  AC_HYSMODE_LARGE_gc = (0x03<<1)     ; Large hysteresis
  
  ; Power profile select
  AC_POWER_PROFILE0_gc = (0x00<<3)    ; Power profile 0, Shortest response time, highest consumption
  AC_POWER_PROFILE1_gc = (0x01<<3)    ; Power profile 1
  AC_POWER_PROFILE2_gc = (0x02<<3)    ; Power profile 2
  AC_POWER_PROFILE3_gc = (0x03<<3)    ; Power profile 3
  
  ; Interrupt Mode select
  AC_NORMAL_INTMODE_BOTHEDGE_gc = (0x00<<4) ; Positive and negative inputs crosses
  AC_NORMAL_INTMODE_NEGEDGE_gc = (0x02<<4) ; Positive input goes below negative input
  AC_NORMAL_INTMODE_POSEDGE_gc = (0x03<<4) ; Positive input goes above negative input
  
  ; AC Output Initial Value select
  AC_INITVAL_LOW_gc = (0x00<<6)       ; Output initialized to 0
  AC_INITVAL_HIGH_gc = (0x01<<6)      ; Output initialized to 1
  
  ; Negative Input MUX Selection
  AC_MUXNEG_AINN0_gc = (0x00<<0)      ; Negative Pin 0
  AC_MUXNEG_AINN2_gc = (0x02<<0)      ; Negative Pin 2
  AC_MUXNEG_AINN3_gc = (0x03<<0)      ; Negative Pin 3
  AC_MUXNEG_DACREF_gc = (0x04<<0)     ; DAC Reference
  
  ; Positive Input MUX Selection
  AC_MUXPOS_AINP0_gc = (0x00<<3)      ; Positive Pin 0
  AC_MUXPOS_AINP3_gc = (0x03<<3)      ; Positive Pin 3
  AC_MUXPOS_AINP4_gc = (0x04<<3)      ; Positive Pin 4
  
  
  ;*************************************************************************
  ;** ADC - Analog to Digital Converter
  ;*************************************************************************
  
  ; ADC_CTRLA masks
  ADC_ENABLE_bm = 0x01                ; ADC Enable bit mask
  ADC_ENABLE_bp = 0                   ; ADC Enable bit position
  ADC_FREERUN_bm = 0x02               ; Free running mode bit mask
  ADC_FREERUN_bp = 1                  ; Free running mode bit position
  ADC_RESSEL_gm = 0x0C                ; Resolution selection group mask
  ADC_RESSEL_gp = 2                   ; Resolution selection group position
  ADC_RESSEL_0_bm = (1<<2)            ; Resolution selection bit 0 mask
  ADC_RESSEL_0_bp = 2                 ; Resolution selection bit 0 position
  ADC_RESSEL_1_bm = (1<<3)            ; Resolution selection bit 1 mask
  ADC_RESSEL_1_bp = 3                 ; Resolution selection bit 1 position
  ADC_LEFTADJ_bm = 0x10               ; Left adjust result bit mask
  ADC_LEFTADJ_bp = 4                  ; Left adjust result bit position
  ADC_CONVMODE_bm = 0x20              ; Conversion mode bit mask
  ADC_CONVMODE_bp = 5                 ; Conversion mode bit position
  ADC_RUNSTBY_bm = 0x80               ; Run standby mode bit mask
  ADC_RUNSTBY_bp = 7                  ; Run standby mode bit position
  
  ; ADC_CTRLB masks
  ADC_SAMPNUM_gm = 0x07               ; Accumulation Samples group mask
  ADC_SAMPNUM_gp = 0                  ; Accumulation Samples group position
  ADC_SAMPNUM_0_bm = (1<<0)           ; Accumulation Samples bit 0 mask
  ADC_SAMPNUM_0_bp = 0                ; Accumulation Samples bit 0 position
  ADC_SAMPNUM_1_bm = (1<<1)           ; Accumulation Samples bit 1 mask
  ADC_SAMPNUM_1_bp = 1                ; Accumulation Samples bit 1 position
  ADC_SAMPNUM_2_bm = (1<<2)           ; Accumulation Samples bit 2 mask
  ADC_SAMPNUM_2_bp = 2                ; Accumulation Samples bit 2 position
  
  ; ADC_CTRLC masks
  ADC_PRESC_gm = 0x0F                 ; Clock Pre-scaler group mask
  ADC_PRESC_gp = 0                    ; Clock Pre-scaler group position
  ADC_PRESC_0_bm = (1<<0)             ; Clock Pre-scaler bit 0 mask
  ADC_PRESC_0_bp = 0                  ; Clock Pre-scaler bit 0 position
  ADC_PRESC_1_bm = (1<<1)             ; Clock Pre-scaler bit 1 mask
  ADC_PRESC_1_bp = 1                  ; Clock Pre-scaler bit 1 position
  ADC_PRESC_2_bm = (1<<2)             ; Clock Pre-scaler bit 2 mask
  ADC_PRESC_2_bp = 2                  ; Clock Pre-scaler bit 2 position
  ADC_PRESC_3_bm = (1<<3)             ; Clock Pre-scaler bit 3 mask
  ADC_PRESC_3_bp = 3                  ; Clock Pre-scaler bit 3 position
  
  ; ADC_CTRLD masks
  ADC_SAMPDLY_gm = 0x0F               ; Sampling Delay Selection group mask
  ADC_SAMPDLY_gp = 0                  ; Sampling Delay Selection group position
  ADC_SAMPDLY_0_bm = (1<<0)           ; Sampling Delay Selection bit 0 mask
  ADC_SAMPDLY_0_bp = 0                ; Sampling Delay Selection bit 0 position
  ADC_SAMPDLY_1_bm = (1<<1)           ; Sampling Delay Selection bit 1 mask
  ADC_SAMPDLY_1_bp = 1                ; Sampling Delay Selection bit 1 position
  ADC_SAMPDLY_2_bm = (1<<2)           ; Sampling Delay Selection bit 2 mask
  ADC_SAMPDLY_2_bp = 2                ; Sampling Delay Selection bit 2 position
  ADC_SAMPDLY_3_bm = (1<<3)           ; Sampling Delay Selection bit 3 mask
  ADC_SAMPDLY_3_bp = 3                ; Sampling Delay Selection bit 3 position
  ADC_INITDLY_gm = 0xE0               ; Initial Delay Selection group mask
  ADC_INITDLY_gp = 5                  ; Initial Delay Selection group position
  ADC_INITDLY_0_bm = (1<<5)           ; Initial Delay Selection bit 0 mask
  ADC_INITDLY_0_bp = 5                ; Initial Delay Selection bit 0 position
  ADC_INITDLY_1_bm = (1<<6)           ; Initial Delay Selection bit 1 mask
  ADC_INITDLY_1_bp = 6                ; Initial Delay Selection bit 1 position
  ADC_INITDLY_2_bm = (1<<7)           ; Initial Delay Selection bit 2 mask
  ADC_INITDLY_2_bp = 7                ; Initial Delay Selection bit 2 position
  
  ; ADC_CTRLE masks
  ADC_WINCM_gm = 0x07                 ; Window Comparator Mode group mask
  ADC_WINCM_gp = 0                    ; Window Comparator Mode group position
  ADC_WINCM_0_bm = (1<<0)             ; Window Comparator Mode bit 0 mask
  ADC_WINCM_0_bp = 0                  ; Window Comparator Mode bit 0 position
  ADC_WINCM_1_bm = (1<<1)             ; Window Comparator Mode bit 1 mask
  ADC_WINCM_1_bp = 1                  ; Window Comparator Mode bit 1 position
  ADC_WINCM_2_bm = (1<<2)             ; Window Comparator Mode bit 2 mask
  ADC_WINCM_2_bp = 2                  ; Window Comparator Mode bit 2 position
  
  ; ADC_SAMPCTRL masks
  ADC_SAMPLEN_gm = 0xFF               ; Sample lenght group mask
  ADC_SAMPLEN_gp = 0                  ; Sample lenght group position
  ADC_SAMPLEN_0_bm = (1<<0)           ; Sample lenght bit 0 mask
  ADC_SAMPLEN_0_bp = 0                ; Sample lenght bit 0 position
  ADC_SAMPLEN_1_bm = (1<<1)           ; Sample lenght bit 1 mask
  ADC_SAMPLEN_1_bp = 1                ; Sample lenght bit 1 position
  ADC_SAMPLEN_2_bm = (1<<2)           ; Sample lenght bit 2 mask
  ADC_SAMPLEN_2_bp = 2                ; Sample lenght bit 2 position
  ADC_SAMPLEN_3_bm = (1<<3)           ; Sample lenght bit 3 mask
  ADC_SAMPLEN_3_bp = 3                ; Sample lenght bit 3 position
  ADC_SAMPLEN_4_bm = (1<<4)           ; Sample lenght bit 4 mask
  ADC_SAMPLEN_4_bp = 4                ; Sample lenght bit 4 position
  ADC_SAMPLEN_5_bm = (1<<5)           ; Sample lenght bit 5 mask
  ADC_SAMPLEN_5_bp = 5                ; Sample lenght bit 5 position
  ADC_SAMPLEN_6_bm = (1<<6)           ; Sample lenght bit 6 mask
  ADC_SAMPLEN_6_bp = 6                ; Sample lenght bit 6 position
  ADC_SAMPLEN_7_bm = (1<<7)           ; Sample lenght bit 7 mask
  ADC_SAMPLEN_7_bp = 7                ; Sample lenght bit 7 position
  
  ; ADC_MUXPOS masks
  ADC_MUXPOS_gm = 0x7F                ; Analog Channel Selection Bits group mask
  ADC_MUXPOS_gp = 0                   ; Analog Channel Selection Bits group position
  ADC_MUXPOS_0_bm = (1<<0)            ; Analog Channel Selection Bits bit 0 mask
  ADC_MUXPOS_0_bp = 0                 ; Analog Channel Selection Bits bit 0 position
  ADC_MUXPOS_1_bm = (1<<1)            ; Analog Channel Selection Bits bit 1 mask
  ADC_MUXPOS_1_bp = 1                 ; Analog Channel Selection Bits bit 1 position
  ADC_MUXPOS_2_bm = (1<<2)            ; Analog Channel Selection Bits bit 2 mask
  ADC_MUXPOS_2_bp = 2                 ; Analog Channel Selection Bits bit 2 position
  ADC_MUXPOS_3_bm = (1<<3)            ; Analog Channel Selection Bits bit 3 mask
  ADC_MUXPOS_3_bp = 3                 ; Analog Channel Selection Bits bit 3 position
  ADC_MUXPOS_4_bm = (1<<4)            ; Analog Channel Selection Bits bit 4 mask
  ADC_MUXPOS_4_bp = 4                 ; Analog Channel Selection Bits bit 4 position
  ADC_MUXPOS_5_bm = (1<<5)            ; Analog Channel Selection Bits bit 5 mask
  ADC_MUXPOS_5_bp = 5                 ; Analog Channel Selection Bits bit 5 position
  ADC_MUXPOS_6_bm = (1<<6)            ; Analog Channel Selection Bits bit 6 mask
  ADC_MUXPOS_6_bp = 6                 ; Analog Channel Selection Bits bit 6 position
  
  ; ADC_MUXNEG masks
  ADC_MUXNEG_gm = 0x7F                ; Analog Channel Selection Bits group mask
  ADC_MUXNEG_gp = 0                   ; Analog Channel Selection Bits group position
  ADC_MUXNEG_0_bm = (1<<0)            ; Analog Channel Selection Bits bit 0 mask
  ADC_MUXNEG_0_bp = 0                 ; Analog Channel Selection Bits bit 0 position
  ADC_MUXNEG_1_bm = (1<<1)            ; Analog Channel Selection Bits bit 1 mask
  ADC_MUXNEG_1_bp = 1                 ; Analog Channel Selection Bits bit 1 position
  ADC_MUXNEG_2_bm = (1<<2)            ; Analog Channel Selection Bits bit 2 mask
  ADC_MUXNEG_2_bp = 2                 ; Analog Channel Selection Bits bit 2 position
  ADC_MUXNEG_3_bm = (1<<3)            ; Analog Channel Selection Bits bit 3 mask
  ADC_MUXNEG_3_bp = 3                 ; Analog Channel Selection Bits bit 3 position
  ADC_MUXNEG_4_bm = (1<<4)            ; Analog Channel Selection Bits bit 4 mask
  ADC_MUXNEG_4_bp = 4                 ; Analog Channel Selection Bits bit 4 position
  ADC_MUXNEG_5_bm = (1<<5)            ; Analog Channel Selection Bits bit 5 mask
  ADC_MUXNEG_5_bp = 5                 ; Analog Channel Selection Bits bit 5 position
  ADC_MUXNEG_6_bm = (1<<6)            ; Analog Channel Selection Bits bit 6 mask
  ADC_MUXNEG_6_bp = 6                 ; Analog Channel Selection Bits bit 6 position
  
  ; ADC_COMMAND masks
  ADC_STCONV_bm = 0x01                ; Start Conversion bit mask
  ADC_STCONV_bp = 0                   ; Start Conversion bit position
  ADC_SPCONV_bm = 0x02                ; Stop Conversion bit mask
  ADC_SPCONV_bp = 1                   ; Stop Conversion bit position
  
  ; ADC_EVCTRL masks
  ADC_STARTEI_bm = 0x01               ; Start Event Input Enable bit mask
  ADC_STARTEI_bp = 0                  ; Start Event Input Enable bit position
  
  ; ADC_INTCTRL masks
  ADC_RESRDY_bm = 0x01                ; Result Ready Interrupt Enable bit mask
  ADC_RESRDY_bp = 0                   ; Result Ready Interrupt Enable bit position
  ADC_WCMP_bm = 0x02                  ; Window Comparator Interrupt Enable bit mask
  ADC_WCMP_bp = 1                     ; Window Comparator Interrupt Enable bit position
  
  ; ADC_INTFLAGS masks
  ; Masks for ADC_RESRDY already defined
  ; Masks for ADC_WCMP already defined
  
  ; ADC_DBGCTRL masks
  ADC_DBGRUN_bm = 0x01                ; Debug run bit mask
  ADC_DBGRUN_bp = 0                   ; Debug run bit position
  
  ; ADC_TEMP masks
  ADC_TEMP_gm = 0xFF                  ; Temporary group mask
  ADC_TEMP_gp = 0                     ; Temporary group position
  ADC_TEMP_0_bm = (1<<0)              ; Temporary bit 0 mask
  ADC_TEMP_0_bp = 0                   ; Temporary bit 0 position
  ADC_TEMP_1_bm = (1<<1)              ; Temporary bit 1 mask
  ADC_TEMP_1_bp = 1                   ; Temporary bit 1 position
  ADC_TEMP_2_bm = (1<<2)              ; Temporary bit 2 mask
  ADC_TEMP_2_bp = 2                   ; Temporary bit 2 position
  ADC_TEMP_3_bm = (1<<3)              ; Temporary bit 3 mask
  ADC_TEMP_3_bp = 3                   ; Temporary bit 3 position
  ADC_TEMP_4_bm = (1<<4)              ; Temporary bit 4 mask
  ADC_TEMP_4_bp = 4                   ; Temporary bit 4 position
  ADC_TEMP_5_bm = (1<<5)              ; Temporary bit 5 mask
  ADC_TEMP_5_bp = 5                   ; Temporary bit 5 position
  ADC_TEMP_6_bm = (1<<6)              ; Temporary bit 6 mask
  ADC_TEMP_6_bp = 6                   ; Temporary bit 6 position
  ADC_TEMP_7_bm = (1<<7)              ; Temporary bit 7 mask
  ADC_TEMP_7_bp = 7                   ; Temporary bit 7 position
  
  ; Conversion mode select
  ADC_CONVMODE_SINGLEENDED_gc = (0x00<<5) ; Single-Ended mode
  ADC_CONVMODE_DIFF_gc = (0x01<<5)    ; Differential mode
  
  ; Resolution selection
  ADC_RESSEL_12BIT_gc = (0x00<<2)     ; 12-bit mode
  ADC_RESSEL_10BIT_gc = (0x01<<2)     ; 10-bit mode
  
  ; Accumulation Samples select
  ADC_SAMPNUM_NONE_gc = (0x00<<0)     ; No accumulation
  ADC_SAMPNUM_ACC2_gc = (0x01<<0)     ; 2 results accumulated
  ADC_SAMPNUM_ACC4_gc = (0x02<<0)     ; 4 results accumulated
  ADC_SAMPNUM_ACC8_gc = (0x03<<0)     ; 8 results accumulated
  ADC_SAMPNUM_ACC16_gc = (0x04<<0)    ; 16 results accumulated
  ADC_SAMPNUM_ACC32_gc = (0x05<<0)    ; 32 results accumulated
  ADC_SAMPNUM_ACC64_gc = (0x06<<0)    ; 64 results accumulated
  ADC_SAMPNUM_ACC128_gc = (0x07<<0)   ; 128 results accumulated
  
  ; Clock Pre-scaler select
  ADC_PRESC_DIV2_gc = (0x00<<0)       ; CLK_PER divided by 2
  ADC_PRESC_DIV4_gc = (0x01<<0)       ; CLK_PER divided by 4
  ADC_PRESC_DIV8_gc = (0x02<<0)       ; CLK_PER divided by 8
  ADC_PRESC_DIV12_gc = (0x03<<0)      ; CLK_PER divided by 12
  ADC_PRESC_DIV16_gc = (0x04<<0)      ; CLK_PER divided by 16
  ADC_PRESC_DIV20_gc = (0x05<<0)      ; CLK_PER divided by 20
  ADC_PRESC_DIV24_gc = (0x06<<0)      ; CLK_PER divided by 24
  ADC_PRESC_DIV28_gc = (0x07<<0)      ; CLK_PER divided by 28
  ADC_PRESC_DIV32_gc = (0x08<<0)      ; CLK_PER divided by 32
  ADC_PRESC_DIV48_gc = (0x09<<0)      ; CLK_PER divided by 48
  ADC_PRESC_DIV64_gc = (0x0A<<0)      ; CLK_PER divided by 64
  ADC_PRESC_DIV96_gc = (0x0B<<0)      ; CLK_PER divided by 96
  ADC_PRESC_DIV128_gc = (0x0C<<0)     ; CLK_PER divided by 128
  ADC_PRESC_DIV256_gc = (0x0D<<0)     ; CLK_PER divided by 256
  
  ; Initial Delay Selection
  ADC_INITDLY_DLY0_gc = (0x00<<5)     ; Delay 0 CLK_ADC cycles
  ADC_INITDLY_DLY16_gc = (0x01<<5)    ; Delay 16 CLK_ADC cycles
  ADC_INITDLY_DLY32_gc = (0x02<<5)    ; Delay 32 CLK_ADC cycles
  ADC_INITDLY_DLY64_gc = (0x03<<5)    ; Delay 64 CLK_ADC cycles
  ADC_INITDLY_DLY128_gc = (0x04<<5)   ; Delay 128 CLK_ADC cycles
  ADC_INITDLY_DLY256_gc = (0x05<<5)   ; Delay 256 CLK_ADC cycles
  
  ; Sampling Delay Selection
  ADC_SAMPDLY_DLY0_gc = (0x00<<0)     ; Delay 0 CLK_ADC cycles
  ADC_SAMPDLY_DLY1_gc = (0x01<<0)     ; Delay 1 CLK_ADC cycles
  ADC_SAMPDLY_DLY2_gc = (0x02<<0)     ; Delay 2 CLK_ADC cycles
  ADC_SAMPDLY_DLY3_gc = (0x03<<0)     ; Delay 3 CLK_ADC cycles
  ADC_SAMPDLY_DLY4_gc = (0x04<<0)     ; Delay 4 CLK_ADC cycles
  ADC_SAMPDLY_DLY5_gc = (0x05<<0)     ; Delay 5 CLK_ADC cycles
  ADC_SAMPDLY_DLY6_gc = (0x06<<0)     ; Delay 6 CLK_ADC cycles
  ADC_SAMPDLY_DLY7_gc = (0x07<<0)     ; Delay 7 CLK_ADC cycles
  ADC_SAMPDLY_DLY8_gc = (0x08<<0)     ; Delay 8 CLK_ADC cycles
  ADC_SAMPDLY_DLY9_gc = (0x09<<0)     ; Delay 9 CLK_ADC cycles
  ADC_SAMPDLY_DLY10_gc = (0x0A<<0)    ; Delay 10 CLK_ADC cycles
  ADC_SAMPDLY_DLY11_gc = (0x0B<<0)    ; Delay 11 CLK_ADC cycles
  ADC_SAMPDLY_DLY12_gc = (0x0C<<0)    ; Delay 12 CLK_ADC cycles
  ADC_SAMPDLY_DLY13_gc = (0x0D<<0)    ; Delay 13 CLK_ADC cycles
  ADC_SAMPDLY_DLY14_gc = (0x0E<<0)    ; Delay 14 CLK_ADC cycles
  ADC_SAMPDLY_DLY15_gc = (0x0F<<0)    ; Delay 15 CLK_ADC cycles
  
  ; Window Comparator Mode select
  ADC_WINCM_NONE_gc = (0x00<<0)       ; No Window Comparison
  ADC_WINCM_BELOW_gc = (0x01<<0)      ; Below Window
  ADC_WINCM_ABOVE_gc = (0x02<<0)      ; Above Window
  ADC_WINCM_INSIDE_gc = (0x03<<0)     ; Inside Window
  ADC_WINCM_OUTSIDE_gc = (0x04<<0)    ; Outside Window
  
  ; Analog Channel Selection Bits
  ADC_MUXNEG_AIN1_gc = (0x01<<0)      ; ADC input pin 1
  ADC_MUXNEG_AIN2_gc = (0x02<<0)      ; ADC input pin 2
  ADC_MUXNEG_AIN3_gc = (0x03<<0)      ; ADC input pin 3
  ADC_MUXNEG_AIN4_gc = (0x04<<0)      ; ADC input pin 4
  ADC_MUXNEG_AIN5_gc = (0x05<<0)      ; ADC input pin 5
  ADC_MUXNEG_AIN6_gc = (0x06<<0)      ; ADC input pin 6
  ADC_MUXNEG_AIN7_gc = (0x07<<0)      ; ADC input pin 7
  ADC_MUXNEG_AIN16_gc = (0x10<<0)     ; ADC input pin 16
  ADC_MUXNEG_AIN17_gc = (0x11<<0)     ; ADC input pin 17
  ADC_MUXNEG_AIN18_gc = (0x12<<0)     ; ADC input pin 18
  ADC_MUXNEG_AIN19_gc = (0x13<<0)     ; ADC input pin 19
  ADC_MUXNEG_AIN20_gc = (0x14<<0)     ; ADC input pin 20
  ADC_MUXNEG_AIN21_gc = (0x15<<0)     ; ADC input pin 21
  ADC_MUXNEG_AIN22_gc = (0x16<<0)     ; ADC input pin 22
  ADC_MUXNEG_AIN23_gc = (0x17<<0)     ; ADC input pin 23
  ADC_MUXNEG_AIN24_gc = (0x18<<0)     ; ADC input pin 24
  ADC_MUXNEG_AIN25_gc = (0x19<<0)     ; ADC input pin 25
  ADC_MUXNEG_AIN26_gc = (0x1A<<0)     ; ADC input pin 26
  ADC_MUXNEG_AIN27_gc = (0x1B<<0)     ; ADC input pin 27
  ADC_MUXNEG_AIN28_gc = (0x1C<<0)     ; ADC input pin 28
  ADC_MUXNEG_AIN29_gc = (0x1D<<0)     ; ADC input pin 29
  ADC_MUXNEG_AIN30_gc = (0x1E<<0)     ; ADC input pin 30
  ADC_MUXNEG_AIN31_gc = (0x1F<<0)     ; ADC input pin 31
  ADC_MUXNEG_GND_gc = (0x40<<0)       ; Ground
  ADC_MUXNEG_DAC0_gc = (0x48<<0)      ; DAC0
  
  ; Analog Channel Selection Bits
  ADC_MUXPOS_AIN1_gc = (0x01<<0)      ; ADC input pin 1
  AIN1 = (0x01<<0)      ; ADC input pin 1
  ADC_MUXPOS_AIN2_gc = (0x02<<0)      ; ADC input pin 2
  AIN2 = (0x02<<0)      ; ADC input pin 2
  ADC_MUXPOS_AIN3_gc = (0x03<<0)      ; ADC input pin 3
  AIN3 = (0x03<<0)      ; ADC input pin 3
  ADC_MUXPOS_AIN4_gc = (0x04<<0)      ; ADC input pin 4
  AIN4 = (0x04<<0)      ; ADC input pin 4
  ADC_MUXPOS_AIN5_gc = (0x05<<0)      ; ADC input pin 5
  AIN5 = (0x05<<0)      ; ADC input pin 5
  ADC_MUXPOS_AIN6_gc = (0x06<<0)      ; ADC input pin 6
  AIN6 = (0x06<<0)      ; ADC input pin 6
  ADC_MUXPOS_AIN7_gc = (0x07<<0)      ; ADC input pin 7
  AIN7 = (0x07<<0)      ; ADC input pin 7
  ADC_MUXPOS_AIN16_gc = (0x10<<0)     ; ADC input pin 16
  AIN16 = (0x10<<0)     ; ADC input pin 16
  ADC_MUXPOS_AIN17_gc = (0x11<<0)     ; ADC input pin 17
  AIN17 = (0x11<<0)     ; ADC input pin 17
  ADC_MUXPOS_AIN18_gc = (0x12<<0)     ; ADC input pin 18
  AIN18 = (0x12<<0)     ; ADC input pin 18
  ADC_MUXPOS_AIN19_gc = (0x13<<0)     ; ADC input pin 19
  AIN19 = (0x13<<0)     ; ADC input pin 19
  ADC_MUXPOS_AIN20_gc = (0x14<<0)     ; ADC input pin 20
  AIN20 = (0x14<<0)     ; ADC input pin 20
  ADC_MUXPOS_AIN21_gc = (0x15<<0)     ; ADC input pin 21
  AIN21 = (0x15<<0)     ; ADC input pin 21
  ADC_MUXPOS_AIN22_gc = (0x16<<0)     ; ADC input pin 22
  AIN22 = (0x16<<0)     ; ADC input pin 22
  ADC_MUXPOS_AIN23_gc = (0x17<<0)     ; ADC input pin 23
  AIN23 = (0x17<<0)     ; ADC input pin 23
  ADC_MUXPOS_AIN24_gc = (0x18<<0)     ; ADC input pin 24
  AIN24 = (0x18<<0)     ; ADC input pin 24
  ADC_MUXPOS_AIN25_gc = (0x19<<0)     ; ADC input pin 25
  AIN25 = (0x19<<0)     ; ADC input pin 25
  ADC_MUXPOS_AIN26_gc = (0x1A<<0)     ; ADC input pin 26
  AIN26 = (0x1A<<0)     ; ADC input pin 26
  ADC_MUXPOS_AIN27_gc = (0x1B<<0)     ; ADC input pin 27
  AIN27 = (0x1B<<0)     ; ADC input pin 27
  ADC_MUXPOS_AIN28_gc = (0x1C<<0)     ; ADC input pin 28
  AIN28 = (0x1C<<0)     ; ADC input pin 28
  ADC_MUXPOS_AIN29_gc = (0x1D<<0)     ; ADC input pin 29
  AIN29 = (0x1D<<0)     ; ADC input pin 29
  ADC_MUXPOS_AIN30_gc = (0x1E<<0)     ; ADC input pin 30
  AIN30 = (0x1E<<0)     ; ADC input pin 30
  ADC_MUXPOS_AIN31_gc = (0x1F<<0)     ; ADC input pin 31
  AIN31 = (0x1F<<0)     ; ADC input pin 31
  ADC_MUXPOS_GND_gc = (0x40<<0)       ; Ground
  ADC_MUXPOS_TEMPSENSE_gc = (0x42<<0) ; Temperature sensor
  ADC_MUXPOS_VDDDIV10_gc = (0x44<<0)  ; VDD/10
  ADC_MUXPOS_VDDIO2DIV10_gc = (0x45<<0) ; VDDIO2/10
  ADC_MUXPOS_DAC0_gc = (0x48<<0)      ; DAC0
  ADC_MUXPOS_DACREF0_gc = (0x49<<0)   ; DACREF0
  
  
  ;*************************************************************************
  ;** BOD - Bod interface
  ;*************************************************************************
  
  ; BOD_CTRLA masks
  BOD_SLEEP_gm = 0x03                 ; Operation in sleep mode group mask
  BOD_SLEEP_gp = 0                    ; Operation in sleep mode group position
  BOD_SLEEP_0_bm = (1<<0)             ; Operation in sleep mode bit 0 mask
  BOD_SLEEP_0_bp = 0                  ; Operation in sleep mode bit 0 position
  BOD_SLEEP_1_bm = (1<<1)             ; Operation in sleep mode bit 1 mask
  BOD_SLEEP_1_bp = 1                  ; Operation in sleep mode bit 1 position
  BOD_ACTIVE_gm = 0x0C                ; Operation in active mode group mask
  BOD_ACTIVE_gp = 2                   ; Operation in active mode group position
  BOD_ACTIVE_0_bm = (1<<2)            ; Operation in active mode bit 0 mask
  BOD_ACTIVE_0_bp = 2                 ; Operation in active mode bit 0 position
  BOD_ACTIVE_1_bm = (1<<3)            ; Operation in active mode bit 1 mask
  BOD_ACTIVE_1_bp = 3                 ; Operation in active mode bit 1 position
  BOD_SAMPFREQ_bm = 0x10              ; Sample frequency bit mask
  BOD_SAMPFREQ_bp = 4                 ; Sample frequency bit position
  
  ; BOD_CTRLB masks
  BOD_LVL_gm = 0x07                   ; Bod level group mask
  BOD_LVL_gp = 0                      ; Bod level group position
  BOD_LVL_0_bm = (1<<0)               ; Bod level bit 0 mask
  BOD_LVL_0_bp = 0                    ; Bod level bit 0 position
  BOD_LVL_1_bm = (1<<1)               ; Bod level bit 1 mask
  BOD_LVL_1_bp = 1                    ; Bod level bit 1 position
  BOD_LVL_2_bm = (1<<2)               ; Bod level bit 2 mask
  BOD_LVL_2_bp = 2                    ; Bod level bit 2 position
  
  ; BOD_VLMCTRLA masks
  BOD_VLMLVL_gm = 0x03                ; voltage level monitor level group mask
  BOD_VLMLVL_gp = 0                   ; voltage level monitor level group position
  BOD_VLMLVL_0_bm = (1<<0)            ; voltage level monitor level bit 0 mask
  BOD_VLMLVL_0_bp = 0                 ; voltage level monitor level bit 0 position
  BOD_VLMLVL_1_bm = (1<<1)            ; voltage level monitor level bit 1 mask
  BOD_VLMLVL_1_bp = 1                 ; voltage level monitor level bit 1 position
  
  ; BOD_INTCTRL masks
  BOD_VLMIE_bm = 0x01                 ; voltage level monitor interrrupt enable bit mask
  BOD_VLMIE_bp = 0                    ; voltage level monitor interrrupt enable bit position
  BOD_VLMCFG_gm = 0x06                ; Configuration group mask
  BOD_VLMCFG_gp = 1                   ; Configuration group position
  BOD_VLMCFG_0_bm = (1<<1)            ; Configuration bit 0 mask
  BOD_VLMCFG_0_bp = 1                 ; Configuration bit 0 position
  BOD_VLMCFG_1_bm = (1<<2)            ; Configuration bit 1 mask
  BOD_VLMCFG_1_bp = 2                 ; Configuration bit 1 position
  
  ; BOD_INTFLAGS masks
  BOD_VLMIF_bm = 0x01                 ; Voltage level monitor interrupt flag bit mask
  BOD_VLMIF_bp = 0                    ; Voltage level monitor interrupt flag bit position
  
  ; BOD_STATUS masks
  BOD_VLMS_bm = 0x01                  ; Voltage level monitor status bit mask
  BOD_VLMS_bp = 0                     ; Voltage level monitor status bit position
  
  ; Operation in active mode select
  BOD_ACTIVE_DIS_gc = (0x00<<2)       ; Disabled
  BOD_ACTIVE_ENABLED_gc = (0x01<<2)   ; Enabled
  BOD_ACTIVE_SAMPLED_gc = (0x02<<2)   ; Sampled
  BOD_ACTIVE_ENWAKE_gc = (0x03<<2)    ; Enabled with wake-up halted until BOD is ready
  
  ; Sample frequency select
  BOD_SAMPFREQ_128HZ_gc = (0x00<<4)   ; 128Hz sampling frequency
  BOD_SAMPFREQ_32HZ_gc = (0x01<<4)    ; 32Hz sampling frequency
  
  ; Operation in sleep mode select
  BOD_SLEEP_DIS_gc = (0x00<<0)        ; Disabled
  BOD_SLEEP_ENABLED_gc = (0x01<<0)    ; Enabled
  BOD_SLEEP_SAMPLED_gc = (0x02<<0)    ; Sampled
  
  ; Bod level select
  BOD_LVL_BODLEVEL0_gc = (0x00<<0)    ; 1.9 V
  BOD_LVL_BODLEVEL1_gc = (0x01<<0)    ; 2.45 V
  BOD_LVL_BODLEVEL2_gc = (0x02<<0)    ; 2.7 V
  BOD_LVL_BODLEVEL3_gc = (0x03<<0)    ; 2.85 V
  
  ; Configuration select
  BOD_VLMCFG_FALLING_gc = (0x00<<1)   ; VDD falls below VLM threshold
  BOD_VLMCFG_RISING_gc = (0x01<<1)    ; VDD rises above VLM threshold
  BOD_VLMCFG_BOTH_gc = (0x02<<1)      ; VDD crosses VLM threshold
  
  ; Voltage level monitor status select
  BOD_VLMS_ABOVE_gc = (0x00<<0)       ; The voltage is above the VLM threshold level
  BOD_VLMS_BELOW_gc = (0x01<<0)       ; The voltage is below the VLM threshold level
  
  ; voltage level monitor level select
  BOD_VLMLVL_OFF_gc = (0x00<<0)       ; VLM Disabled
  BOD_VLMLVL_5ABOVE_gc = (0x01<<0)    ; VLM threshold 5% above BOD level
  BOD_VLMLVL_15ABOVE_gc = (0x02<<0)   ; VLM threshold 15% above BOD level
  BOD_VLMLVL_25ABOVE_gc = (0x03<<0)   ; VLM threshold 25% above BOD level
  
  
  ;*************************************************************************
  ;** CCL - Configurable Custom Logic
  ;*************************************************************************
  
  ; CCL_CTRLA masks
  CCL_ENABLE_bm = 0x01                ; Enable bit mask
  CCL_ENABLE_bp = 0                   ; Enable bit position
  CCL_RUNSTDBY_bm = 0x40              ; Run in Standby bit mask
  CCL_RUNSTDBY_bp = 6                 ; Run in Standby bit position
  
  ; CCL_SEQCTRL0 masks
  CCL_SEQSEL_gm = 0x07                ; Sequential Selection group mask
  CCL_SEQSEL_gp = 0                   ; Sequential Selection group position
  CCL_SEQSEL_0_bm = (1<<0)            ; Sequential Selection bit 0 mask
  CCL_SEQSEL_0_bp = 0                 ; Sequential Selection bit 0 position
  CCL_SEQSEL_1_bm = (1<<1)            ; Sequential Selection bit 1 mask
  CCL_SEQSEL_1_bp = 1                 ; Sequential Selection bit 1 position
  CCL_SEQSEL_2_bm = (1<<2)            ; Sequential Selection bit 2 mask
  CCL_SEQSEL_2_bp = 2                 ; Sequential Selection bit 2 position
  
  ; CCL_SEQCTRL1 masks
  ; Masks for CCL_SEQSEL already defined
  
  ; CCL_INTCTRL0 masks
  CCL_INTMODE0_gm = 0x03              ; Interrupt Mode for LUT0 group mask
  CCL_INTMODE0_gp = 0                 ; Interrupt Mode for LUT0 group position
  CCL_INTMODE0_0_bm = (1<<0)          ; Interrupt Mode for LUT0 bit 0 mask
  CCL_INTMODE0_0_bp = 0               ; Interrupt Mode for LUT0 bit 0 position
  CCL_INTMODE0_1_bm = (1<<1)          ; Interrupt Mode for LUT0 bit 1 mask
  CCL_INTMODE0_1_bp = 1               ; Interrupt Mode for LUT0 bit 1 position
  CCL_INTMODE1_gm = 0x0C              ; Interrupt Mode for LUT1 group mask
  CCL_INTMODE1_gp = 2                 ; Interrupt Mode for LUT1 group position
  CCL_INTMODE1_0_bm = (1<<2)          ; Interrupt Mode for LUT1 bit 0 mask
  CCL_INTMODE1_0_bp = 2               ; Interrupt Mode for LUT1 bit 0 position
  CCL_INTMODE1_1_bm = (1<<3)          ; Interrupt Mode for LUT1 bit 1 mask
  CCL_INTMODE1_1_bp = 3               ; Interrupt Mode for LUT1 bit 1 position
  CCL_INTMODE2_gm = 0x30              ; Interrupt Mode for LUT2 group mask
  CCL_INTMODE2_gp = 4                 ; Interrupt Mode for LUT2 group position
  CCL_INTMODE2_0_bm = (1<<4)          ; Interrupt Mode for LUT2 bit 0 mask
  CCL_INTMODE2_0_bp = 4               ; Interrupt Mode for LUT2 bit 0 position
  CCL_INTMODE2_1_bm = (1<<5)          ; Interrupt Mode for LUT2 bit 1 mask
  CCL_INTMODE2_1_bp = 5               ; Interrupt Mode for LUT2 bit 1 position
  CCL_INTMODE3_gm = 0xC0              ; Interrupt Mode for LUT3 group mask
  CCL_INTMODE3_gp = 6                 ; Interrupt Mode for LUT3 group position
  CCL_INTMODE3_0_bm = (1<<6)          ; Interrupt Mode for LUT3 bit 0 mask
  CCL_INTMODE3_0_bp = 6               ; Interrupt Mode for LUT3 bit 0 position
  CCL_INTMODE3_1_bm = (1<<7)          ; Interrupt Mode for LUT3 bit 1 mask
  CCL_INTMODE3_1_bp = 7               ; Interrupt Mode for LUT3 bit 1 position
  
  ; CCL_INTFLAGS masks
  CCL_INT_gm = 0x0F                   ; Interrupt Flag group mask
  CCL_INT_gp = 0                      ; Interrupt Flag group position
  CCL_INT_0_bm = (1<<0)               ; Interrupt Flag bit 0 mask
  CCL_INT_0_bp = 0                    ; Interrupt Flag bit 0 position
  CCL_INT_1_bm = (1<<1)               ; Interrupt Flag bit 1 mask
  CCL_INT_1_bp = 1                    ; Interrupt Flag bit 1 position
  CCL_INT_2_bm = (1<<2)               ; Interrupt Flag bit 2 mask
  CCL_INT_2_bp = 2                    ; Interrupt Flag bit 2 position
  CCL_INT_3_bm = (1<<3)               ; Interrupt Flag bit 3 mask
  CCL_INT_3_bp = 3                    ; Interrupt Flag bit 3 position
  
  ; CCL_LUT0CTRLA masks
  ; Masks for CCL_ENABLE already defined
  CCL_CLKSRC_gm = 0x0E                ; Clock Source Selection group mask
  CCL_CLKSRC_gp = 1                   ; Clock Source Selection group position
  CCL_CLKSRC_0_bm = (1<<1)            ; Clock Source Selection bit 0 mask
  CCL_CLKSRC_0_bp = 1                 ; Clock Source Selection bit 0 position
  CCL_CLKSRC_1_bm = (1<<2)            ; Clock Source Selection bit 1 mask
  CCL_CLKSRC_1_bp = 2                 ; Clock Source Selection bit 1 position
  CCL_CLKSRC_2_bm = (1<<3)            ; Clock Source Selection bit 2 mask
  CCL_CLKSRC_2_bp = 3                 ; Clock Source Selection bit 2 position
  CCL_FILTSEL_gm = 0x30               ; Filter Selection group mask
  CCL_FILTSEL_gp = 4                  ; Filter Selection group position
  CCL_FILTSEL_0_bm = (1<<4)           ; Filter Selection bit 0 mask
  CCL_FILTSEL_0_bp = 4                ; Filter Selection bit 0 position
  CCL_FILTSEL_1_bm = (1<<5)           ; Filter Selection bit 1 mask
  CCL_FILTSEL_1_bp = 5                ; Filter Selection bit 1 position
  CCL_OUTEN_bm = 0x40                 ; Output Enable bit mask
  CCL_OUTEN_bp = 6                    ; Output Enable bit position
  CCL_EDGEDET_bm = 0x80               ; Edge Detection Enable bit mask
  CCL_EDGEDET_bp = 7                  ; Edge Detection Enable bit position
  
  ; CCL_LUT0CTRLB masks
  CCL_INSEL0_gm = 0x0F                ; LUT Input 0 Source Selection group mask
  CCL_INSEL0_gp = 0                   ; LUT Input 0 Source Selection group position
  CCL_INSEL0_0_bm = (1<<0)            ; LUT Input 0 Source Selection bit 0 mask
  CCL_INSEL0_0_bp = 0                 ; LUT Input 0 Source Selection bit 0 position
  CCL_INSEL0_1_bm = (1<<1)            ; LUT Input 0 Source Selection bit 1 mask
  CCL_INSEL0_1_bp = 1                 ; LUT Input 0 Source Selection bit 1 position
  CCL_INSEL0_2_bm = (1<<2)            ; LUT Input 0 Source Selection bit 2 mask
  CCL_INSEL0_2_bp = 2                 ; LUT Input 0 Source Selection bit 2 position
  CCL_INSEL0_3_bm = (1<<3)            ; LUT Input 0 Source Selection bit 3 mask
  CCL_INSEL0_3_bp = 3                 ; LUT Input 0 Source Selection bit 3 position
  CCL_INSEL1_gm = 0xF0                ; LUT Input 1 Source Selection group mask
  CCL_INSEL1_gp = 4                   ; LUT Input 1 Source Selection group position
  CCL_INSEL1_0_bm = (1<<4)            ; LUT Input 1 Source Selection bit 0 mask
  CCL_INSEL1_0_bp = 4                 ; LUT Input 1 Source Selection bit 0 position
  CCL_INSEL1_1_bm = (1<<5)            ; LUT Input 1 Source Selection bit 1 mask
  CCL_INSEL1_1_bp = 5                 ; LUT Input 1 Source Selection bit 1 position
  CCL_INSEL1_2_bm = (1<<6)            ; LUT Input 1 Source Selection bit 2 mask
  CCL_INSEL1_2_bp = 6                 ; LUT Input 1 Source Selection bit 2 position
  CCL_INSEL1_3_bm = (1<<7)            ; LUT Input 1 Source Selection bit 3 mask
  CCL_INSEL1_3_bp = 7                 ; LUT Input 1 Source Selection bit 3 position
  
  ; CCL_LUT0CTRLC masks
  CCL_INSEL2_gm = 0x0F                ; LUT Input 2 Source Selection group mask
  CCL_INSEL2_gp = 0                   ; LUT Input 2 Source Selection group position
  CCL_INSEL2_0_bm = (1<<0)            ; LUT Input 2 Source Selection bit 0 mask
  CCL_INSEL2_0_bp = 0                 ; LUT Input 2 Source Selection bit 0 position
  CCL_INSEL2_1_bm = (1<<1)            ; LUT Input 2 Source Selection bit 1 mask
  CCL_INSEL2_1_bp = 1                 ; LUT Input 2 Source Selection bit 1 position
  CCL_INSEL2_2_bm = (1<<2)            ; LUT Input 2 Source Selection bit 2 mask
  CCL_INSEL2_2_bp = 2                 ; LUT Input 2 Source Selection bit 2 position
  CCL_INSEL2_3_bm = (1<<3)            ; LUT Input 2 Source Selection bit 3 mask
  CCL_INSEL2_3_bp = 3                 ; LUT Input 2 Source Selection bit 3 position
  
  ; CCL_TRUTH0 masks
  CCL_TRUTH_gm = 0xFF                 ; Truth Table group mask
  CCL_TRUTH_gp = 0                    ; Truth Table group position
  CCL_TRUTH_0_bm = (1<<0)             ; Truth Table bit 0 mask
  CCL_TRUTH_0_bp = 0                  ; Truth Table bit 0 position
  CCL_TRUTH_1_bm = (1<<1)             ; Truth Table bit 1 mask
  CCL_TRUTH_1_bp = 1                  ; Truth Table bit 1 position
  CCL_TRUTH_2_bm = (1<<2)             ; Truth Table bit 2 mask
  CCL_TRUTH_2_bp = 2                  ; Truth Table bit 2 position
  CCL_TRUTH_3_bm = (1<<3)             ; Truth Table bit 3 mask
  CCL_TRUTH_3_bp = 3                  ; Truth Table bit 3 position
  CCL_TRUTH_4_bm = (1<<4)             ; Truth Table bit 4 mask
  CCL_TRUTH_4_bp = 4                  ; Truth Table bit 4 position
  CCL_TRUTH_5_bm = (1<<5)             ; Truth Table bit 5 mask
  CCL_TRUTH_5_bp = 5                  ; Truth Table bit 5 position
  CCL_TRUTH_6_bm = (1<<6)             ; Truth Table bit 6 mask
  CCL_TRUTH_6_bp = 6                  ; Truth Table bit 6 position
  CCL_TRUTH_7_bm = (1<<7)             ; Truth Table bit 7 mask
  CCL_TRUTH_7_bp = 7                  ; Truth Table bit 7 position
  
  ; CCL_LUT1CTRLA masks
  ; Masks for CCL_ENABLE already defined
  ; Masks for CCL_CLKSRC already defined
  ; Masks for CCL_FILTSEL already defined
  ; Masks for CCL_OUTEN already defined
  ; Masks for CCL_EDGEDET already defined
  
  ; CCL_LUT1CTRLB masks
  ; Masks for CCL_INSEL0 already defined
  ; Masks for CCL_INSEL1 already defined
  
  ; CCL_LUT1CTRLC masks
  ; Masks for CCL_INSEL2 already defined
  
  ; CCL_TRUTH1 masks
  ; Masks for CCL_TRUTH already defined
  
  ; CCL_LUT2CTRLA masks
  ; Masks for CCL_ENABLE already defined
  ; Masks for CCL_CLKSRC already defined
  ; Masks for CCL_FILTSEL already defined
  ; Masks for CCL_OUTEN already defined
  ; Masks for CCL_EDGEDET already defined
  
  ; CCL_LUT2CTRLB masks
  ; Masks for CCL_INSEL0 already defined
  ; Masks for CCL_INSEL1 already defined
  
  ; CCL_LUT2CTRLC masks
  ; Masks for CCL_INSEL2 already defined
  
  ; CCL_TRUTH2 masks
  ; Masks for CCL_TRUTH already defined
  
  ; CCL_LUT3CTRLA masks
  ; Masks for CCL_ENABLE already defined
  ; Masks for CCL_CLKSRC already defined
  ; Masks for CCL_FILTSEL already defined
  ; Masks for CCL_OUTEN already defined
  ; Masks for CCL_EDGEDET already defined
  
  ; CCL_LUT3CTRLB masks
  ; Masks for CCL_INSEL0 already defined
  ; Masks for CCL_INSEL1 already defined
  
  ; CCL_LUT3CTRLC masks
  ; Masks for CCL_INSEL2 already defined
  
  ; CCL_TRUTH3 masks
  ; Masks for CCL_TRUTH already defined
  
  ; Interrupt Mode for LUT0 select
  CCL_INTMODE0_INTDISABLE_gc = (0x00<<0) ; Interrupt disabled
  CCL_INTMODE0_RISING_gc = (0x01<<0)  ; Sense rising edge
  CCL_INTMODE0_FALLING_gc = (0x02<<0) ; Sense falling edge
  CCL_INTMODE0_BOTH_gc = (0x03<<0)    ; Sense both edges
  
  ; Interrupt Mode for LUT1 select
  CCL_INTMODE1_INTDISABLE_gc = (0x00<<2) ; Interrupt disabled
  CCL_INTMODE1_RISING_gc = (0x01<<2)  ; Sense rising edge
  CCL_INTMODE1_FALLING_gc = (0x02<<2) ; Sense falling edge
  CCL_INTMODE1_BOTH_gc = (0x03<<2)    ; Sense both edges
  
  ; Interrupt Mode for LUT2 select
  CCL_INTMODE2_INTDISABLE_gc = (0x00<<4) ; Interrupt disabled
  CCL_INTMODE2_RISING_gc = (0x01<<4)  ; Sense rising edge
  CCL_INTMODE2_FALLING_gc = (0x02<<4) ; Sense falling edge
  CCL_INTMODE2_BOTH_gc = (0x03<<4)    ; Sense both edges
  
  ; Interrupt Mode for LUT3 select
  CCL_INTMODE3_INTDISABLE_gc = (0x00<<6) ; Interrupt disabled
  CCL_INTMODE3_RISING_gc = (0x01<<6)  ; Sense rising edge
  CCL_INTMODE3_FALLING_gc = (0x02<<6) ; Sense falling edge
  CCL_INTMODE3_BOTH_gc = (0x03<<6)    ; Sense both edges
  
  ; Clock Source Selection
  CCL_CLKSRC_CLKPER_gc = (0x00<<1)    ; Peripheral Clock
  CCL_CLKSRC_IN2_gc = (0x01<<1)       ; Selection by INSEL2
  CCL_CLKSRC_OSCHF_gc = (0x04<<1)     ; Internal High-Frequency Oscillator
  CCL_CLKSRC_OSC32K_gc = (0x05<<1)    ; 32.768 kHz oscillator
  CCL_CLKSRC_OSC1K_gc = (0x06<<1)     ; 32.768 kHz oscillator divided by 32
  
  ; Edge Detection Enable select
  CCL_EDGEDET_DIS_gc = (0x00<<7)      ; Edge detector is disabled
  CCL_EDGEDET_EN_gc = (0x01<<7)       ; Edge detector is enabled
  
  ; Filter Selection
  CCL_FILTSEL_DISABLE_gc = (0x00<<4)  ; Filter disabled
  CCL_FILTSEL_SYNCH_gc = (0x01<<4)    ; Synchronizer enabled
  CCL_FILTSEL_FILTER_gc = (0x02<<4)   ; Filter enabled
  
  ; LUT Input 0 Source Selection
  CCL_INSEL0_MASK_gc = (0x00<<0)      ; Masked input
  CCL_INSEL0_FEEDBACK_gc = (0x01<<0)  ; Feedback input source
  CCL_INSEL0_LINK_gc = (0x02<<0)      ; Linked LUT input source
  CCL_INSEL0_EVENTA_gc = (0x03<<0)    ; Event input source A
  CCL_INSEL0_EVENTB_gc = (0x04<<0)    ; Event input source B
  CCL_INSEL0_IN0_gc = (0x05<<0)       ; IO pin LUTn-IN0 input source
  CCL_INSEL0_AC0_gc = (0x06<<0)       ; AC0 OUT input source
  CCL_INSEL0_ZCD3_gc = (0x07<<0)      ; ZCD3 OUT input source
  CCL_INSEL0_USART0_gc = (0x08<<0)    ; USART0 TXD input source
  CCL_INSEL0_SPI0_gc = (0x09<<0)      ; SPI0 MOSI input source
  CCL_INSEL0_TCA0_gc = (0x0A<<0)      ; TCA0 WO0 input source
  CCL_INSEL0_TCB0_gc = (0x0B<<0)      ; TCB0 WO input source
  CCL_INSEL0_TCD0_gc = (0x0C<<0)      ; TCD0 WOA input source
  
  ; LUT Input 1 Source Selection
  CCL_INSEL1_MASK_gc = (0x00<<4)      ; Masked input
  CCL_INSEL1_FEEDBACK_gc = (0x01<<4)  ; Feedback input source
  CCL_INSEL1_LINK_gc = (0x02<<4)      ; Linked LUT input source
  CCL_INSEL1_EVENTA_gc = (0x03<<4)    ; Event input source A
  CCL_INSEL1_EVENTB_gc = (0x04<<4)    ; Event input source B
  CCL_INSEL1_IN1_gc = (0x05<<4)       ; IO pin LUTn-IN1 input source
  CCL_INSEL1_AC0_gc = (0x06<<4)       ; AC0 OUT input source
  CCL_INSEL1_ZCD3_gc = (0x07<<4)      ; ZCD3 OUT input source
  CCL_INSEL1_USART1_gc = (0x08<<4)    ; USART1 TXD input source
  CCL_INSEL1_SPI0_gc = (0x09<<4)      ; SPI0 MOSI input source
  CCL_INSEL1_TCA0_gc = (0x0A<<4)      ; TCA0 WO1 input source
  CCL_INSEL1_TCB1_gc = (0x0B<<4)      ; TCB1 WO input source
  CCL_INSEL1_TCD0_gc = (0x0C<<4)      ; TCD0 WOB input source
  
  ; LUT Input 2 Source Selection
  CCL_INSEL2_MASK_gc = (0x00<<0)      ; Masked input
  CCL_INSEL2_FEEDBACK_gc = (0x01<<0)  ; Feedback input source
  CCL_INSEL2_LINK_gc = (0x02<<0)      ; Linked LUT input source
  CCL_INSEL2_EVENTA_gc = (0x03<<0)    ; Event input source A
  CCL_INSEL2_EVENTB_gc = (0x04<<0)    ; Event input source B
  CCL_INSEL2_IN2_gc = (0x05<<0)       ; IO pin LUTn-IN2 input source
  CCL_INSEL2_AC0_gc = (0x06<<0)       ; AC0 OUT input source
  CCL_INSEL2_ZCD3_gc = (0x07<<0)      ; ZCD3 OUT input source
  CCL_INSEL2_USART1_gc = (0x08<<0)    ; USART1 TXD input source
  CCL_INSEL2_SPI0_gc = (0x09<<0)      ; SPI0 SCK input source
  CCL_INSEL2_TCA0_gc = (0x0A<<0)      ; TCA0 WO2 input source
  CCL_INSEL2_TCB2_gc = (0x0B<<0)      ; TCB2 WO input source
  CCL_INSEL2_TCD0_gc = (0x0C<<0)      ; TCD0 WOC input source
  
  ; Sequential Selection
  CCL_SEQSEL_DISABLE_gc = (0x00<<0)   ; Sequential logic disabled
  CCL_SEQSEL_DFF_gc = (0x01<<0)       ; D FlipFlop
  CCL_SEQSEL_JK_gc = (0x02<<0)        ; JK FlipFlop
  CCL_SEQSEL_LATCH_gc = (0x03<<0)     ; D Latch
  CCL_SEQSEL_RS_gc = (0x04<<0)        ; RS Latch
  
  
  ;*************************************************************************
  ;** CLKCTRL - Clock controller
  ;*************************************************************************
  
  ; CLKCTRL_MCLKCTRLA masks
  CLKCTRL_CLKSEL_gm = 0x07            ; Clock select group mask
  CLKCTRL_CLKSEL_gp = 0               ; Clock select group position
  CLKCTRL_CLKSEL_0_bm = (1<<0)        ; Clock select bit 0 mask
  CLKCTRL_CLKSEL_0_bp = 0             ; Clock select bit 0 position
  CLKCTRL_CLKSEL_1_bm = (1<<1)        ; Clock select bit 1 mask
  CLKCTRL_CLKSEL_1_bp = 1             ; Clock select bit 1 position
  CLKCTRL_CLKSEL_2_bm = (1<<2)        ; Clock select bit 2 mask
  CLKCTRL_CLKSEL_2_bp = 2             ; Clock select bit 2 position
  CLKCTRL_CLKOUT_bm = 0x80            ; System clock out bit mask
  CLKCTRL_CLKOUT_bp = 7               ; System clock out bit position
  
  ; CLKCTRL_MCLKCTRLB masks
  CLKCTRL_PEN_bm = 0x01               ; Prescaler enable bit mask
  CLKCTRL_PEN_bp = 0                  ; Prescaler enable bit position
  CLKCTRL_PDIV_gm = 0x1E              ; Prescaler division group mask
  CLKCTRL_PDIV_gp = 1                 ; Prescaler division group position
  CLKCTRL_PDIV_0_bm = (1<<1)          ; Prescaler division bit 0 mask
  CLKCTRL_PDIV_0_bp = 1               ; Prescaler division bit 0 position
  CLKCTRL_PDIV_1_bm = (1<<2)          ; Prescaler division bit 1 mask
  CLKCTRL_PDIV_1_bp = 2               ; Prescaler division bit 1 position
  CLKCTRL_PDIV_2_bm = (1<<3)          ; Prescaler division bit 2 mask
  CLKCTRL_PDIV_2_bp = 3               ; Prescaler division bit 2 position
  CLKCTRL_PDIV_3_bm = (1<<4)          ; Prescaler division bit 3 mask
  CLKCTRL_PDIV_3_bp = 4               ; Prescaler division bit 3 position
  
  ; CLKCTRL_MCLKCTRLC masks
  CLKCTRL_CFDEN_bm = 0x01             ; Clock Failure Detect Enable bit mask
  CLKCTRL_CFDEN_bp = 0                ; Clock Failure Detect Enable bit position
  CLKCTRL_CFDTST_bm = 0x02            ; Clock Failure Detect Test bit mask
  CLKCTRL_CFDTST_bp = 1               ; Clock Failure Detect Test bit position
  CLKCTRL_CFDSRC_gm = 0x0C            ; Clock Failure Detect Source group mask
  CLKCTRL_CFDSRC_gp = 2               ; Clock Failure Detect Source group position
  CLKCTRL_CFDSRC_0_bm = (1<<2)        ; Clock Failure Detect Source bit 0 mask
  CLKCTRL_CFDSRC_0_bp = 2             ; Clock Failure Detect Source bit 0 position
  CLKCTRL_CFDSRC_1_bm = (1<<3)        ; Clock Failure Detect Source bit 1 mask
  CLKCTRL_CFDSRC_1_bp = 3             ; Clock Failure Detect Source bit 1 position
  
  ; CLKCTRL_MCLKINTCTRL masks
  CLKCTRL_CFD_bm = 0x01               ; Clock Failure Detect Interrupt Enable bit mask
  CLKCTRL_CFD_bp = 0                  ; Clock Failure Detect Interrupt Enable bit position
  CLKCTRL_INTTYPE_bm = 0x80           ; Interrupt type bit mask
  CLKCTRL_INTTYPE_bp = 7              ; Interrupt type bit position
  
  ; CLKCTRL_MCLKINTFLAGS masks
  ; Masks for CLKCTRL_CFD already defined
  
  ; CLKCTRL_MCLKSTATUS masks
  CLKCTRL_SOSC_bm = 0x01              ; System Oscillator changing bit mask
  CLKCTRL_SOSC_bp = 0                 ; System Oscillator changing bit position
  CLKCTRL_OSCHFS_bm = 0x02            ; High frequency oscillator status bit mask
  CLKCTRL_OSCHFS_bp = 1               ; High frequency oscillator status bit position
  CLKCTRL_OSC32KS_bm = 0x04           ; 32KHz oscillator status bit mask
  CLKCTRL_OSC32KS_bp = 2              ; 32KHz oscillator status bit position
  CLKCTRL_XOSC32KS_bm = 0x08          ; 32.768 kHz Crystal Oscillator status bit mask
  CLKCTRL_XOSC32KS_bp = 3             ; 32.768 kHz Crystal Oscillator status bit position
  CLKCTRL_EXTS_bm = 0x10              ; External Clock status bit mask
  CLKCTRL_EXTS_bp = 4                 ; External Clock status bit position
  CLKCTRL_PLLS_bm = 0x20              ; PLL oscillator status bit mask
  CLKCTRL_PLLS_bp = 5                 ; PLL oscillator status bit position
  
  ; CLKCTRL_OSCHFCTRLA masks
  CLKCTRL_AUTOTUNE_bm = 0x01          ; Autotune bit mask
  CLKCTRL_AUTOTUNE_bp = 0             ; Autotune bit position
  CLKCTRL_FRQSEL_gm = 0x3C            ; Frequency select group mask
  CLKCTRL_FRQSEL_gp = 2               ; Frequency select group position
  CLKCTRL_FRQSEL_0_bm = (1<<2)        ; Frequency select bit 0 mask
  CLKCTRL_FRQSEL_0_bp = 2             ; Frequency select bit 0 position
  CLKCTRL_FRQSEL_1_bm = (1<<3)        ; Frequency select bit 1 mask
  CLKCTRL_FRQSEL_1_bp = 3             ; Frequency select bit 1 position
  CLKCTRL_FRQSEL_2_bm = (1<<4)        ; Frequency select bit 2 mask
  CLKCTRL_FRQSEL_2_bp = 4             ; Frequency select bit 2 position
  CLKCTRL_FRQSEL_3_bm = (1<<5)        ; Frequency select bit 3 mask
  CLKCTRL_FRQSEL_3_bp = 5             ; Frequency select bit 3 position
  CLKCTRL_RUNSTDBY_bm = 0x80          ; Run standby bit mask
  CLKCTRL_RUNSTDBY_bp = 7             ; Run standby bit position
  
  ; CLKCTRL_OSCHFTUNE masks
  CLKCTRL_TUNE_gm = 0xFF              ; Tune group mask
  CLKCTRL_TUNE_gp = 0                 ; Tune group position
  CLKCTRL_TUNE_0_bm = (1<<0)          ; Tune bit 0 mask
  CLKCTRL_TUNE_0_bp = 0               ; Tune bit 0 position
  CLKCTRL_TUNE_1_bm = (1<<1)          ; Tune bit 1 mask
  CLKCTRL_TUNE_1_bp = 1               ; Tune bit 1 position
  CLKCTRL_TUNE_2_bm = (1<<2)          ; Tune bit 2 mask
  CLKCTRL_TUNE_2_bp = 2               ; Tune bit 2 position
  CLKCTRL_TUNE_3_bm = (1<<3)          ; Tune bit 3 mask
  CLKCTRL_TUNE_3_bp = 3               ; Tune bit 3 position
  CLKCTRL_TUNE_4_bm = (1<<4)          ; Tune bit 4 mask
  CLKCTRL_TUNE_4_bp = 4               ; Tune bit 4 position
  CLKCTRL_TUNE_5_bm = (1<<5)          ; Tune bit 5 mask
  CLKCTRL_TUNE_5_bp = 5               ; Tune bit 5 position
  CLKCTRL_TUNE_6_bm = (1<<6)          ; Tune bit 6 mask
  CLKCTRL_TUNE_6_bp = 6               ; Tune bit 6 position
  CLKCTRL_TUNE_7_bm = (1<<7)          ; Tune bit 7 mask
  CLKCTRL_TUNE_7_bp = 7               ; Tune bit 7 position
  
  ; CLKCTRL_PLLCTRLA masks
  CLKCTRL_MULFAC_gm = 0x03            ; Multiplication factor group mask
  CLKCTRL_MULFAC_gp = 0               ; Multiplication factor group position
  CLKCTRL_MULFAC_0_bm = (1<<0)        ; Multiplication factor bit 0 mask
  CLKCTRL_MULFAC_0_bp = 0             ; Multiplication factor bit 0 position
  CLKCTRL_MULFAC_1_bm = (1<<1)        ; Multiplication factor bit 1 mask
  CLKCTRL_MULFAC_1_bp = 1             ; Multiplication factor bit 1 position
  CLKCTRL_SOURCE_bm = 0x40            ; Source bit mask
  CLKCTRL_SOURCE_bp = 6               ; Source bit position
  ; Masks for CLKCTRL_RUNSTDBY already defined
  
  ; CLKCTRL_OSC32KCTRLA masks
  ; Masks for CLKCTRL_RUNSTDBY already defined
  
  ; CLKCTRL_XOSC32KCTRLA masks
  CLKCTRL_ENABLE_bm = 0x01            ; Enable bit mask
  CLKCTRL_ENABLE_bp = 0               ; Enable bit position
  CLKCTRL_LPMODE_bm = 0x02            ; Low power mode bit mask
  CLKCTRL_LPMODE_bp = 1               ; Low power mode bit position
  CLKCTRL_SEL_bm = 0x04               ; Select bit mask
  CLKCTRL_SEL_bp = 2                  ; Select bit position
  CLKCTRL_CSUT_gm = 0x30              ; Crystal startup time group mask
  CLKCTRL_CSUT_gp = 4                 ; Crystal startup time group position
  CLKCTRL_CSUT_0_bm = (1<<4)          ; Crystal startup time bit 0 mask
  CLKCTRL_CSUT_0_bp = 4               ; Crystal startup time bit 0 position
  CLKCTRL_CSUT_1_bm = (1<<5)          ; Crystal startup time bit 1 mask
  CLKCTRL_CSUT_1_bp = 5               ; Crystal startup time bit 1 position
  ; Masks for CLKCTRL_RUNSTDBY already defined
  
  ; CLKCTRL_XOSCHFCTRLA masks
  ; Masks for CLKCTRL_ENABLE already defined
  CLKCTRL_SELHF_bm = 0x02             ; External Source Select bit mask
  CLKCTRL_SELHF_bp = 1                ; External Source Select bit position
  CLKCTRL_FRQRANGE_gm = 0x0C          ; Frequency Range group mask
  CLKCTRL_FRQRANGE_gp = 2             ; Frequency Range group position
  CLKCTRL_FRQRANGE_0_bm = (1<<2)      ; Frequency Range bit 0 mask
  CLKCTRL_FRQRANGE_0_bp = 2           ; Frequency Range bit 0 position
  CLKCTRL_FRQRANGE_1_bm = (1<<3)      ; Frequency Range bit 1 mask
  CLKCTRL_FRQRANGE_1_bp = 3           ; Frequency Range bit 1 position
  CLKCTRL_CSUTHF_gm = 0x30            ; Start-up Time Select group mask
  CLKCTRL_CSUTHF_gp = 4               ; Start-up Time Select group position
  CLKCTRL_CSUTHF_0_bm = (1<<4)        ; Start-up Time Select bit 0 mask
  CLKCTRL_CSUTHF_0_bp = 4             ; Start-up Time Select bit 0 position
  CLKCTRL_CSUTHF_1_bm = (1<<5)        ; Start-up Time Select bit 1 mask
  CLKCTRL_CSUTHF_1_bp = 5             ; Start-up Time Select bit 1 position
  CLKCTRL_RUNSTBY_bm = 0x80           ; Run Standby bit mask
  CLKCTRL_RUNSTBY_bp = 7              ; Run Standby bit position
  
  ; Clock select
  CLKCTRL_CLKSEL_OSCHF_gc = (0x00<<0) ; Internal high-frequency oscillator
  CLKCTRL_CLKSEL_OSC32K_gc = (0x01<<0) ; Internal 32.768 kHz oscillator
  CLKCTRL_CLKSEL_XOSC32K_gc = (0x02<<0) ; 32.768 kHz crystal oscillator
  CLKCTRL_CLKSEL_EXTCLK_gc = (0x03<<0) ; External clock
  
  ; Prescaler division select
  CLKCTRL_PDIV_2X_gc = (0x00<<1)      ; 2X
  CLKCTRL_PDIV_4X_gc = (0x01<<1)      ; 4X
  CLKCTRL_PDIV_8X_gc = (0x02<<1)      ; 8X
  CLKCTRL_PDIV_16X_gc = (0x03<<1)     ; 16X
  CLKCTRL_PDIV_32X_gc = (0x04<<1)     ; 32X
  CLKCTRL_PDIV_64X_gc = (0x05<<1)     ; 64X
  CLKCTRL_PDIV_6X_gc = (0x08<<1)      ; 6X
  CLKCTRL_PDIV_10X_gc = (0x09<<1)     ; 10X
  CLKCTRL_PDIV_12X_gc = (0x0A<<1)     ; 12X
  CLKCTRL_PDIV_24X_gc = (0x0B<<1)     ; 24X
  CLKCTRL_PDIV_48X_gc = (0x0C<<1)     ; 48X
  
  ; Clock Failure Detect Source select
  CLKCTRL_CFDSRC_CLKMAIN_gc = (0x00<<2) ; Main Clock
  CLKCTRL_CFDSRC_XOSCHF_gc = (0x01<<2) ; XOSCHF
  CLKCTRL_CFDSRC_XOSC32K_gc = (0x02<<2) ; XOSC32K
  
  ; Interrupt type select
  CLKCTRL_INTTYPE_INT_gc = (0x00<<7)  ; Regular Interrupt
  CLKCTRL_INTTYPE_NMI_gc = (0x01<<7)  ; NMI
  
  ; Frequency select
  CLKCTRL_FRQSEL_1M_gc = (0x00<<2)    ; 1 MHz system clock
  CLKCTRL_FRQSEL_2M_gc = (0x01<<2)    ; 2 MHz system clock
  CLKCTRL_FRQSEL_3M_gc = (0x02<<2)    ; 3 MHz system clock
  CLKCTRL_FRQSEL_4M_gc = (0x03<<2)    ; 4 MHz system clock (default)
  CLKCTRL_FRQSEL_8M_gc = (0x05<<2)    ; 8 MHz system clock
  CLKCTRL_FRQSEL_12M_gc = (0x06<<2)   ; 12 MHz system clock
  CLKCTRL_FRQSEL_16M_gc = (0x07<<2)   ; 16 MHz system clock
  CLKCTRL_FRQSEL_20M_gc = (0x08<<2)   ; 20 MHz system clock
  CLKCTRL_FRQSEL_24M_gc = (0x09<<2)   ; 24 MHz system clock
  
  ; Multiplication factor select
  CLKCTRL_MULFAC_DISABLE_gc = (0x00<<0) ; PLL is disabled
  CLKCTRL_MULFAC_2x_gc = (0x01<<0)    ; 2 x multiplication factor
  CLKCTRL_MULFAC_3x_gc = (0x02<<0)    ; 3 x multiplication factor
  
  ; Source select
  CLKCTRL_SOURCE_OSCHF_gc = (0x00<<6) ; High frequency internal oscillator as PLL source
  CLKCTRL_SOURCE_XOSCHF_gc = (0x01<<6) ; High frequency external clock or external high frequency oscillator as PLL source
  
  ; Start-up Time Select
  CLKCTRL_CSUTHF_256_gc = (0x00<<4)   ; 256 XOSCHF cycles
  CLKCTRL_CSUTHF_1K_gc = (0x01<<4)    ; 1K XOSCHF cycles
  CLKCTRL_CSUTHF_4K_gc = (0x02<<4)    ; 4K XOSCHF cycles
  
  ; Frequency Range select
  CLKCTRL_FRQRANGE_8M_gc = (0x00<<2)  ; Max 8 MHz XTAL Frequency
  CLKCTRL_FRQRANGE_16M_gc = (0x01<<2) ; Max 16 MHz XTAL Frequency
  CLKCTRL_FRQRANGE_24M_gc = (0x02<<2) ; Max 24 MHz XTAL Frequency
  CLKCTRL_FRQRANGE_32M_gc = (0x03<<2) ; Max 32 MHz XTAL Frequency
  
  ; External Source Select
  CLKCTRL_SELHF_XTAL_gc = (0x00<<1)   ; External Crystal
  CLKCTRL_SELHF_EXTCLOCK_gc = (0x01<<1) ; External clock on XTALHF1 pin
  
  ; Crystal startup time select
  CLKCTRL_CSUT_1K_gc = (0x00<<4)      ; 1k cycles
  CLKCTRL_CSUT_16K_gc = (0x01<<4)     ; 16k cycles
  CLKCTRL_CSUT_32K_gc = (0x02<<4)     ; 32k cycles
  CLKCTRL_CSUT_64K_gc = (0x03<<4)     ; 64k cycles
  
  
  ;*************************************************************************
  ;** CPU - CPU
  ;*************************************************************************
  
  ; CPU_CCP masks
  CPU_CCP_gm = 0xFF                   ; CCP signature group mask
  CPU_CCP_gp = 0                      ; CCP signature group position
  CPU_CCP_0_bm = (1<<0)               ; CCP signature bit 0 mask
  CPU_CCP_0_bp = 0                    ; CCP signature bit 0 position
  CPU_CCP_1_bm = (1<<1)               ; CCP signature bit 1 mask
  CPU_CCP_1_bp = 1                    ; CCP signature bit 1 position
  CPU_CCP_2_bm = (1<<2)               ; CCP signature bit 2 mask
  CPU_CCP_2_bp = 2                    ; CCP signature bit 2 position
  CPU_CCP_3_bm = (1<<3)               ; CCP signature bit 3 mask
  CPU_CCP_3_bp = 3                    ; CCP signature bit 3 position
  CPU_CCP_4_bm = (1<<4)               ; CCP signature bit 4 mask
  CPU_CCP_4_bp = 4                    ; CCP signature bit 4 position
  CPU_CCP_5_bm = (1<<5)               ; CCP signature bit 5 mask
  CPU_CCP_5_bp = 5                    ; CCP signature bit 5 position
  CPU_CCP_6_bm = (1<<6)               ; CCP signature bit 6 mask
  CPU_CCP_6_bp = 6                    ; CCP signature bit 6 position
  CPU_CCP_7_bm = (1<<7)               ; CCP signature bit 7 mask
  CPU_CCP_7_bp = 7                    ; CCP signature bit 7 position
  
  ; CPU_SREG masks
  CPU_C_bm = 0x01                     ; Carry Flag bit mask
  CPU_C_bp = 0                        ; Carry Flag bit position
  CPU_Z_bm = 0x02                     ; Zero Flag bit mask
  CPU_Z_bp = 1                        ; Zero Flag bit position
  CPU_N_bm = 0x04                     ; Negative Flag bit mask
  CPU_N_bp = 2                        ; Negative Flag bit position
  CPU_V_bm = 0x08                     ; Two's Complement Overflow Flag bit mask
  CPU_V_bp = 3                        ; Two's Complement Overflow Flag bit position
  CPU_S_bm = 0x10                     ; N Exclusive Or V Flag bit mask
  CPU_S_bp = 4                        ; N Exclusive Or V Flag bit position
  CPU_H_bm = 0x20                     ; Half Carry Flag bit mask
  CPU_H_bp = 5                        ; Half Carry Flag bit position
  CPU_T_bm = 0x40                     ; Transfer Bit bit mask
  CPU_T_bp = 6                        ; Transfer Bit bit position
  CPU_I_bm = 0x80                     ; Global Interrupt Enable Flag bit mask
  CPU_I_bp = 7                        ; Global Interrupt Enable Flag bit position
  
  ; CCP signature select
  CPU_CCP_SPM_gc = (0x9D<<0)          ; SPM Instruction Protection
  CPU_CCP_IOREG_gc = (0xD8<<0)        ; IO Register Protection
  
  
  ;*************************************************************************
  ;** CPUINT - Interrupt Controller
  ;*************************************************************************
  
  ; CPUINT_CTRLA masks
  CPUINT_LVL0RR_bm = 0x01             ; Round-robin Scheduling Enable bit mask
  CPUINT_LVL0RR_bp = 0                ; Round-robin Scheduling Enable bit position
  CPUINT_CVT_bm = 0x20                ; Compact Vector Table bit mask
  CPUINT_CVT_bp = 5                   ; Compact Vector Table bit position
  CPUINT_IVSEL_bm = 0x40              ; Interrupt Vector Select bit mask
  CPUINT_IVSEL_bp = 6                 ; Interrupt Vector Select bit position
  
  ; CPUINT_STATUS masks
  CPUINT_LVL0EX_bm = 0x01             ; Level 0 Interrupt Executing bit mask
  CPUINT_LVL0EX_bp = 0                ; Level 0 Interrupt Executing bit position
  CPUINT_LVL1EX_bm = 0x02             ; Level 1 Interrupt Executing bit mask
  CPUINT_LVL1EX_bp = 1                ; Level 1 Interrupt Executing bit position
  CPUINT_NMIEX_bm = 0x80              ; Non-maskable Interrupt Executing bit mask
  CPUINT_NMIEX_bp = 7                 ; Non-maskable Interrupt Executing bit position
  
  ; CPUINT_LVL0PRI masks
  CPUINT_LVL0PRI_gm = 0xFF            ; Interrupt Level Priority group mask
  CPUINT_LVL0PRI_gp = 0               ; Interrupt Level Priority group position
  CPUINT_LVL0PRI_0_bm = (1<<0)        ; Interrupt Level Priority bit 0 mask
  CPUINT_LVL0PRI_0_bp = 0             ; Interrupt Level Priority bit 0 position
  CPUINT_LVL0PRI_1_bm = (1<<1)        ; Interrupt Level Priority bit 1 mask
  CPUINT_LVL0PRI_1_bp = 1             ; Interrupt Level Priority bit 1 position
  CPUINT_LVL0PRI_2_bm = (1<<2)        ; Interrupt Level Priority bit 2 mask
  CPUINT_LVL0PRI_2_bp = 2             ; Interrupt Level Priority bit 2 position
  CPUINT_LVL0PRI_3_bm = (1<<3)        ; Interrupt Level Priority bit 3 mask
  CPUINT_LVL0PRI_3_bp = 3             ; Interrupt Level Priority bit 3 position
  CPUINT_LVL0PRI_4_bm = (1<<4)        ; Interrupt Level Priority bit 4 mask
  CPUINT_LVL0PRI_4_bp = 4             ; Interrupt Level Priority bit 4 position
  CPUINT_LVL0PRI_5_bm = (1<<5)        ; Interrupt Level Priority bit 5 mask
  CPUINT_LVL0PRI_5_bp = 5             ; Interrupt Level Priority bit 5 position
  CPUINT_LVL0PRI_6_bm = (1<<6)        ; Interrupt Level Priority bit 6 mask
  CPUINT_LVL0PRI_6_bp = 6             ; Interrupt Level Priority bit 6 position
  CPUINT_LVL0PRI_7_bm = (1<<7)        ; Interrupt Level Priority bit 7 mask
  CPUINT_LVL0PRI_7_bp = 7             ; Interrupt Level Priority bit 7 position
  
  ; CPUINT_LVL1VEC masks
  CPUINT_LVL1VEC_gm = 0xFF            ; Interrupt Vector with High Priority group mask
  CPUINT_LVL1VEC_gp = 0               ; Interrupt Vector with High Priority group position
  CPUINT_LVL1VEC_0_bm = (1<<0)        ; Interrupt Vector with High Priority bit 0 mask
  CPUINT_LVL1VEC_0_bp = 0             ; Interrupt Vector with High Priority bit 0 position
  CPUINT_LVL1VEC_1_bm = (1<<1)        ; Interrupt Vector with High Priority bit 1 mask
  CPUINT_LVL1VEC_1_bp = 1             ; Interrupt Vector with High Priority bit 1 position
  CPUINT_LVL1VEC_2_bm = (1<<2)        ; Interrupt Vector with High Priority bit 2 mask
  CPUINT_LVL1VEC_2_bp = 2             ; Interrupt Vector with High Priority bit 2 position
  CPUINT_LVL1VEC_3_bm = (1<<3)        ; Interrupt Vector with High Priority bit 3 mask
  CPUINT_LVL1VEC_3_bp = 3             ; Interrupt Vector with High Priority bit 3 position
  CPUINT_LVL1VEC_4_bm = (1<<4)        ; Interrupt Vector with High Priority bit 4 mask
  CPUINT_LVL1VEC_4_bp = 4             ; Interrupt Vector with High Priority bit 4 position
  CPUINT_LVL1VEC_5_bm = (1<<5)        ; Interrupt Vector with High Priority bit 5 mask
  CPUINT_LVL1VEC_5_bp = 5             ; Interrupt Vector with High Priority bit 5 position
  CPUINT_LVL1VEC_6_bm = (1<<6)        ; Interrupt Vector with High Priority bit 6 mask
  CPUINT_LVL1VEC_6_bp = 6             ; Interrupt Vector with High Priority bit 6 position
  CPUINT_LVL1VEC_7_bm = (1<<7)        ; Interrupt Vector with High Priority bit 7 mask
  CPUINT_LVL1VEC_7_bp = 7             ; Interrupt Vector with High Priority bit 7 position
  
  
  ;*************************************************************************
  ;** CRCSCAN - CRCSCAN
  ;*************************************************************************
  
  ; CRCSCAN_CTRLA masks
  CRCSCAN_ENABLE_bm = 0x01            ; Enable CRC scan bit mask
  CRCSCAN_ENABLE_bp = 0               ; Enable CRC scan bit position
  CRCSCAN_NMIEN_bm = 0x02             ; Enable NMI Trigger bit mask
  CRCSCAN_NMIEN_bp = 1                ; Enable NMI Trigger bit position
  CRCSCAN_RESET_bm = 0x80             ; Reset CRC scan bit mask
  CRCSCAN_RESET_bp = 7                ; Reset CRC scan bit position
  
  ; CRCSCAN_CTRLB masks
  CRCSCAN_SRC_gm = 0x03               ; CRC Source group mask
  CRCSCAN_SRC_gp = 0                  ; CRC Source group position
  CRCSCAN_SRC_0_bm = (1<<0)           ; CRC Source bit 0 mask
  CRCSCAN_SRC_0_bp = 0                ; CRC Source bit 0 position
  CRCSCAN_SRC_1_bm = (1<<1)           ; CRC Source bit 1 mask
  CRCSCAN_SRC_1_bp = 1                ; CRC Source bit 1 position
  
  ; CRCSCAN_STATUS masks
  CRCSCAN_BUSY_bm = 0x01              ; CRC Busy bit mask
  CRCSCAN_BUSY_bp = 0                 ; CRC Busy bit position
  CRCSCAN_OK_bm = 0x02                ; CRC Ok bit mask
  CRCSCAN_OK_bp = 1                   ; CRC Ok bit position
  
  ; CRC Source select
  CRCSCAN_SRC_FLASH_gc = (0x00<<0)    ; CRC on entire flash
  CRCSCAN_SRC_APPLICATION_gc = (0x01<<0) ; CRC on boot and appl section of flash
  CRCSCAN_SRC_BOOT_gc = (0x02<<0)     ; CRC on boot section of flash
  
  
  ;*************************************************************************
  ;** DAC - Digital to Analog Converter
  ;*************************************************************************
  
  ; DAC_CTRLA masks
  DAC_ENABLE_bm = 0x01                ; DAC Enable bit mask
  DAC_ENABLE_bp = 0                   ; DAC Enable bit position
  DAC_OUTEN_bm = 0x40                 ; Output Buffer Enable bit mask
  DAC_OUTEN_bp = 6                    ; Output Buffer Enable bit position
  DAC_RUNSTDBY_bm = 0x80              ; Run in Standby Mode bit mask
  DAC_RUNSTDBY_bp = 7                 ; Run in Standby Mode bit position
  
  ; DAC_DATA masks
  DAC_DATA_gm = 0xFFC0                ; Data group mask
  DAC_DATA_gp = 6                     ; Data group position
  DAC_DATA_0_bm = (1<<6)              ; Data bit 0 mask
  DAC_DATA_0_bp = 6                   ; Data bit 0 position
  DAC_DATA_1_bm = (1<<7)              ; Data bit 1 mask
  DAC_DATA_1_bp = 7                   ; Data bit 1 position
  DAC_DATA_2_bm = (1<<8)              ; Data bit 2 mask
  DAC_DATA_2_bp = 8                   ; Data bit 2 position
  DAC_DATA_3_bm = (1<<9)              ; Data bit 3 mask
  DAC_DATA_3_bp = 9                   ; Data bit 3 position
  DAC_DATA_4_bm = (1<<10)             ; Data bit 4 mask
  DAC_DATA_4_bp = 10                  ; Data bit 4 position
  DAC_DATA_5_bm = (1<<11)             ; Data bit 5 mask
  DAC_DATA_5_bp = 11                  ; Data bit 5 position
  DAC_DATA_6_bm = (1<<12)             ; Data bit 6 mask
  DAC_DATA_6_bp = 12                  ; Data bit 6 position
  DAC_DATA_7_bm = (1<<13)             ; Data bit 7 mask
  DAC_DATA_7_bp = 13                  ; Data bit 7 position
  DAC_DATA_8_bm = (1<<14)             ; Data bit 8 mask
  DAC_DATA_8_bp = 14                  ; Data bit 8 position
  DAC_DATA_9_bm = (1<<15)             ; Data bit 9 mask
  DAC_DATA_9_bp = 15                  ; Data bit 9 position
  
  
  ;*************************************************************************
  ;** EVSYS - Event System
  ;*************************************************************************
  
  ; EVSYS_SWEVENTA masks
  EVSYS_SWEVENTA_gm = 0xFF            ; Software event on channel select group mask
  EVSYS_SWEVENTA_gp = 0               ; Software event on channel select group position
  EVSYS_SWEVENTA_0_bm = (1<<0)        ; Software event on channel select bit 0 mask
  EVSYS_SWEVENTA_0_bp = 0             ; Software event on channel select bit 0 position
  EVSYS_SWEVENTA_1_bm = (1<<1)        ; Software event on channel select bit 1 mask
  EVSYS_SWEVENTA_1_bp = 1             ; Software event on channel select bit 1 position
  EVSYS_SWEVENTA_2_bm = (1<<2)        ; Software event on channel select bit 2 mask
  EVSYS_SWEVENTA_2_bp = 2             ; Software event on channel select bit 2 position
  EVSYS_SWEVENTA_3_bm = (1<<3)        ; Software event on channel select bit 3 mask
  EVSYS_SWEVENTA_3_bp = 3             ; Software event on channel select bit 3 position
  EVSYS_SWEVENTA_4_bm = (1<<4)        ; Software event on channel select bit 4 mask
  EVSYS_SWEVENTA_4_bp = 4             ; Software event on channel select bit 4 position
  EVSYS_SWEVENTA_5_bm = (1<<5)        ; Software event on channel select bit 5 mask
  EVSYS_SWEVENTA_5_bp = 5             ; Software event on channel select bit 5 position
  EVSYS_SWEVENTA_6_bm = (1<<6)        ; Software event on channel select bit 6 mask
  EVSYS_SWEVENTA_6_bp = 6             ; Software event on channel select bit 6 position
  EVSYS_SWEVENTA_7_bm = (1<<7)        ; Software event on channel select bit 7 mask
  EVSYS_SWEVENTA_7_bp = 7             ; Software event on channel select bit 7 position
  
  ; EVSYS_SWEVENTB masks
  EVSYS_SWEVENTB_gm = 0x03            ; Software event on channel select group mask
  EVSYS_SWEVENTB_gp = 0               ; Software event on channel select group position
  EVSYS_SWEVENTB_0_bm = (1<<0)        ; Software event on channel select bit 0 mask
  EVSYS_SWEVENTB_0_bp = 0             ; Software event on channel select bit 0 position
  EVSYS_SWEVENTB_1_bm = (1<<1)        ; Software event on channel select bit 1 mask
  EVSYS_SWEVENTB_1_bp = 1             ; Software event on channel select bit 1 position
  
  ; EVSYS_CHANNEL0 masks
  EVSYS_CHANNEL0_gm = 0xFF            ; Channel 0 generator select group mask
  EVSYS_CHANNEL0_gp = 0               ; Channel 0 generator select group position
  EVSYS_CHANNEL0_0_bm = (1<<0)        ; Channel 0 generator select bit 0 mask
  EVSYS_CHANNEL0_0_bp = 0             ; Channel 0 generator select bit 0 position
  EVSYS_CHANNEL0_1_bm = (1<<1)        ; Channel 0 generator select bit 1 mask
  EVSYS_CHANNEL0_1_bp = 1             ; Channel 0 generator select bit 1 position
  EVSYS_CHANNEL0_2_bm = (1<<2)        ; Channel 0 generator select bit 2 mask
  EVSYS_CHANNEL0_2_bp = 2             ; Channel 0 generator select bit 2 position
  EVSYS_CHANNEL0_3_bm = (1<<3)        ; Channel 0 generator select bit 3 mask
  EVSYS_CHANNEL0_3_bp = 3             ; Channel 0 generator select bit 3 position
  EVSYS_CHANNEL0_4_bm = (1<<4)        ; Channel 0 generator select bit 4 mask
  EVSYS_CHANNEL0_4_bp = 4             ; Channel 0 generator select bit 4 position
  EVSYS_CHANNEL0_5_bm = (1<<5)        ; Channel 0 generator select bit 5 mask
  EVSYS_CHANNEL0_5_bp = 5             ; Channel 0 generator select bit 5 position
  EVSYS_CHANNEL0_6_bm = (1<<6)        ; Channel 0 generator select bit 6 mask
  EVSYS_CHANNEL0_6_bp = 6             ; Channel 0 generator select bit 6 position
  EVSYS_CHANNEL0_7_bm = (1<<7)        ; Channel 0 generator select bit 7 mask
  EVSYS_CHANNEL0_7_bp = 7             ; Channel 0 generator select bit 7 position
  
  ; EVSYS_CHANNEL1 masks
  EVSYS_CHANNEL1_gm = 0xFF            ; Channel 1 generator select group mask
  EVSYS_CHANNEL1_gp = 0               ; Channel 1 generator select group position
  EVSYS_CHANNEL1_0_bm = (1<<0)        ; Channel 1 generator select bit 0 mask
  EVSYS_CHANNEL1_0_bp = 0             ; Channel 1 generator select bit 0 position
  EVSYS_CHANNEL1_1_bm = (1<<1)        ; Channel 1 generator select bit 1 mask
  EVSYS_CHANNEL1_1_bp = 1             ; Channel 1 generator select bit 1 position
  EVSYS_CHANNEL1_2_bm = (1<<2)        ; Channel 1 generator select bit 2 mask
  EVSYS_CHANNEL1_2_bp = 2             ; Channel 1 generator select bit 2 position
  EVSYS_CHANNEL1_3_bm = (1<<3)        ; Channel 1 generator select bit 3 mask
  EVSYS_CHANNEL1_3_bp = 3             ; Channel 1 generator select bit 3 position
  EVSYS_CHANNEL1_4_bm = (1<<4)        ; Channel 1 generator select bit 4 mask
  EVSYS_CHANNEL1_4_bp = 4             ; Channel 1 generator select bit 4 position
  EVSYS_CHANNEL1_5_bm = (1<<5)        ; Channel 1 generator select bit 5 mask
  EVSYS_CHANNEL1_5_bp = 5             ; Channel 1 generator select bit 5 position
  EVSYS_CHANNEL1_6_bm = (1<<6)        ; Channel 1 generator select bit 6 mask
  EVSYS_CHANNEL1_6_bp = 6             ; Channel 1 generator select bit 6 position
  EVSYS_CHANNEL1_7_bm = (1<<7)        ; Channel 1 generator select bit 7 mask
  EVSYS_CHANNEL1_7_bp = 7             ; Channel 1 generator select bit 7 position
  
  ; EVSYS_CHANNEL2 masks
  EVSYS_CHANNEL2_gm = 0xFF            ; Channel 2 generator select group mask
  EVSYS_CHANNEL2_gp = 0               ; Channel 2 generator select group position
  EVSYS_CHANNEL2_0_bm = (1<<0)        ; Channel 2 generator select bit 0 mask
  EVSYS_CHANNEL2_0_bp = 0             ; Channel 2 generator select bit 0 position
  EVSYS_CHANNEL2_1_bm = (1<<1)        ; Channel 2 generator select bit 1 mask
  EVSYS_CHANNEL2_1_bp = 1             ; Channel 2 generator select bit 1 position
  EVSYS_CHANNEL2_2_bm = (1<<2)        ; Channel 2 generator select bit 2 mask
  EVSYS_CHANNEL2_2_bp = 2             ; Channel 2 generator select bit 2 position
  EVSYS_CHANNEL2_3_bm = (1<<3)        ; Channel 2 generator select bit 3 mask
  EVSYS_CHANNEL2_3_bp = 3             ; Channel 2 generator select bit 3 position
  EVSYS_CHANNEL2_4_bm = (1<<4)        ; Channel 2 generator select bit 4 mask
  EVSYS_CHANNEL2_4_bp = 4             ; Channel 2 generator select bit 4 position
  EVSYS_CHANNEL2_5_bm = (1<<5)        ; Channel 2 generator select bit 5 mask
  EVSYS_CHANNEL2_5_bp = 5             ; Channel 2 generator select bit 5 position
  EVSYS_CHANNEL2_6_bm = (1<<6)        ; Channel 2 generator select bit 6 mask
  EVSYS_CHANNEL2_6_bp = 6             ; Channel 2 generator select bit 6 position
  EVSYS_CHANNEL2_7_bm = (1<<7)        ; Channel 2 generator select bit 7 mask
  EVSYS_CHANNEL2_7_bp = 7             ; Channel 2 generator select bit 7 position
  
  ; EVSYS_CHANNEL3 masks
  EVSYS_CHANNEL3_gm = 0xFF            ; Channel 3 generator select group mask
  EVSYS_CHANNEL3_gp = 0               ; Channel 3 generator select group position
  EVSYS_CHANNEL3_0_bm = (1<<0)        ; Channel 3 generator select bit 0 mask
  EVSYS_CHANNEL3_0_bp = 0             ; Channel 3 generator select bit 0 position
  EVSYS_CHANNEL3_1_bm = (1<<1)        ; Channel 3 generator select bit 1 mask
  EVSYS_CHANNEL3_1_bp = 1             ; Channel 3 generator select bit 1 position
  EVSYS_CHANNEL3_2_bm = (1<<2)        ; Channel 3 generator select bit 2 mask
  EVSYS_CHANNEL3_2_bp = 2             ; Channel 3 generator select bit 2 position
  EVSYS_CHANNEL3_3_bm = (1<<3)        ; Channel 3 generator select bit 3 mask
  EVSYS_CHANNEL3_3_bp = 3             ; Channel 3 generator select bit 3 position
  EVSYS_CHANNEL3_4_bm = (1<<4)        ; Channel 3 generator select bit 4 mask
  EVSYS_CHANNEL3_4_bp = 4             ; Channel 3 generator select bit 4 position
  EVSYS_CHANNEL3_5_bm = (1<<5)        ; Channel 3 generator select bit 5 mask
  EVSYS_CHANNEL3_5_bp = 5             ; Channel 3 generator select bit 5 position
  EVSYS_CHANNEL3_6_bm = (1<<6)        ; Channel 3 generator select bit 6 mask
  EVSYS_CHANNEL3_6_bp = 6             ; Channel 3 generator select bit 6 position
  EVSYS_CHANNEL3_7_bm = (1<<7)        ; Channel 3 generator select bit 7 mask
  EVSYS_CHANNEL3_7_bp = 7             ; Channel 3 generator select bit 7 position
  
  ; EVSYS_CHANNEL4 masks
  EVSYS_CHANNEL4_gm = 0xFF            ; Channel 4 generator select group mask
  EVSYS_CHANNEL4_gp = 0               ; Channel 4 generator select group position
  EVSYS_CHANNEL4_0_bm = (1<<0)        ; Channel 4 generator select bit 0 mask
  EVSYS_CHANNEL4_0_bp = 0             ; Channel 4 generator select bit 0 position
  EVSYS_CHANNEL4_1_bm = (1<<1)        ; Channel 4 generator select bit 1 mask
  EVSYS_CHANNEL4_1_bp = 1             ; Channel 4 generator select bit 1 position
  EVSYS_CHANNEL4_2_bm = (1<<2)        ; Channel 4 generator select bit 2 mask
  EVSYS_CHANNEL4_2_bp = 2             ; Channel 4 generator select bit 2 position
  EVSYS_CHANNEL4_3_bm = (1<<3)        ; Channel 4 generator select bit 3 mask
  EVSYS_CHANNEL4_3_bp = 3             ; Channel 4 generator select bit 3 position
  EVSYS_CHANNEL4_4_bm = (1<<4)        ; Channel 4 generator select bit 4 mask
  EVSYS_CHANNEL4_4_bp = 4             ; Channel 4 generator select bit 4 position
  EVSYS_CHANNEL4_5_bm = (1<<5)        ; Channel 4 generator select bit 5 mask
  EVSYS_CHANNEL4_5_bp = 5             ; Channel 4 generator select bit 5 position
  EVSYS_CHANNEL4_6_bm = (1<<6)        ; Channel 4 generator select bit 6 mask
  EVSYS_CHANNEL4_6_bp = 6             ; Channel 4 generator select bit 6 position
  EVSYS_CHANNEL4_7_bm = (1<<7)        ; Channel 4 generator select bit 7 mask
  EVSYS_CHANNEL4_7_bp = 7             ; Channel 4 generator select bit 7 position
  
  ; EVSYS_CHANNEL5 masks
  EVSYS_CHANNEL5_gm = 0xFF            ; Channel 5 generator select group mask
  EVSYS_CHANNEL5_gp = 0               ; Channel 5 generator select group position
  EVSYS_CHANNEL5_0_bm = (1<<0)        ; Channel 5 generator select bit 0 mask
  EVSYS_CHANNEL5_0_bp = 0             ; Channel 5 generator select bit 0 position
  EVSYS_CHANNEL5_1_bm = (1<<1)        ; Channel 5 generator select bit 1 mask
  EVSYS_CHANNEL5_1_bp = 1             ; Channel 5 generator select bit 1 position
  EVSYS_CHANNEL5_2_bm = (1<<2)        ; Channel 5 generator select bit 2 mask
  EVSYS_CHANNEL5_2_bp = 2             ; Channel 5 generator select bit 2 position
  EVSYS_CHANNEL5_3_bm = (1<<3)        ; Channel 5 generator select bit 3 mask
  EVSYS_CHANNEL5_3_bp = 3             ; Channel 5 generator select bit 3 position
  EVSYS_CHANNEL5_4_bm = (1<<4)        ; Channel 5 generator select bit 4 mask
  EVSYS_CHANNEL5_4_bp = 4             ; Channel 5 generator select bit 4 position
  EVSYS_CHANNEL5_5_bm = (1<<5)        ; Channel 5 generator select bit 5 mask
  EVSYS_CHANNEL5_5_bp = 5             ; Channel 5 generator select bit 5 position
  EVSYS_CHANNEL5_6_bm = (1<<6)        ; Channel 5 generator select bit 6 mask
  EVSYS_CHANNEL5_6_bp = 6             ; Channel 5 generator select bit 6 position
  EVSYS_CHANNEL5_7_bm = (1<<7)        ; Channel 5 generator select bit 7 mask
  EVSYS_CHANNEL5_7_bp = 7             ; Channel 5 generator select bit 7 position
  
  ; EVSYS_USERCCLLUT0A masks
  EVSYS_USER_gm = 0xFF                ; User channel select group mask
  EVSYS_USER_gp = 0                   ; User channel select group position
  EVSYS_USER_0_bm = (1<<0)            ; User channel select bit 0 mask
  EVSYS_USER_0_bp = 0                 ; User channel select bit 0 position
  EVSYS_USER_1_bm = (1<<1)            ; User channel select bit 1 mask
  EVSYS_USER_1_bp = 1                 ; User channel select bit 1 position
  EVSYS_USER_2_bm = (1<<2)            ; User channel select bit 2 mask
  EVSYS_USER_2_bp = 2                 ; User channel select bit 2 position
  EVSYS_USER_3_bm = (1<<3)            ; User channel select bit 3 mask
  EVSYS_USER_3_bp = 3                 ; User channel select bit 3 position
  EVSYS_USER_4_bm = (1<<4)            ; User channel select bit 4 mask
  EVSYS_USER_4_bp = 4                 ; User channel select bit 4 position
  EVSYS_USER_5_bm = (1<<5)            ; User channel select bit 5 mask
  EVSYS_USER_5_bp = 5                 ; User channel select bit 5 position
  EVSYS_USER_6_bm = (1<<6)            ; User channel select bit 6 mask
  EVSYS_USER_6_bp = 6                 ; User channel select bit 6 position
  EVSYS_USER_7_bm = (1<<7)            ; User channel select bit 7 mask
  EVSYS_USER_7_bp = 7                 ; User channel select bit 7 position
  
  ; EVSYS_USERCCLLUT0B masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT1A masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT1B masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT2A masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT2B masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT3A masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERCCLLUT3B masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERADC0START masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USEREVSYSEVOUTA masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USEREVSYSEVOUTC masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USEREVSYSEVOUTD masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USEREVSYSEVOUTF masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERUSART0IRDA masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERUSART1IRDA masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCA0CNTA masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCA0CNTB masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB0CAPT masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB0COUNT masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB1CAPT masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB1COUNT masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB2CAPT masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCB2COUNT masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCD0INPUTA masks
  ; Masks for EVSYS_USER already defined
  
  ; EVSYS_USERTCD0INPUTB masks
  ; Masks for EVSYS_USER already defined
  
  ; Channel 0 generator select
  EVSYS_CHANNEL0_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL0_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
  EVSYS_CHANNEL0_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
  EVSYS_CHANNEL0_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL0_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL0_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL0_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL0_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL0_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL0_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL0_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL0_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL0_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL0_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL0_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
  EVSYS_CHANNEL0_ZCD3_gc = (0x30<<0)  ; Zero Cross Detect 3 out
  EVSYS_CHANNEL0_PORTA_PIN0_gc = (0x40<<0) ; Port A Pin 0
  EVSYS_CHANNEL0_PORTA_PIN1_gc = (0x41<<0) ; Port A Pin 1
  EVSYS_CHANNEL0_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL0_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL0_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
  EVSYS_CHANNEL0_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
  EVSYS_CHANNEL0_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
  EVSYS_CHANNEL0_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL0_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL0_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL0_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL0_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL0_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL0_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  EVSYS_CHANNEL0_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
  EVSYS_CHANNEL0_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
  EVSYS_CHANNEL0_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
  EVSYS_CHANNEL0_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
  EVSYS_CHANNEL0_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
  EVSYS_CHANNEL0_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
  
  ; Channel 1 generator select
  EVSYS_CHANNEL1_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL1_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
  EVSYS_CHANNEL1_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
  EVSYS_CHANNEL1_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL1_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL1_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL1_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL1_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL1_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL1_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL1_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL1_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL1_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL1_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL1_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
  EVSYS_CHANNEL1_ZCD3_gc = (0x30<<0)  ; Zero Cross Detect 3 out
  EVSYS_CHANNEL1_PORTA_PIN0_gc = (0x40<<0) ; Port A Pin 0
  EVSYS_CHANNEL1_PORTA_PIN1_gc = (0x41<<0) ; Port A Pin 1
  EVSYS_CHANNEL1_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL1_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL1_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
  EVSYS_CHANNEL1_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
  EVSYS_CHANNEL1_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
  EVSYS_CHANNEL1_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL1_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL1_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL1_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL1_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL1_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL1_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  EVSYS_CHANNEL1_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
  EVSYS_CHANNEL1_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
  EVSYS_CHANNEL1_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
  EVSYS_CHANNEL1_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
  EVSYS_CHANNEL1_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
  EVSYS_CHANNEL1_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
  
  ; Channel 2 generator select
  EVSYS_CHANNEL2_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL2_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
  EVSYS_CHANNEL2_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
  EVSYS_CHANNEL2_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL2_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL2_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL2_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL2_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL2_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL2_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL2_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL2_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL2_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL2_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL2_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
  EVSYS_CHANNEL2_ZCD3_gc = (0x30<<0)  ; Zero Cross Detect 3 out
  EVSYS_CHANNEL2_PORTC_PIN1_gc = (0x41<<0) ; Port C Pin 1
  EVSYS_CHANNEL2_PORTC_PIN2_gc = (0x42<<0) ; Port C Pin 2
  EVSYS_CHANNEL2_PORTC_PIN3_gc = (0x43<<0) ; Port C Pin 3
  EVSYS_CHANNEL2_PORTD_PIN4_gc = (0x4C<<0) ; Port D Pin 4
  EVSYS_CHANNEL2_PORTD_PIN5_gc = (0x4D<<0) ; Port D Pin 5
  EVSYS_CHANNEL2_PORTD_PIN6_gc = (0x4E<<0) ; Port D Pin 6
  EVSYS_CHANNEL2_PORTD_PIN7_gc = (0x4F<<0) ; Port D Pin 7
  EVSYS_CHANNEL2_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL2_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL2_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
  EVSYS_CHANNEL2_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
  EVSYS_CHANNEL2_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
  EVSYS_CHANNEL2_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL2_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL2_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL2_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL2_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL2_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL2_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  EVSYS_CHANNEL2_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
  EVSYS_CHANNEL2_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
  EVSYS_CHANNEL2_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
  EVSYS_CHANNEL2_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
  EVSYS_CHANNEL2_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
  EVSYS_CHANNEL2_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
  
  ; Channel 3 generator select
  EVSYS_CHANNEL3_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL3_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
  EVSYS_CHANNEL3_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
  EVSYS_CHANNEL3_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL3_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL3_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL3_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL3_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL3_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL3_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL3_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL3_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL3_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL3_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL3_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
  EVSYS_CHANNEL3_ZCD3_gc = (0x30<<0)  ; Zero Cross Detect 3 out
  EVSYS_CHANNEL3_PORTC_PIN1_gc = (0x41<<0) ; Port C Pin 1
  EVSYS_CHANNEL3_PORTC_PIN2_gc = (0x42<<0) ; Port C Pin 2
  EVSYS_CHANNEL3_PORTC_PIN3_gc = (0x43<<0) ; Port C Pin 3
  EVSYS_CHANNEL3_PORTD_PIN4_gc = (0x4C<<0) ; Port D Pin 4
  EVSYS_CHANNEL3_PORTD_PIN5_gc = (0x4D<<0) ; Port D Pin 5
  EVSYS_CHANNEL3_PORTD_PIN6_gc = (0x4E<<0) ; Port D Pin 6
  EVSYS_CHANNEL3_PORTD_PIN7_gc = (0x4F<<0) ; Port D Pin 7
  EVSYS_CHANNEL3_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL3_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL3_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
  EVSYS_CHANNEL3_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
  EVSYS_CHANNEL3_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
  EVSYS_CHANNEL3_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL3_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL3_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL3_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL3_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL3_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL3_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  EVSYS_CHANNEL3_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
  EVSYS_CHANNEL3_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
  EVSYS_CHANNEL3_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
  EVSYS_CHANNEL3_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
  EVSYS_CHANNEL3_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
  EVSYS_CHANNEL3_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
  
  ; Channel 4 generator select
  EVSYS_CHANNEL4_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL4_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
  EVSYS_CHANNEL4_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
  EVSYS_CHANNEL4_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL4_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL4_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL4_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL4_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL4_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL4_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL4_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL4_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL4_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL4_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL4_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
  EVSYS_CHANNEL4_ZCD3_gc = (0x30<<0)  ; Zero Cross Detect 3 out
  EVSYS_CHANNEL4_PORTF_PIN6_gc = (0x4E<<0) ; Port F Pin 6
  EVSYS_CHANNEL4_PORTF_PIN7_gc = (0x4F<<0) ; Port F Pin 7
  EVSYS_CHANNEL4_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL4_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL4_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
  EVSYS_CHANNEL4_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
  EVSYS_CHANNEL4_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
  EVSYS_CHANNEL4_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL4_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL4_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL4_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL4_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL4_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL4_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  EVSYS_CHANNEL4_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
  EVSYS_CHANNEL4_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
  EVSYS_CHANNEL4_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
  EVSYS_CHANNEL4_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
  EVSYS_CHANNEL4_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
  EVSYS_CHANNEL4_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
  
  ; Channel 5 generator select
  EVSYS_CHANNEL5_OFF_gc = (0x00<<0)   ; Off
  EVSYS_CHANNEL5_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
  EVSYS_CHANNEL5_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
  EVSYS_CHANNEL5_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
  EVSYS_CHANNEL5_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
  EVSYS_CHANNEL5_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
  EVSYS_CHANNEL5_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
  EVSYS_CHANNEL5_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
  EVSYS_CHANNEL5_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
  EVSYS_CHANNEL5_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
  EVSYS_CHANNEL5_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
  EVSYS_CHANNEL5_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
  EVSYS_CHANNEL5_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
  EVSYS_CHANNEL5_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
  EVSYS_CHANNEL5_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
  EVSYS_CHANNEL5_ZCD3_gc = (0x30<<0)  ; Zero Cross Detect 3 out
  EVSYS_CHANNEL5_PORTF_PIN6_gc = (0x4E<<0) ; Port F Pin 6
  EVSYS_CHANNEL5_PORTF_PIN7_gc = (0x4F<<0) ; Port F Pin 7
  EVSYS_CHANNEL5_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
  EVSYS_CHANNEL5_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
  EVSYS_CHANNEL5_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
  EVSYS_CHANNEL5_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
  EVSYS_CHANNEL5_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
  EVSYS_CHANNEL5_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
  EVSYS_CHANNEL5_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
  EVSYS_CHANNEL5_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
  EVSYS_CHANNEL5_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
  EVSYS_CHANNEL5_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
  EVSYS_CHANNEL5_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
  EVSYS_CHANNEL5_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
  EVSYS_CHANNEL5_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
  EVSYS_CHANNEL5_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
  EVSYS_CHANNEL5_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
  EVSYS_CHANNEL5_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
  EVSYS_CHANNEL5_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
  EVSYS_CHANNEL5_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
  
  ; Software event on channel select
  EVSYS_SWEVENTA_CH0_gc = (0x01<<0)   ; Software event on channel 0
  EVSYS_SWEVENTA_CH1_gc = (0x02<<0)   ; Software event on channel 1
  EVSYS_SWEVENTA_CH2_gc = (0x04<<0)   ; Software event on channel 2
  EVSYS_SWEVENTA_CH3_gc = (0x08<<0)   ; Software event on channel 3
  EVSYS_SWEVENTA_CH4_gc = (0x10<<0)   ; Software event on channel 4
  EVSYS_SWEVENTA_CH5_gc = (0x20<<0)   ; Software event on channel 5
  EVSYS_SWEVENTA_CH6_gc = (0x40<<0)   ; Software event on channel 6
  EVSYS_SWEVENTA_CH7_gc = (0x80<<0)   ; Software event on channel 7
  
  ; Software event on channel select
  EVSYS_SWEVENTB_CH8_gc = (0x00<<0)   ; Software event on channel 8
  EVSYS_SWEVENTB_CH9_gc = (0x01<<0)   ; Software event on channel 9
  
  ; User channel select
  EVSYS_USER_OFF_gc = (0x00<<0)       ; Off
  EVSYS_USER_CHANNEL0_gc = (0x01<<0)  ; Connect user to event channel 0
  EVSYS_USER_CHANNEL1_gc = (0x02<<0)  ; Connect user to event channel 1
  EVSYS_USER_CHANNEL2_gc = (0x03<<0)  ; Connect user to event channel 2
  EVSYS_USER_CHANNEL3_gc = (0x04<<0)  ; Connect user to event channel 3
  EVSYS_USER_CHANNEL4_gc = (0x05<<0)  ; Connect user to event channel 4
  EVSYS_USER_CHANNEL5_gc = (0x06<<0)  ; Connect user to event channel 5
  
  
  ;*************************************************************************
  ;** FUSE - Fuses
  ;*************************************************************************
  
  ; FUSE_WDTCFG masks
  FUSE_PERIOD_gm = 0x0F               ; Watchdog Timeout Period group mask
  FUSE_PERIOD_gp = 0                  ; Watchdog Timeout Period group position
  FUSE_PERIOD_0_bm = (1<<0)           ; Watchdog Timeout Period bit 0 mask
  FUSE_PERIOD_0_bp = 0                ; Watchdog Timeout Period bit 0 position
  FUSE_PERIOD_1_bm = (1<<1)           ; Watchdog Timeout Period bit 1 mask
  FUSE_PERIOD_1_bp = 1                ; Watchdog Timeout Period bit 1 position
  FUSE_PERIOD_2_bm = (1<<2)           ; Watchdog Timeout Period bit 2 mask
  FUSE_PERIOD_2_bp = 2                ; Watchdog Timeout Period bit 2 position
  FUSE_PERIOD_3_bm = (1<<3)           ; Watchdog Timeout Period bit 3 mask
  FUSE_PERIOD_3_bp = 3                ; Watchdog Timeout Period bit 3 position
  FUSE_WINDOW_gm = 0xF0               ; Watchdog Window Timeout Period group mask
  FUSE_WINDOW_gp = 4                  ; Watchdog Window Timeout Period group position
  FUSE_WINDOW_0_bm = (1<<4)           ; Watchdog Window Timeout Period bit 0 mask
  FUSE_WINDOW_0_bp = 4                ; Watchdog Window Timeout Period bit 0 position
  FUSE_WINDOW_1_bm = (1<<5)           ; Watchdog Window Timeout Period bit 1 mask
  FUSE_WINDOW_1_bp = 5                ; Watchdog Window Timeout Period bit 1 position
  FUSE_WINDOW_2_bm = (1<<6)           ; Watchdog Window Timeout Period bit 2 mask
  FUSE_WINDOW_2_bp = 6                ; Watchdog Window Timeout Period bit 2 position
  FUSE_WINDOW_3_bm = (1<<7)           ; Watchdog Window Timeout Period bit 3 mask
  FUSE_WINDOW_3_bp = 7                ; Watchdog Window Timeout Period bit 3 position
  
  ; FUSE_BODCFG masks
  FUSE_SLEEP_gm = 0x03                ; BOD Operation in Sleep Mode group mask
  FUSE_SLEEP_gp = 0                   ; BOD Operation in Sleep Mode group position
  FUSE_SLEEP_0_bm = (1<<0)            ; BOD Operation in Sleep Mode bit 0 mask
  FUSE_SLEEP_0_bp = 0                 ; BOD Operation in Sleep Mode bit 0 position
  FUSE_SLEEP_1_bm = (1<<1)            ; BOD Operation in Sleep Mode bit 1 mask
  FUSE_SLEEP_1_bp = 1                 ; BOD Operation in Sleep Mode bit 1 position
  FUSE_ACTIVE_gm = 0x0C               ; BOD Operation in Active Mode group mask
  FUSE_ACTIVE_gp = 2                  ; BOD Operation in Active Mode group position
  FUSE_ACTIVE_0_bm = (1<<2)           ; BOD Operation in Active Mode bit 0 mask
  FUSE_ACTIVE_0_bp = 2                ; BOD Operation in Active Mode bit 0 position
  FUSE_ACTIVE_1_bm = (1<<3)           ; BOD Operation in Active Mode bit 1 mask
  FUSE_ACTIVE_1_bp = 3                ; BOD Operation in Active Mode bit 1 position
  FUSE_SAMPFREQ_bm = 0x10             ; BOD Sample Frequency bit mask
  FUSE_SAMPFREQ_bp = 4                ; BOD Sample Frequency bit position
  FUSE_LVL_gm = 0xE0                  ; BOD Level group mask
  FUSE_LVL_gp = 5                     ; BOD Level group position
  FUSE_LVL_0_bm = (1<<5)              ; BOD Level bit 0 mask
  FUSE_LVL_0_bp = 5                   ; BOD Level bit 0 position
  FUSE_LVL_1_bm = (1<<6)              ; BOD Level bit 1 mask
  FUSE_LVL_1_bp = 6                   ; BOD Level bit 1 position
  FUSE_LVL_2_bm = (1<<7)              ; BOD Level bit 2 mask
  FUSE_LVL_2_bp = 7                   ; BOD Level bit 2 position
  
  ; FUSE_OSCCFG masks
  FUSE_CLKSEL_gm = 0x07               ; Frequency Select group mask
  FUSE_CLKSEL_gp = 0                  ; Frequency Select group position
  FUSE_CLKSEL_0_bm = (1<<0)           ; Frequency Select bit 0 mask
  FUSE_CLKSEL_0_bp = 0                ; Frequency Select bit 0 position
  FUSE_CLKSEL_1_bm = (1<<1)           ; Frequency Select bit 1 mask
  FUSE_CLKSEL_1_bp = 1                ; Frequency Select bit 1 position
  FUSE_CLKSEL_2_bm = (1<<2)           ; Frequency Select bit 2 mask
  FUSE_CLKSEL_2_bp = 2                ; Frequency Select bit 2 position
  
  ; FUSE_SYSCFG0 masks
  FUSE_EESAVE_bm = 0x01               ; EEPROM Save bit mask
  FUSE_EESAVE_bp = 0                  ; EEPROM Save bit position
  FUSE_RSTPINCFG_bm = 0x08            ; Reset Pin Configuration bit mask
  FUSE_RSTPINCFG_bp = 3               ; Reset Pin Configuration bit position
  FUSE_UPDIPINCFG_bm = 0x10           ; UPDI Pin Configuration bit mask
  FUSE_UPDIPINCFG_bp = 4              ; UPDI Pin Configuration bit position
  FUSE_CRCSEL_bm = 0x20               ; CRC Select bit mask
  FUSE_CRCSEL_bp = 5                  ; CRC Select bit position
  FUSE_CRCSRC_gm = 0xC0               ; CRC Source group mask
  FUSE_CRCSRC_gp = 6                  ; CRC Source group position
  FUSE_CRCSRC_0_bm = (1<<6)           ; CRC Source bit 0 mask
  FUSE_CRCSRC_0_bp = 6                ; CRC Source bit 0 position
  FUSE_CRCSRC_1_bm = (1<<7)           ; CRC Source bit 1 mask
  FUSE_CRCSRC_1_bp = 7                ; CRC Source bit 1 position
  
  ; FUSE_SYSCFG1 masks
  FUSE_SUT_gm = 0x07                  ; Startup Time group mask
  FUSE_SUT_gp = 0                     ; Startup Time group position
  FUSE_SUT_0_bm = (1<<0)              ; Startup Time bit 0 mask
  FUSE_SUT_0_bp = 0                   ; Startup Time bit 0 position
  FUSE_SUT_1_bm = (1<<1)              ; Startup Time bit 1 mask
  FUSE_SUT_1_bp = 1                   ; Startup Time bit 1 position
  FUSE_SUT_2_bm = (1<<2)              ; Startup Time bit 2 mask
  FUSE_SUT_2_bp = 2                   ; Startup Time bit 2 position
  FUSE_MVSYSCFG_gm = 0x18             ; MVIO System Configuration group mask
  FUSE_MVSYSCFG_gp = 3                ; MVIO System Configuration group position
  FUSE_MVSYSCFG_0_bm = (1<<3)         ; MVIO System Configuration bit 0 mask
  FUSE_MVSYSCFG_0_bp = 3              ; MVIO System Configuration bit 0 position
  FUSE_MVSYSCFG_1_bm = (1<<4)         ; MVIO System Configuration bit 1 mask
  FUSE_MVSYSCFG_1_bp = 4              ; MVIO System Configuration bit 1 position
  
  ; BOD Operation in Active Mode select
  FUSE_ACTIVE_DISABLE_gc = (0x00<<2)  ; BOD disabled
  FUSE_ACTIVE_ENABLE_gc = (0x01<<2)   ; BOD enabled in continuous mode
  FUSE_ACTIVE_SAMPLE_gc = (0x02<<2)   ; BOD enabled in sampled mode
  FUSE_ACTIVE_ENABLEWAIT_gc = (0x03<<2) ; BOD enabled in continuous mode. Execution is halted at wake-up until BOD is running.
  
  ; BOD Level select
  FUSE_LVL_BODLEVEL0_gc = (0x00<<5)   ; 1.9V
  FUSE_LVL_BODLEVEL1_gc = (0x01<<5)   ; 2.45V
  FUSE_LVL_BODLEVEL2_gc = (0x02<<5)   ; 2.7V
  FUSE_LVL_BODLEVEL3_gc = (0x03<<5)   ; 2.85V
  
  ; BOD Sample Frequency select
  FUSE_SAMPFREQ_128Hz_gc = (0x00<<4)  ; Sample frequency is 128 Hz
  FUSE_SAMPFREQ_32Hz_gc = (0x01<<4)   ; Sample frequency is 32 Hz
  
  ; BOD Operation in Sleep Mode select
  FUSE_SLEEP_DISABLE_gc = (0x00<<0)   ; BOD disabled
  FUSE_SLEEP_ENABLE_gc = (0x01<<0)    ; BOD enabled in continuous mode
  FUSE_SLEEP_SAMPLE_gc = (0x02<<0)    ; BOD enabled in sampled mode
  
  ; Frequency Select
  FUSE_CLKSEL_OSCHF_gc = (0x00<<0)    ; 1-32MHz internal oscillator
  FUSE_CLKSEL_OSC32K_gc = (0x01<<0)   ; 32.768kHz internal oscillator
  
  ; CRC Select
  FUSE_CRCSEL_CRC16_gc = (0x00<<5)    ; Enable CRC16
  FUSE_CRCSEL_CRC32_gc = (0x01<<5)    ; Enable CRC32
  
  ; CRC Source select
  FUSE_CRCSRC_FLASH_gc = (0x00<<6)    ; CRC of full Flash (boot, application code and application data)
  FUSE_CRCSRC_BOOT_gc = (0x01<<6)     ; CRC of boot section
  FUSE_CRCSRC_BOOTAPP_gc = (0x02<<6)  ; CRC of application code and boot sections
  FUSE_CRCSRC_NOCRC_gc = (0x03<<6)    ; No CRC
  
  ; Reset Pin Configuration select
  FUSE_RSTPINCFG_GPIO_gc = (0x00<<3)  ; GPIO mode
  FUSE_RSTPINCFG_RST_gc = (0x01<<3)   ; Reset mode
  
  ; UPDI Pin Configuration select
  FUSE_UPDIPINCFG_GPIO_gc = (0x00<<4) ; GPIO Mode
  FUSE_UPDIPINCFG_UPDI_gc = (0x01<<4) ; UPDI Mode
  
  ; MVIO System Configuration select
  FUSE_MVSYSCFG_DUAL_gc = (0x01<<3)   ; Device used in a dual supply configuration
  FUSE_MVSYSCFG_SINGLE_gc = (0x02<<3) ; Device used in a single supply configuration
  
  ; Startup Time select
  FUSE_SUT_0MS_gc = (0x00<<0)         ; 0 ms
  FUSE_SUT_1MS_gc = (0x01<<0)         ; 1 ms
  FUSE_SUT_2MS_gc = (0x02<<0)         ; 2 ms
  FUSE_SUT_4MS_gc = (0x03<<0)         ; 4 ms
  FUSE_SUT_8MS_gc = (0x04<<0)         ; 8 ms
  FUSE_SUT_16MS_gc = (0x05<<0)        ; 16 ms
  FUSE_SUT_32MS_gc = (0x06<<0)        ; 32 ms
  FUSE_SUT_64MS_gc = (0x07<<0)        ; 64 ms
  
  ; Watchdog Timeout Period select
  FUSE_PERIOD_OFF_gc = (0x00<<0)      ; Watch-Dog timer Off
  FUSE_PERIOD_8CLK_gc = (0x01<<0)     ; 8 cycles (8ms)
  FUSE_PERIOD_16CLK_gc = (0x02<<0)    ; 16 cycles (16ms)
  FUSE_PERIOD_32CLK_gc = (0x03<<0)    ; 32 cycles (32ms)
  FUSE_PERIOD_64CLK_gc = (0x04<<0)    ; 64 cycles (64ms)
  FUSE_PERIOD_128CLK_gc = (0x05<<0)   ; 128 cycles (0.128s)
  FUSE_PERIOD_256CLK_gc = (0x06<<0)   ; 256 cycles (0.256s)
  FUSE_PERIOD_512CLK_gc = (0x07<<0)   ; 512 cycles (0.512s)
  FUSE_PERIOD_1KCLK_gc = (0x08<<0)    ; 1K cycles (1.0s)
  FUSE_PERIOD_2KCLK_gc = (0x09<<0)    ; 2K cycles (2.0s)
  FUSE_PERIOD_4KCLK_gc = (0x0A<<0)    ; 4K cycles (4.0s)
  FUSE_PERIOD_8KCLK_gc = (0x0B<<0)    ; 8K cycles (8.0s)
  
  ; Watchdog Window Timeout Period select
  FUSE_WINDOW_OFF_gc = (0x00<<4)      ; Window mode off
  FUSE_WINDOW_8CLK_gc = (0x01<<4)     ; 8 cycles (8ms)
  FUSE_WINDOW_16CLK_gc = (0x02<<4)    ; 16 cycles (16ms)
  FUSE_WINDOW_32CLK_gc = (0x03<<4)    ; 32 cycles (32ms)
  FUSE_WINDOW_64CLK_gc = (0x04<<4)    ; 64 cycles (64ms)
  FUSE_WINDOW_128CLK_gc = (0x05<<4)   ; 128 cycles (0.128s)
  FUSE_WINDOW_256CLK_gc = (0x06<<4)   ; 256 cycles (0.256s)
  FUSE_WINDOW_512CLK_gc = (0x07<<4)   ; 512 cycles (0.512s)
  FUSE_WINDOW_1KCLK_gc = (0x08<<4)    ; 1K cycles (1.0s)
  FUSE_WINDOW_2KCLK_gc = (0x09<<4)    ; 2K cycles (2.0s)
  FUSE_WINDOW_4KCLK_gc = (0x0A<<4)    ; 4K cycles (4.0s)
  FUSE_WINDOW_8KCLK_gc = (0x0B<<4)    ; 8K cycles (8.0s)
  
  
  ;*************************************************************************
  ;** GPR - General Purpose Registers
  ;*************************************************************************
  
  
  ;*************************************************************************
  ;** LOCK - Lockbits
  ;*************************************************************************
  
  ; LOCK_KEY masks
  LOCK_KEY_gm = 0xFFFFFFFF            ; Lock Key group mask
  LOCK_KEY_gp = 0                     ; Lock Key group position
  LOCK_KEY_0_bm = (1<<0)              ; Lock Key bit 0 mask
  LOCK_KEY_0_bp = 0                   ; Lock Key bit 0 position
  LOCK_KEY_1_bm = (1<<1)              ; Lock Key bit 1 mask
  LOCK_KEY_1_bp = 1                   ; Lock Key bit 1 position
  LOCK_KEY_2_bm = (1<<2)              ; Lock Key bit 2 mask
  LOCK_KEY_2_bp = 2                   ; Lock Key bit 2 position
  LOCK_KEY_3_bm = (1<<3)              ; Lock Key bit 3 mask
  LOCK_KEY_3_bp = 3                   ; Lock Key bit 3 position
  LOCK_KEY_4_bm = (1<<4)              ; Lock Key bit 4 mask
  LOCK_KEY_4_bp = 4                   ; Lock Key bit 4 position
  LOCK_KEY_5_bm = (1<<5)              ; Lock Key bit 5 mask
  LOCK_KEY_5_bp = 5                   ; Lock Key bit 5 position
  LOCK_KEY_6_bm = (1<<6)              ; Lock Key bit 6 mask
  LOCK_KEY_6_bp = 6                   ; Lock Key bit 6 position
  LOCK_KEY_7_bm = (1<<7)              ; Lock Key bit 7 mask
  LOCK_KEY_7_bp = 7                   ; Lock Key bit 7 position
  LOCK_KEY_8_bm = (1<<8)              ; Lock Key bit 8 mask
  LOCK_KEY_8_bp = 8                   ; Lock Key bit 8 position
  LOCK_KEY_9_bm = (1<<9)              ; Lock Key bit 9 mask
  LOCK_KEY_9_bp = 9                   ; Lock Key bit 9 position
  LOCK_KEY_10_bm = (1<<10)            ; Lock Key bit 10 mask
  LOCK_KEY_10_bp = 10                 ; Lock Key bit 10 position
  LOCK_KEY_11_bm = (1<<11)            ; Lock Key bit 11 mask
  LOCK_KEY_11_bp = 11                 ; Lock Key bit 11 position
  LOCK_KEY_12_bm = (1<<12)            ; Lock Key bit 12 mask
  LOCK_KEY_12_bp = 12                 ; Lock Key bit 12 position
  LOCK_KEY_13_bm = (1<<13)            ; Lock Key bit 13 mask
  LOCK_KEY_13_bp = 13                 ; Lock Key bit 13 position
  LOCK_KEY_14_bm = (1<<14)            ; Lock Key bit 14 mask
  LOCK_KEY_14_bp = 14                 ; Lock Key bit 14 position
  LOCK_KEY_15_bm = (1<<15)            ; Lock Key bit 15 mask
  LOCK_KEY_15_bp = 15                 ; Lock Key bit 15 position
  LOCK_KEY_16_bm = (1<<16)            ; Lock Key bit 16 mask
  LOCK_KEY_16_bp = 16                 ; Lock Key bit 16 position
  LOCK_KEY_17_bm = (1<<17)            ; Lock Key bit 17 mask
  LOCK_KEY_17_bp = 17                 ; Lock Key bit 17 position
  LOCK_KEY_18_bm = (1<<18)            ; Lock Key bit 18 mask
  LOCK_KEY_18_bp = 18                 ; Lock Key bit 18 position
  LOCK_KEY_19_bm = (1<<19)            ; Lock Key bit 19 mask
  LOCK_KEY_19_bp = 19                 ; Lock Key bit 19 position
  LOCK_KEY_20_bm = (1<<20)            ; Lock Key bit 20 mask
  LOCK_KEY_20_bp = 20                 ; Lock Key bit 20 position
  LOCK_KEY_21_bm = (1<<21)            ; Lock Key bit 21 mask
  LOCK_KEY_21_bp = 21                 ; Lock Key bit 21 position
  LOCK_KEY_22_bm = (1<<22)            ; Lock Key bit 22 mask
  LOCK_KEY_22_bp = 22                 ; Lock Key bit 22 position
  LOCK_KEY_23_bm = (1<<23)            ; Lock Key bit 23 mask
  LOCK_KEY_23_bp = 23                 ; Lock Key bit 23 position
  LOCK_KEY_24_bm = (1<<24)            ; Lock Key bit 24 mask
  LOCK_KEY_24_bp = 24                 ; Lock Key bit 24 position
  LOCK_KEY_25_bm = (1<<25)            ; Lock Key bit 25 mask
  LOCK_KEY_25_bp = 25                 ; Lock Key bit 25 position
  LOCK_KEY_26_bm = (1<<26)            ; Lock Key bit 26 mask
  LOCK_KEY_26_bp = 26                 ; Lock Key bit 26 position
  LOCK_KEY_27_bm = (1<<27)            ; Lock Key bit 27 mask
  LOCK_KEY_27_bp = 27                 ; Lock Key bit 27 position
  LOCK_KEY_28_bm = (1<<28)            ; Lock Key bit 28 mask
  LOCK_KEY_28_bp = 28                 ; Lock Key bit 28 position
  LOCK_KEY_29_bm = (1<<29)            ; Lock Key bit 29 mask
  LOCK_KEY_29_bp = 29                 ; Lock Key bit 29 position
  LOCK_KEY_30_bm = (1<<30)            ; Lock Key bit 30 mask
  LOCK_KEY_30_bp = 30                 ; Lock Key bit 30 position
  LOCK_KEY_31_bm = (1<<31)            ; Lock Key bit 31 mask
  LOCK_KEY_31_bp = 31                 ; Lock Key bit 31 position
  
  ; Lock Key select
  LOCK_KEY_NOLOCK_gc = (0x5CC5C55C<<0) ; No locks
  LOCK_KEY_RWLOCK_gc = (0xA33A3AA3<<0) ; Read and write lock
  
  
  ;*************************************************************************
  ;** MVIO - Multi-Voltage I/O
  ;*************************************************************************
  
  ; MVIO_INTCTRL masks
  MVIO_VDDIO2IE_bm = 0x01             ; VDDIO2 Interrupt Enable bit mask
  MVIO_VDDIO2IE_bp = 0                ; VDDIO2 Interrupt Enable bit position
  
  ; MVIO_INTFLAGS masks
  MVIO_VDDIO2IF_bm = 0x01             ; VDDIO2 Interrupt Flag bit mask
  MVIO_VDDIO2IF_bp = 0                ; VDDIO2 Interrupt Flag bit position
  
  ; MVIO_STATUS masks
  MVIO_VDDIO2S_bm = 0x01              ; VDDIO2 Status bit mask
  MVIO_VDDIO2S_bp = 0                 ; VDDIO2 Status bit position
  
  
  ;*************************************************************************
  ;** NVMCTRL - Non-volatile Memory Controller
  ;*************************************************************************
  
  ; NVMCTRL_CTRLA masks
  NVMCTRL_CMD_gm = 0x7F               ; Command group mask
  NVMCTRL_CMD_gp = 0                  ; Command group position
  NVMCTRL_CMD_0_bm = (1<<0)           ; Command bit 0 mask
  NVMCTRL_CMD_0_bp = 0                ; Command bit 0 position
  NVMCTRL_CMD_1_bm = (1<<1)           ; Command bit 1 mask
  NVMCTRL_CMD_1_bp = 1                ; Command bit 1 position
  NVMCTRL_CMD_2_bm = (1<<2)           ; Command bit 2 mask
  NVMCTRL_CMD_2_bp = 2                ; Command bit 2 position
  NVMCTRL_CMD_3_bm = (1<<3)           ; Command bit 3 mask
  NVMCTRL_CMD_3_bp = 3                ; Command bit 3 position
  NVMCTRL_CMD_4_bm = (1<<4)           ; Command bit 4 mask
  NVMCTRL_CMD_4_bp = 4                ; Command bit 4 position
  NVMCTRL_CMD_5_bm = (1<<5)           ; Command bit 5 mask
  NVMCTRL_CMD_5_bp = 5                ; Command bit 5 position
  NVMCTRL_CMD_6_bm = (1<<6)           ; Command bit 6 mask
  NVMCTRL_CMD_6_bp = 6                ; Command bit 6 position
  
  ; NVMCTRL_CTRLB masks
  NVMCTRL_APPCODEWP_bm = 0x01         ; Application Code Write Protect bit mask
  NVMCTRL_APPCODEWP_bp = 0            ; Application Code Write Protect bit position
  NVMCTRL_BOOTRP_bm = 0x02            ; Boot Read Protect bit mask
  NVMCTRL_BOOTRP_bp = 1               ; Boot Read Protect bit position
  NVMCTRL_APPDATAWP_bm = 0x04         ; Application Data Write Protect bit mask
  NVMCTRL_APPDATAWP_bp = 2            ; Application Data Write Protect bit position
  NVMCTRL_FLMAP_gm = 0x30             ; Flash Mapping in Data space group mask
  NVMCTRL_FLMAP_gp = 4                ; Flash Mapping in Data space group position
  NVMCTRL_FLMAP_0_bm = (1<<4)         ; Flash Mapping in Data space bit 0 mask
  NVMCTRL_FLMAP_0_bp = 4              ; Flash Mapping in Data space bit 0 position
  NVMCTRL_FLMAP_1_bm = (1<<5)         ; Flash Mapping in Data space bit 1 mask
  NVMCTRL_FLMAP_1_bp = 5              ; Flash Mapping in Data space bit 1 position
  NVMCTRL_FLMAPLOCK_bm = 0x80         ; Flash Mapping Lock bit mask
  NVMCTRL_FLMAPLOCK_bp = 7            ; Flash Mapping Lock bit position
  
  ; NVMCTRL_STATUS masks
  NVMCTRL_FBUSY_bm = 0x01             ; Flash busy bit mask
  NVMCTRL_FBUSY_bp = 0                ; Flash busy bit position
  NVMCTRL_EEBUSY_bm = 0x02            ; EEPROM busy bit mask
  NVMCTRL_EEBUSY_bp = 1               ; EEPROM busy bit position
  NVMCTRL_ERROR_gm = 0x70             ; Write error group mask
  NVMCTRL_ERROR_gp = 4                ; Write error group position
  NVMCTRL_ERROR_0_bm = (1<<4)         ; Write error bit 0 mask
  NVMCTRL_ERROR_0_bp = 4              ; Write error bit 0 position
  NVMCTRL_ERROR_1_bm = (1<<5)         ; Write error bit 1 mask
  NVMCTRL_ERROR_1_bp = 5              ; Write error bit 1 position
  NVMCTRL_ERROR_2_bm = (1<<6)         ; Write error bit 2 mask
  NVMCTRL_ERROR_2_bp = 6              ; Write error bit 2 position
  
  ; NVMCTRL_INTCTRL masks
  NVMCTRL_EEREADY_bm = 0x01           ; EEPROM Ready bit mask
  NVMCTRL_EEREADY_bp = 0              ; EEPROM Ready bit position
  
  ; NVMCTRL_INTFLAGS masks
  ; Masks for NVMCTRL_EEREADY already defined
  
  ; Command select
  NVMCTRL_CMD_NONE_gc = (0x00<<0)     ; No Command
  NVMCTRL_CMD_NOOP_gc = (0x01<<0)     ; No Operation
  NVMCTRL_CMD_FLWR_gc = (0x02<<0)     ; Flash Write
  NVMCTRL_CMD_FLPER_gc = (0x08<<0)    ; Flash Page Erase
  NVMCTRL_CMD_FLMPER2_gc = (0x09<<0)  ; Flash Multi-Page Erase 2 pages
  NVMCTRL_CMD_FLMPER4_gc = (0x0A<<0)  ; Flash Multi-Page Erase 4 pages
  NVMCTRL_CMD_FLMPER8_gc = (0x0B<<0)  ; Flash Multi-Page Erase 8 pages
  NVMCTRL_CMD_FLMPER16_gc = (0x0C<<0) ; Flash Multi-Page Erase 16 pages
  NVMCTRL_CMD_FLMPER32_gc = (0x0D<<0) ; Flash Multi-Page Erase 32 pages
  NVMCTRL_CMD_EEWR_gc = (0x12<<0)     ; EEPROM Write
  NVMCTRL_CMD_EEERWR_gc = (0x13<<0)   ; EEPROM Erase and Write
  NVMCTRL_CMD_EEBER_gc = (0x18<<0)    ; EEPROM Byte Erase
  NVMCTRL_CMD_EEMBER2_gc = (0x19<<0)  ; EEPROM Multi-Byte Erase 2 bytes
  NVMCTRL_CMD_EEMBER4_gc = (0x1A<<0)  ; EEPROM Multi-Byte Erase 4 bytes
  NVMCTRL_CMD_EEMBER8_gc = (0x1B<<0)  ; EEPROM Multi-Byte Erase 8 bytes
  NVMCTRL_CMD_EEMBER16_gc = (0x1C<<0) ; EEPROM Multi-Byte Erase 16 bytes
  NVMCTRL_CMD_EEMBER32_gc = (0x1D<<0) ; EEPROM Multi-Byte Erase 32 bytes
  NVMCTRL_CMD_CHER_gc = (0x20<<0)     ; Chip Erase Command
  NVMCTRL_CMD_EECHER_gc = (0x30<<0)   ; EEPROM Erase Command
  
  ; Flash Mapping in Data space select
  NVMCTRL_FLMAP_SECTION0_gc = (0x00<<4) ; Flash section 0
  NVMCTRL_FLMAP_SECTION1_gc = (0x01<<4) ; Flash section 1
  NVMCTRL_FLMAP_SECTION2_gc = (0x02<<4) ; Flash section 2
  NVMCTRL_FLMAP_SECTION3_gc = (0x03<<4) ; Flash section 3
  
  ; Write error select
  NVMCTRL_ERROR_NOERROR_gc = (0x00<<4) ; No Error
  NVMCTRL_ERROR_ILLEGALCMD_gc = (0x01<<4) ; Write command not selected
  NVMCTRL_ERROR_ILLEGALSADDR_gc = (0x02<<4) ; Write to section not allowed
  NVMCTRL_ERROR_DOUBLESELECT_gc = (0x03<<4) ; Selecting new write command while write command already seleted
  NVMCTRL_ERROR_ONGOINGPROG_gc = (0x04<<4) ; Starting a new programming operation before previous is completed
  
  
  ;*************************************************************************
  ;** PORT - I/O Ports
  ;*************************************************************************
  
  ; PORT_INTFLAGS masks
  PORT_INT_gm = 0xFF                  ; Pin Interrupt Flag group mask
  PORT_INT_gp = 0                     ; Pin Interrupt Flag group position
  PORT_INT_0_bm = (1<<0)              ; Pin Interrupt Flag bit 0 mask
  PORT_INT_0_bp = 0                   ; Pin Interrupt Flag bit 0 position
  PORT_INT_1_bm = (1<<1)              ; Pin Interrupt Flag bit 1 mask
  PORT_INT_1_bp = 1                   ; Pin Interrupt Flag bit 1 position
  PORT_INT_2_bm = (1<<2)              ; Pin Interrupt Flag bit 2 mask
  PORT_INT_2_bp = 2                   ; Pin Interrupt Flag bit 2 position
  PORT_INT_3_bm = (1<<3)              ; Pin Interrupt Flag bit 3 mask
  PORT_INT_3_bp = 3                   ; Pin Interrupt Flag bit 3 position
  PORT_INT_4_bm = (1<<4)              ; Pin Interrupt Flag bit 4 mask
  PORT_INT_4_bp = 4                   ; Pin Interrupt Flag bit 4 position
  PORT_INT_5_bm = (1<<5)              ; Pin Interrupt Flag bit 5 mask
  PORT_INT_5_bp = 5                   ; Pin Interrupt Flag bit 5 position
  PORT_INT_6_bm = (1<<6)              ; Pin Interrupt Flag bit 6 mask
  PORT_INT_6_bp = 6                   ; Pin Interrupt Flag bit 6 position
  PORT_INT_7_bm = (1<<7)              ; Pin Interrupt Flag bit 7 mask
  PORT_INT_7_bp = 7                   ; Pin Interrupt Flag bit 7 position
  
  ; PORT_PORTCTRL masks
  PORT_SRL_bm = 0x01                  ; Slew Rate Limit Enable bit mask
  PORT_SRL_bp = 0                     ; Slew Rate Limit Enable bit position
  
  ; PORT_PINCONFIG masks
  PORT_ISC_gm = 0x07                  ; Input/Sense Configuration group mask
  PORT_ISC_gp = 0                     ; Input/Sense Configuration group position
  PORT_ISC_0_bm = (1<<0)              ; Input/Sense Configuration bit 0 mask
  PORT_ISC_0_bp = 0                   ; Input/Sense Configuration bit 0 position
  PORT_ISC_1_bm = (1<<1)              ; Input/Sense Configuration bit 1 mask
  PORT_ISC_1_bp = 1                   ; Input/Sense Configuration bit 1 position
  PORT_ISC_2_bm = (1<<2)              ; Input/Sense Configuration bit 2 mask
  PORT_ISC_2_bp = 2                   ; Input/Sense Configuration bit 2 position
  PORT_PULLUPEN_bm = 0x08             ; Pullup enable bit mask
  PORT_PULLUPEN_bp = 3                ; Pullup enable bit position
  PORT_INLVL_bm = 0x40                ; Input level select bit mask
  PORT_INLVL_bp = 6                   ; Input level select bit position
  PORT_INVEN_bm = 0x80                ; Inverted I/O Enable bit mask
  PORT_INVEN_bp = 7                   ; Inverted I/O Enable bit position
  
  ; PORT_PINCTRLUPD masks
  PORT_PINCTRLUPD_gm = 0xFF           ; Pin control update mask group mask
  PORT_PINCTRLUPD_gp = 0              ; Pin control update mask group position
  PORT_PINCTRLUPD_0_bm = (1<<0)       ; Pin control update mask bit 0 mask
  PORT_PINCTRLUPD_0_bp = 0            ; Pin control update mask bit 0 position
  PORT_PINCTRLUPD_1_bm = (1<<1)       ; Pin control update mask bit 1 mask
  PORT_PINCTRLUPD_1_bp = 1            ; Pin control update mask bit 1 position
  PORT_PINCTRLUPD_2_bm = (1<<2)       ; Pin control update mask bit 2 mask
  PORT_PINCTRLUPD_2_bp = 2            ; Pin control update mask bit 2 position
  PORT_PINCTRLUPD_3_bm = (1<<3)       ; Pin control update mask bit 3 mask
  PORT_PINCTRLUPD_3_bp = 3            ; Pin control update mask bit 3 position
  PORT_PINCTRLUPD_4_bm = (1<<4)       ; Pin control update mask bit 4 mask
  PORT_PINCTRLUPD_4_bp = 4            ; Pin control update mask bit 4 position
  PORT_PINCTRLUPD_5_bm = (1<<5)       ; Pin control update mask bit 5 mask
  PORT_PINCTRLUPD_5_bp = 5            ; Pin control update mask bit 5 position
  PORT_PINCTRLUPD_6_bm = (1<<6)       ; Pin control update mask bit 6 mask
  PORT_PINCTRLUPD_6_bp = 6            ; Pin control update mask bit 6 position
  PORT_PINCTRLUPD_7_bm = (1<<7)       ; Pin control update mask bit 7 mask
  PORT_PINCTRLUPD_7_bp = 7            ; Pin control update mask bit 7 position
  
  ; PORT_PINCTRLSET masks
  PORT_PINCTRLSET_gm = 0xFF           ; Pin control set mask group mask
  PORT_PINCTRLSET_gp = 0              ; Pin control set mask group position
  PORT_PINCTRLSET_0_bm = (1<<0)       ; Pin control set mask bit 0 mask
  PORT_PINCTRLSET_0_bp = 0            ; Pin control set mask bit 0 position
  PORT_PINCTRLSET_1_bm = (1<<1)       ; Pin control set mask bit 1 mask
  PORT_PINCTRLSET_1_bp = 1            ; Pin control set mask bit 1 position
  PORT_PINCTRLSET_2_bm = (1<<2)       ; Pin control set mask bit 2 mask
  PORT_PINCTRLSET_2_bp = 2            ; Pin control set mask bit 2 position
  PORT_PINCTRLSET_3_bm = (1<<3)       ; Pin control set mask bit 3 mask
  PORT_PINCTRLSET_3_bp = 3            ; Pin control set mask bit 3 position
  PORT_PINCTRLSET_4_bm = (1<<4)       ; Pin control set mask bit 4 mask
  PORT_PINCTRLSET_4_bp = 4            ; Pin control set mask bit 4 position
  PORT_PINCTRLSET_5_bm = (1<<5)       ; Pin control set mask bit 5 mask
  PORT_PINCTRLSET_5_bp = 5            ; Pin control set mask bit 5 position
  PORT_PINCTRLSET_6_bm = (1<<6)       ; Pin control set mask bit 6 mask
  PORT_PINCTRLSET_6_bp = 6            ; Pin control set mask bit 6 position
  PORT_PINCTRLSET_7_bm = (1<<7)       ; Pin control set mask bit 7 mask
  PORT_PINCTRLSET_7_bp = 7            ; Pin control set mask bit 7 position
  
  ; PORT_PINCTRLCLR masks
  PORT_PINCTRLCLR_gm = 0xFF           ; Pin control clear mask group mask
  PORT_PINCTRLCLR_gp = 0              ; Pin control clear mask group position
  PORT_PINCTRLCLR_0_bm = (1<<0)       ; Pin control clear mask bit 0 mask
  PORT_PINCTRLCLR_0_bp = 0            ; Pin control clear mask bit 0 position
  PORT_PINCTRLCLR_1_bm = (1<<1)       ; Pin control clear mask bit 1 mask
  PORT_PINCTRLCLR_1_bp = 1            ; Pin control clear mask bit 1 position
  PORT_PINCTRLCLR_2_bm = (1<<2)       ; Pin control clear mask bit 2 mask
  PORT_PINCTRLCLR_2_bp = 2            ; Pin control clear mask bit 2 position
  PORT_PINCTRLCLR_3_bm = (1<<3)       ; Pin control clear mask bit 3 mask
  PORT_PINCTRLCLR_3_bp = 3            ; Pin control clear mask bit 3 position
  PORT_PINCTRLCLR_4_bm = (1<<4)       ; Pin control clear mask bit 4 mask
  PORT_PINCTRLCLR_4_bp = 4            ; Pin control clear mask bit 4 position
  PORT_PINCTRLCLR_5_bm = (1<<5)       ; Pin control clear mask bit 5 mask
  PORT_PINCTRLCLR_5_bp = 5            ; Pin control clear mask bit 5 position
  PORT_PINCTRLCLR_6_bm = (1<<6)       ; Pin control clear mask bit 6 mask
  PORT_PINCTRLCLR_6_bp = 6            ; Pin control clear mask bit 6 position
  PORT_PINCTRLCLR_7_bm = (1<<7)       ; Pin control clear mask bit 7 mask
  PORT_PINCTRLCLR_7_bp = 7            ; Pin control clear mask bit 7 position
  
  ; PORT_PIN0CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INLVL already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN1CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INLVL already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN2CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INLVL already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN3CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INLVL already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN4CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INLVL already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN5CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INLVL already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN6CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INLVL already defined
  ; Masks for PORT_INVEN already defined
  
  ; PORT_PIN7CTRL masks
  ; Masks for PORT_ISC already defined
  ; Masks for PORT_PULLUPEN already defined
  ; Masks for PORT_INLVL already defined
  ; Masks for PORT_INVEN already defined
  
  ; Input/Sense Configuration select
  PORT_ISC_INTDISABLE_gc = (0x00<<0)  ; Interrupt disabled but input buffer enabled
  PORT_ISC_BOTHEDGES_gc = (0x01<<0)   ; Sense Both Edges
  PORT_ISC_RISING_gc = (0x02<<0)      ; Sense Rising Edge
  PORT_ISC_FALLING_gc = (0x03<<0)     ; Sense Falling Edge
  PORT_ISC_INPUT_DISABLE_gc = (0x04<<0) ; Digital Input Buffer disabled
  PORT_ISC_LEVEL_gc = (0x05<<0)       ; Sense low Level
  
  
  ;*************************************************************************
  ;** PORTMUX - Port Multiplexer
  ;*************************************************************************
  
  ; PORTMUX_EVSYSROUTEA masks
  PORTMUX_EVOUTA_bm = 0x01            ; Event Output A bit mask
  PORTMUX_EVOUTA_bp = 0               ; Event Output A bit position
  PORTMUX_EVOUTC_bm = 0x04            ; Event Output C bit mask
  PORTMUX_EVOUTC_bp = 2               ; Event Output C bit position
  PORTMUX_EVOUTD_bm = 0x08            ; Event Output D bit mask
  PORTMUX_EVOUTD_bp = 3               ; Event Output D bit position
  PORTMUX_EVOUTF_bm = 0x20            ; Event Output F bit mask
  PORTMUX_EVOUTF_bp = 5               ; Event Output F bit position
  
  ; PORTMUX_CCLROUTEA masks
  PORTMUX_LUT0_bm = 0x01              ; CCL Look-Up Table 0 Signals bit mask
  PORTMUX_LUT0_bp = 0                 ; CCL Look-Up Table 0 Signals bit position
  PORTMUX_LUT1_bm = 0x02              ; CCL Look-Up Table 1 Signals bit mask
  PORTMUX_LUT1_bp = 1                 ; CCL Look-Up Table 1 Signals bit position
  PORTMUX_LUT2_bm = 0x04              ; CCL Look-Up Table 2 Signals bit mask
  PORTMUX_LUT2_bp = 2                 ; CCL Look-Up Table 2 Signals bit position
  PORTMUX_LUT3_bm = 0x08              ; CCL Look-Up Table 3 Signals bit mask
  PORTMUX_LUT3_bp = 3                 ; CCL Look-Up Table 3 Signals bit position
  
  ; PORTMUX_USARTROUTEA masks
  PORTMUX_USART0_gm = 0x07            ; USART0 Signals group mask
  PORTMUX_USART0_gp = 0               ; USART0 Signals group position
  PORTMUX_USART0_0_bm = (1<<0)        ; USART0 Signals bit 0 mask
  PORTMUX_USART0_0_bp = 0             ; USART0 Signals bit 0 position
  PORTMUX_USART0_1_bm = (1<<1)        ; USART0 Signals bit 1 mask
  PORTMUX_USART0_1_bp = 1             ; USART0 Signals bit 1 position
  PORTMUX_USART0_2_bm = (1<<2)        ; USART0 Signals bit 2 mask
  PORTMUX_USART0_2_bp = 2             ; USART0 Signals bit 2 position
  PORTMUX_USART1_gm = 0x18            ; USART1 Signals group mask
  PORTMUX_USART1_gp = 3               ; USART1 Signals group position
  PORTMUX_USART1_0_bm = (1<<3)        ; USART1 Signals bit 0 mask
  PORTMUX_USART1_0_bp = 3             ; USART1 Signals bit 0 position
  PORTMUX_USART1_1_bm = (1<<4)        ; USART1 Signals bit 1 mask
  PORTMUX_USART1_1_bp = 4             ; USART1 Signals bit 1 position
  
  ; PORTMUX_SPIROUTEA masks
  PORTMUX_SPI0_gm = 0x07              ; SPI0 Signals group mask
  PORTMUX_SPI0_gp = 0                 ; SPI0 Signals group position
  PORTMUX_SPI0_0_bm = (1<<0)          ; SPI0 Signals bit 0 mask
  PORTMUX_SPI0_0_bp = 0               ; SPI0 Signals bit 0 position
  PORTMUX_SPI0_1_bm = (1<<1)          ; SPI0 Signals bit 1 mask
  PORTMUX_SPI0_1_bp = 1               ; SPI0 Signals bit 1 position
  PORTMUX_SPI0_2_bm = (1<<2)          ; SPI0 Signals bit 2 mask
  PORTMUX_SPI0_2_bp = 2               ; SPI0 Signals bit 2 position
  
  ; PORTMUX_TWIROUTEA masks
  PORTMUX_TWI0_gm = 0x03              ; TWI0 Signals group mask
  PORTMUX_TWI0_gp = 0                 ; TWI0 Signals group position
  PORTMUX_TWI0_0_bm = (1<<0)          ; TWI0 Signals bit 0 mask
  PORTMUX_TWI0_0_bp = 0               ; TWI0 Signals bit 0 position
  PORTMUX_TWI0_1_bm = (1<<1)          ; TWI0 Signals bit 1 mask
  PORTMUX_TWI0_1_bp = 1               ; TWI0 Signals bit 1 position
  
  ; PORTMUX_TCAROUTEA masks
  PORTMUX_TCA0_gm = 0x07              ; TCA0 Signals group mask
  PORTMUX_TCA0_gp = 0                 ; TCA0 Signals group position
  PORTMUX_TCA0_0_bm = (1<<0)          ; TCA0 Signals bit 0 mask
  PORTMUX_TCA0_0_bp = 0               ; TCA0 Signals bit 0 position
  PORTMUX_TCA0_1_bm = (1<<1)          ; TCA0 Signals bit 1 mask
  PORTMUX_TCA0_1_bp = 1               ; TCA0 Signals bit 1 position
  PORTMUX_TCA0_2_bm = (1<<2)          ; TCA0 Signals bit 2 mask
  PORTMUX_TCA0_2_bp = 2               ; TCA0 Signals bit 2 position
  
  ; PORTMUX_TCBROUTEA masks
  PORTMUX_TCB0_bm = 0x01              ; TCB0 Output bit mask
  PORTMUX_TCB0_bp = 0                 ; TCB0 Output bit position
  PORTMUX_TCB1_bm = 0x02              ; TCB1 Output bit mask
  PORTMUX_TCB1_bp = 1                 ; TCB1 Output bit position
  
  ; PORTMUX_TCDROUTEA masks
  PORTMUX_TCD0_gm = 0x07              ; TCD0 Signals group mask
  PORTMUX_TCD0_gp = 0                 ; TCD0 Signals group position
  PORTMUX_TCD0_0_bm = (1<<0)          ; TCD0 Signals bit 0 mask
  PORTMUX_TCD0_0_bp = 0               ; TCD0 Signals bit 0 position
  PORTMUX_TCD0_1_bm = (1<<1)          ; TCD0 Signals bit 1 mask
  PORTMUX_TCD0_1_bp = 1               ; TCD0 Signals bit 1 position
  PORTMUX_TCD0_2_bm = (1<<2)          ; TCD0 Signals bit 2 mask
  PORTMUX_TCD0_2_bp = 2               ; TCD0 Signals bit 2 position
  
  ; CCL Look-Up Table 0 Signals select
  PORTMUX_LUT0_DEFAULT_gc = (0x00<<0) ; Out: PA3 In: PA0, PA1, PA2
  PORTMUX_LUT0_ALT1_gc = (0x01<<0)    ; Out: PA6 In: PA0, PA1, PA2
  
  ; CCL Look-Up Table 1 Signals select
  PORTMUX_LUT1_DEFAULT_gc = (0x00<<1) ; Out: PC3 In: PC0, PC1, PC2
  PORTMUX_LUT1_ALT1_gc = (0x01<<1)    ; Out: PC6 In: PC0, PC1, PC2
  
  ; CCL Look-Up Table 2 Signals select
  PORTMUX_LUT2_DEFAULT_gc = (0x00<<2) ; Out: PD3 In: PD0, PD1, PD2
  PORTMUX_LUT2_ALT1_gc = (0x01<<2)    ; Out: PD6 In: PD0, PD1, PD2
  
  ; CCL Look-Up Table 3 Signals select
  PORTMUX_LUT3_DEFAULT_gc = (0x00<<3) ; Out: PF3 In: PF0, PF1, PF2
  
  ; Event Output A select
  PORTMUX_EVOUTA_DEFAULT_gc = (0x00<<0) ; EVOUT on PA2
  PORTMUX_EVOUTA_ALT1_gc = (0x01<<0)  ; EVOUT on PA7
  
  ; Event Output C select
  PORTMUX_EVOUTC_DEFAULT_gc = (0x00<<2) ; EVOUT on PC2
  PORTMUX_EVOUTC_ALT1_gc = (0x01<<2)  ; EVOUT on PC7
  
  ; Event Output D select
  PORTMUX_EVOUTD_DEFAULT_gc = (0x00<<3) ; EVOUT on PD2
  PORTMUX_EVOUTD_ALT1_gc = (0x01<<3)  ; EVOUT on PD7
  
  ; Event Output F select
  PORTMUX_EVOUTF_DEFAULT_gc = (0x00<<5) ; EVOUT on PF2
  
  ; SPI0 Signals select
  PORTMUX_SPI0_DEFAULT_gc = (0x00<<0) ; PA4, PA5, PA6, PA7
  PORTMUX_SPI0_ALT1_gc = (0x01<<0)    ; PE0, PE1, PE2, PE3
  PORTMUX_SPI0_ALT2_gc = (0x02<<0)    ; PG4, PG5, PG6, PG7
  PORTMUX_SPI0_ALT3_gc = (0x03<<0)    ; PA0, PA1, PC0, PC1
  PORTMUX_SPI0_ALT4_gc = (0x04<<0)    ; PD4, PD5, PD6, PD7
  PORTMUX_SPI0_ALT5_gc = (0x05<<0)    ; PC0, PC1, PC2, PC3
  PORTMUX_SPI0_ALT6_gc = (0x06<<0)    ; PC1, PC2, PC3, PF7
  PORTMUX_SPI0_NONE_gc = (0x07<<0)    ; NA, NA, NA, Set to 1
  
  ; TCA0 Signals select
  PORTMUX_TCA0_PORTA_gc = (0x00<<0)   ; PA0, PA1, PA2, PA3, PA4, PA5
  PORTMUX_TCA0_PORTB_gc = (0x01<<0)   ; PB0, PB1, PB2, PB3, PB4, PB5
  PORTMUX_TCA0_PORTC_gc = (0x02<<0)   ; PC0, PC1, PC2, PC3, PC4, PC5
  PORTMUX_TCA0_PORTD_gc = (0x03<<0)   ; PD0, PD1, PD2, PD3, PD4, PD5
  PORTMUX_TCA0_PORTE_gc = (0x04<<0)   ; PE0, PE1, PE2, PE3, PE4, PE5
  PORTMUX_TCA0_PORTF_gc = (0x05<<0)   ; PF0, PF1, PF2, PF3, PF4, PF5
  PORTMUX_TCA0_PORTG_gc = (0x06<<0)   ; PG0, PG1, PG2, PG3, PG4, PG5
  
  ; TCB0 Output select
  PORTMUX_TCB0_DEFAULT_gc = (0x00<<0) ; WO on PA2
  PORTMUX_TCB0_ALT1_gc = (0x01<<0)    ; WO on PF4
  
  ; TCB1 Output select
  PORTMUX_TCB1_DEFAULT_gc = (0x00<<1) ; WO on PA3
  PORTMUX_TCB1_ALT1_gc = (0x01<<1)    ; WO on PF5
  
  ; TCD0 Signals select
  PORTMUX_TCD0_DEFAULT_gc = (0x00<<0) ; PA4, PA5, PA6, PA7
  PORTMUX_TCD0_ALT1_gc = (0x01<<0)    ; PB4, PB5, PB6, PB7
  PORTMUX_TCD0_ALT2_gc = (0x02<<0)    ; PF0, PF1, PF2, PF3
  PORTMUX_TCD0_ALT3_gc = (0x03<<0)    ; PG4, PG5, PG6, PG7
  PORTMUX_TCD0_ALT4_gc = (0x04<<0)    ; PA4, PA5, PD4, PD5
  
  ; TWI0 Signals select
  PORTMUX_TWI0_DEFAULT_gc = (0x00<<0) ; PA2, PA3, PC2, PC3
  PORTMUX_TWI0_ALT1_gc = (0x01<<0)    ; PA2, PA3, PC6, PC7
  PORTMUX_TWI0_ALT2_gc = (0x02<<0)    ; PC2, PC3, PC6, PC7
  PORTMUX_TWI0_ALT3_gc = (0x03<<0)    ; PA0, PA1, PC2, PC3
  
  ; USART0 Signals select
  PORTMUX_USART0_DEFAULT_gc = (0x00<<0) ; PA0, PA1, PA2, PA3
  PORTMUX_USART0_ALT1_gc = (0x01<<0)  ; PA4, PA5, PA6, PA7
  PORTMUX_USART0_ALT2_gc = (0x02<<0)  ; PA2, PA3
  PORTMUX_USART0_ALT3_gc = (0x03<<0)  ; PD4, PD5, PD6, PD7
  PORTMUX_USART0_ALT4_gc = (0x04<<0)  ; PC1, PC2, PC3
  PORTMUX_USART0_NONE_gc = (0x05<<0)  ; Not connected to any pins
  
  ; USART1 Signals select
  PORTMUX_USART1_DEFAULT_gc = (0x00<<3) ; PC0, PC1, PC2, PC3
  PORTMUX_USART1_ALT2_gc = (0x02<<3)  ; PD6, PD7
  PORTMUX_USART1_NONE_gc = (0x03<<3)  ; Not connected to any pins
  
  
  ;*************************************************************************
  ;** RSTCTRL - Reset controller
  ;*************************************************************************
  
  ; RSTCTRL_RSTFR masks
  RSTCTRL_PORF_bm = 0x01              ; Power on Reset flag bit mask
  RSTCTRL_PORF_bp = 0                 ; Power on Reset flag bit position
  RSTCTRL_BORF_bm = 0x02              ; Brown out detector Reset flag bit mask
  RSTCTRL_BORF_bp = 1                 ; Brown out detector Reset flag bit position
  RSTCTRL_EXTRF_bm = 0x04             ; External Reset flag bit mask
  RSTCTRL_EXTRF_bp = 2                ; External Reset flag bit position
  RSTCTRL_WDRF_bm = 0x08              ; Watch dog Reset flag bit mask
  RSTCTRL_WDRF_bp = 3                 ; Watch dog Reset flag bit position
  RSTCTRL_SWRF_bm = 0x10              ; Software Reset flag bit mask
  RSTCTRL_SWRF_bp = 4                 ; Software Reset flag bit position
  RSTCTRL_UPDIRF_bm = 0x20            ; UPDI Reset flag bit mask
  RSTCTRL_UPDIRF_bp = 5               ; UPDI Reset flag bit position
  
  ; RSTCTRL_SWRR masks
  RSTCTRL_SWRST_bm = 0x01             ; Software reset enable bit mask
  RSTCTRL_SWRST_bp = 0                ; Software reset enable bit position
  
  
  ;*************************************************************************
  ;** RTC - Real-Time Counter
  ;*************************************************************************
  
  ; RTC_CTRLA masks
  RTC_RTCEN_bm = 0x01                 ; Enable bit mask
  RTC_RTCEN_bp = 0                    ; Enable bit position
  RTC_CORREN_bm = 0x04                ; Correction enable bit mask
  RTC_CORREN_bp = 2                   ; Correction enable bit position
  RTC_PRESCALER_gm = 0x78             ; Prescaling Factor group mask
  RTC_PRESCALER_gp = 3                ; Prescaling Factor group position
  RTC_PRESCALER_0_bm = (1<<3)         ; Prescaling Factor bit 0 mask
  RTC_PRESCALER_0_bp = 3              ; Prescaling Factor bit 0 position
  RTC_PRESCALER_1_bm = (1<<4)         ; Prescaling Factor bit 1 mask
  RTC_PRESCALER_1_bp = 4              ; Prescaling Factor bit 1 position
  RTC_PRESCALER_2_bm = (1<<5)         ; Prescaling Factor bit 2 mask
  RTC_PRESCALER_2_bp = 5              ; Prescaling Factor bit 2 position
  RTC_PRESCALER_3_bm = (1<<6)         ; Prescaling Factor bit 3 mask
  RTC_PRESCALER_3_bp = 6              ; Prescaling Factor bit 3 position
  RTC_RUNSTDBY_bm = 0x80              ; Run In Standby bit mask
  RTC_RUNSTDBY_bp = 7                 ; Run In Standby bit position
  
  ; RTC_STATUS masks
  RTC_CTRLABUSY_bm = 0x01             ; CTRLA Synchronization Busy Flag bit mask
  RTC_CTRLABUSY_bp = 0                ; CTRLA Synchronization Busy Flag bit position
  RTC_CNTBUSY_bm = 0x02               ; Count Synchronization Busy Flag bit mask
  RTC_CNTBUSY_bp = 1                  ; Count Synchronization Busy Flag bit position
  RTC_PERBUSY_bm = 0x04               ; Period Synchronization Busy Flag bit mask
  RTC_PERBUSY_bp = 2                  ; Period Synchronization Busy Flag bit position
  RTC_CMPBUSY_bm = 0x08               ; Comparator Synchronization Busy Flag bit mask
  RTC_CMPBUSY_bp = 3                  ; Comparator Synchronization Busy Flag bit position
  
  ; RTC_INTCTRL masks
  RTC_OVF_bm = 0x01                   ; Overflow Interrupt enable bit mask
  RTC_OVF_bp = 0                      ; Overflow Interrupt enable bit position
  RTC_CMP_bm = 0x02                   ; Compare Match Interrupt enable bit mask
  RTC_CMP_bp = 1                      ; Compare Match Interrupt enable bit position
  
  ; RTC_INTFLAGS masks
  ; Masks for RTC_OVF already defined
  ; Masks for RTC_CMP already defined
  
  ; RTC_DBGCTRL masks
  RTC_DBGRUN_bm = 0x01                ; Run in debug bit mask
  RTC_DBGRUN_bp = 0                   ; Run in debug bit position
  
  ; RTC_CALIB masks
  RTC_ERROR_gm = 0x7F                 ; Error Correction Value group mask
  RTC_ERROR_gp = 0                    ; Error Correction Value group position
  RTC_ERROR_0_bm = (1<<0)             ; Error Correction Value bit 0 mask
  RTC_ERROR_0_bp = 0                  ; Error Correction Value bit 0 position
  RTC_ERROR_1_bm = (1<<1)             ; Error Correction Value bit 1 mask
  RTC_ERROR_1_bp = 1                  ; Error Correction Value bit 1 position
  RTC_ERROR_2_bm = (1<<2)             ; Error Correction Value bit 2 mask
  RTC_ERROR_2_bp = 2                  ; Error Correction Value bit 2 position
  RTC_ERROR_3_bm = (1<<3)             ; Error Correction Value bit 3 mask
  RTC_ERROR_3_bp = 3                  ; Error Correction Value bit 3 position
  RTC_ERROR_4_bm = (1<<4)             ; Error Correction Value bit 4 mask
  RTC_ERROR_4_bp = 4                  ; Error Correction Value bit 4 position
  RTC_ERROR_5_bm = (1<<5)             ; Error Correction Value bit 5 mask
  RTC_ERROR_5_bp = 5                  ; Error Correction Value bit 5 position
  RTC_ERROR_6_bm = (1<<6)             ; Error Correction Value bit 6 mask
  RTC_ERROR_6_bp = 6                  ; Error Correction Value bit 6 position
  RTC_SIGN_bm = 0x80                  ; Error Correction Sign Bit bit mask
  RTC_SIGN_bp = 7                     ; Error Correction Sign Bit bit position
  
  ; RTC_CLKSEL masks
  RTC_CLKSEL_gm = 0x03                ; Clock Select group mask
  RTC_CLKSEL_gp = 0                   ; Clock Select group position
  RTC_CLKSEL_0_bm = (1<<0)            ; Clock Select bit 0 mask
  RTC_CLKSEL_0_bp = 0                 ; Clock Select bit 0 position
  RTC_CLKSEL_1_bm = (1<<1)            ; Clock Select bit 1 mask
  RTC_CLKSEL_1_bp = 1                 ; Clock Select bit 1 position
  
  ; RTC_PITCTRLA masks
  RTC_PITEN_bm = 0x01                 ; Enable bit mask
  RTC_PITEN_bp = 0                    ; Enable bit position
  RTC_PERIOD_gm = 0x78                ; Period group mask
  RTC_PERIOD_gp = 3                   ; Period group position
  RTC_PERIOD_0_bm = (1<<3)            ; Period bit 0 mask
  RTC_PERIOD_0_bp = 3                 ; Period bit 0 position
  RTC_PERIOD_1_bm = (1<<4)            ; Period bit 1 mask
  RTC_PERIOD_1_bp = 4                 ; Period bit 1 position
  RTC_PERIOD_2_bm = (1<<5)            ; Period bit 2 mask
  RTC_PERIOD_2_bp = 5                 ; Period bit 2 position
  RTC_PERIOD_3_bm = (1<<6)            ; Period bit 3 mask
  RTC_PERIOD_3_bp = 6                 ; Period bit 3 position
  
  ; RTC_PITSTATUS masks
  RTC_CTRLBUSY_bm = 0x01              ; CTRLA Synchronization Busy Flag bit mask
  RTC_CTRLBUSY_bp = 0                 ; CTRLA Synchronization Busy Flag bit position
  
  ; RTC_PITINTCTRL masks
  RTC_PI_bm = 0x01                    ; Periodic Interrupt bit mask
  RTC_PI_bp = 0                       ; Periodic Interrupt bit position
  
  ; RTC_PITINTFLAGS masks
  ; Masks for RTC_PI already defined
  
  ; RTC_PITDBGCTRL masks
  ; Masks for RTC_DBGRUN already defined
  
  ; Clock Select
  RTC_CLKSEL_OSC32K_gc = (0x00<<0)    ; 32.768 kHz from OSC32K
  RTC_CLKSEL_OSC1K_gc = (0x01<<0)     ; 1.024 kHz from OSC32K
  RTC_CLKSEL_XTAL32K_gc = (0x02<<0)   ; 32.768 kHz from XOSC32K
  RTC_CLKSEL_EXTCLK_gc = (0x03<<0)    ; External Clock
  
  ; Prescaling Factor select
  RTC_PRESCALER_DIV1_gc = (0x00<<3)   ; RTC Clock / 1
  RTC_PRESCALER_DIV2_gc = (0x01<<3)   ; RTC Clock / 2
  RTC_PRESCALER_DIV4_gc = (0x02<<3)   ; RTC Clock / 4
  RTC_PRESCALER_DIV8_gc = (0x03<<3)   ; RTC Clock / 8
  RTC_PRESCALER_DIV16_gc = (0x04<<3)  ; RTC Clock / 16
  RTC_PRESCALER_DIV32_gc = (0x05<<3)  ; RTC Clock / 32
  RTC_PRESCALER_DIV64_gc = (0x06<<3)  ; RTC Clock / 64
  RTC_PRESCALER_DIV128_gc = (0x07<<3) ; RTC Clock / 128
  RTC_PRESCALER_DIV256_gc = (0x08<<3) ; RTC Clock / 256
  RTC_PRESCALER_DIV512_gc = (0x09<<3) ; RTC Clock / 512
  RTC_PRESCALER_DIV1024_gc = (0x0A<<3) ; RTC Clock / 1024
  RTC_PRESCALER_DIV2048_gc = (0x0B<<3) ; RTC Clock / 2048
  RTC_PRESCALER_DIV4096_gc = (0x0C<<3) ; RTC Clock / 4096
  RTC_PRESCALER_DIV8192_gc = (0x0D<<3) ; RTC Clock / 8192
  RTC_PRESCALER_DIV16384_gc = (0x0E<<3) ; RTC Clock / 16384
  RTC_PRESCALER_DIV32768_gc = (0x0F<<3) ; RTC Clock / 32768
  
  ; Period select
  RTC_PERIOD_OFF_gc = (0x00<<3)       ; Off
  RTC_PERIOD_CYC4_gc = (0x01<<3)      ; RTC Clock Cycles 4
  RTC_PERIOD_CYC8_gc = (0x02<<3)      ; RTC Clock Cycles 8
  RTC_PERIOD_CYC16_gc = (0x03<<3)     ; RTC Clock Cycles 16
  RTC_PERIOD_CYC32_gc = (0x04<<3)     ; RTC Clock Cycles 32
  RTC_PERIOD_CYC64_gc = (0x05<<3)     ; RTC Clock Cycles 64
  RTC_PERIOD_CYC128_gc = (0x06<<3)    ; RTC Clock Cycles 128
  RTC_PERIOD_CYC256_gc = (0x07<<3)    ; RTC Clock Cycles 256
  RTC_PERIOD_CYC512_gc = (0x08<<3)    ; RTC Clock Cycles 512
  RTC_PERIOD_CYC1024_gc = (0x09<<3)   ; RTC Clock Cycles 1024
  RTC_PERIOD_CYC2048_gc = (0x0A<<3)   ; RTC Clock Cycles 2048
  RTC_PERIOD_CYC4096_gc = (0x0B<<3)   ; RTC Clock Cycles 4096
  RTC_PERIOD_CYC8192_gc = (0x0C<<3)   ; RTC Clock Cycles 8192
  RTC_PERIOD_CYC16384_gc = (0x0D<<3)  ; RTC Clock Cycles 16384
  RTC_PERIOD_CYC32768_gc = (0x0E<<3)  ; RTC Clock Cycles 32768
  
  
  ;*************************************************************************
  ;** SIGROW - Signature row
  ;*************************************************************************
  
  ; SIGROW_TEMPSENSE0 masks
  SIGROW_TEMPSENSE0_gm = 0xFFFF       ; Temperature Calibration 0 group mask
  SIGROW_TEMPSENSE0_gp = 0            ; Temperature Calibration 0 group position
  SIGROW_TEMPSENSE0_0_bm = (1<<0)     ; Temperature Calibration 0 bit 0 mask
  SIGROW_TEMPSENSE0_0_bp = 0          ; Temperature Calibration 0 bit 0 position
  SIGROW_TEMPSENSE0_1_bm = (1<<1)     ; Temperature Calibration 0 bit 1 mask
  SIGROW_TEMPSENSE0_1_bp = 1          ; Temperature Calibration 0 bit 1 position
  SIGROW_TEMPSENSE0_2_bm = (1<<2)     ; Temperature Calibration 0 bit 2 mask
  SIGROW_TEMPSENSE0_2_bp = 2          ; Temperature Calibration 0 bit 2 position
  SIGROW_TEMPSENSE0_3_bm = (1<<3)     ; Temperature Calibration 0 bit 3 mask
  SIGROW_TEMPSENSE0_3_bp = 3          ; Temperature Calibration 0 bit 3 position
  SIGROW_TEMPSENSE0_4_bm = (1<<4)     ; Temperature Calibration 0 bit 4 mask
  SIGROW_TEMPSENSE0_4_bp = 4          ; Temperature Calibration 0 bit 4 position
  SIGROW_TEMPSENSE0_5_bm = (1<<5)     ; Temperature Calibration 0 bit 5 mask
  SIGROW_TEMPSENSE0_5_bp = 5          ; Temperature Calibration 0 bit 5 position
  SIGROW_TEMPSENSE0_6_bm = (1<<6)     ; Temperature Calibration 0 bit 6 mask
  SIGROW_TEMPSENSE0_6_bp = 6          ; Temperature Calibration 0 bit 6 position
  SIGROW_TEMPSENSE0_7_bm = (1<<7)     ; Temperature Calibration 0 bit 7 mask
  SIGROW_TEMPSENSE0_7_bp = 7          ; Temperature Calibration 0 bit 7 position
  SIGROW_TEMPSENSE0_8_bm = (1<<8)     ; Temperature Calibration 0 bit 8 mask
  SIGROW_TEMPSENSE0_8_bp = 8          ; Temperature Calibration 0 bit 8 position
  SIGROW_TEMPSENSE0_9_bm = (1<<9)     ; Temperature Calibration 0 bit 9 mask
  SIGROW_TEMPSENSE0_9_bp = 9          ; Temperature Calibration 0 bit 9 position
  SIGROW_TEMPSENSE0_10_bm = (1<<10)   ; Temperature Calibration 0 bit 10 mask
  SIGROW_TEMPSENSE0_10_bp = 10        ; Temperature Calibration 0 bit 10 position
  SIGROW_TEMPSENSE0_11_bm = (1<<11)   ; Temperature Calibration 0 bit 11 mask
  SIGROW_TEMPSENSE0_11_bp = 11        ; Temperature Calibration 0 bit 11 position
  SIGROW_TEMPSENSE0_12_bm = (1<<12)   ; Temperature Calibration 0 bit 12 mask
  SIGROW_TEMPSENSE0_12_bp = 12        ; Temperature Calibration 0 bit 12 position
  SIGROW_TEMPSENSE0_13_bm = (1<<13)   ; Temperature Calibration 0 bit 13 mask
  SIGROW_TEMPSENSE0_13_bp = 13        ; Temperature Calibration 0 bit 13 position
  SIGROW_TEMPSENSE0_14_bm = (1<<14)   ; Temperature Calibration 0 bit 14 mask
  SIGROW_TEMPSENSE0_14_bp = 14        ; Temperature Calibration 0 bit 14 position
  SIGROW_TEMPSENSE0_15_bm = (1<<15)   ; Temperature Calibration 0 bit 15 mask
  SIGROW_TEMPSENSE0_15_bp = 15        ; Temperature Calibration 0 bit 15 position
  
  ; SIGROW_TEMPSENSE1 masks
  SIGROW_TEMPSENSE1_gm = 0xFFFF       ; Temperature Calibration 1 group mask
  SIGROW_TEMPSENSE1_gp = 0            ; Temperature Calibration 1 group position
  SIGROW_TEMPSENSE1_0_bm = (1<<0)     ; Temperature Calibration 1 bit 0 mask
  SIGROW_TEMPSENSE1_0_bp = 0          ; Temperature Calibration 1 bit 0 position
  SIGROW_TEMPSENSE1_1_bm = (1<<1)     ; Temperature Calibration 1 bit 1 mask
  SIGROW_TEMPSENSE1_1_bp = 1          ; Temperature Calibration 1 bit 1 position
  SIGROW_TEMPSENSE1_2_bm = (1<<2)     ; Temperature Calibration 1 bit 2 mask
  SIGROW_TEMPSENSE1_2_bp = 2          ; Temperature Calibration 1 bit 2 position
  SIGROW_TEMPSENSE1_3_bm = (1<<3)     ; Temperature Calibration 1 bit 3 mask
  SIGROW_TEMPSENSE1_3_bp = 3          ; Temperature Calibration 1 bit 3 position
  SIGROW_TEMPSENSE1_4_bm = (1<<4)     ; Temperature Calibration 1 bit 4 mask
  SIGROW_TEMPSENSE1_4_bp = 4          ; Temperature Calibration 1 bit 4 position
  SIGROW_TEMPSENSE1_5_bm = (1<<5)     ; Temperature Calibration 1 bit 5 mask
  SIGROW_TEMPSENSE1_5_bp = 5          ; Temperature Calibration 1 bit 5 position
  SIGROW_TEMPSENSE1_6_bm = (1<<6)     ; Temperature Calibration 1 bit 6 mask
  SIGROW_TEMPSENSE1_6_bp = 6          ; Temperature Calibration 1 bit 6 position
  SIGROW_TEMPSENSE1_7_bm = (1<<7)     ; Temperature Calibration 1 bit 7 mask
  SIGROW_TEMPSENSE1_7_bp = 7          ; Temperature Calibration 1 bit 7 position
  SIGROW_TEMPSENSE1_8_bm = (1<<8)     ; Temperature Calibration 1 bit 8 mask
  SIGROW_TEMPSENSE1_8_bp = 8          ; Temperature Calibration 1 bit 8 position
  SIGROW_TEMPSENSE1_9_bm = (1<<9)     ; Temperature Calibration 1 bit 9 mask
  SIGROW_TEMPSENSE1_9_bp = 9          ; Temperature Calibration 1 bit 9 position
  SIGROW_TEMPSENSE1_10_bm = (1<<10)   ; Temperature Calibration 1 bit 10 mask
  SIGROW_TEMPSENSE1_10_bp = 10        ; Temperature Calibration 1 bit 10 position
  SIGROW_TEMPSENSE1_11_bm = (1<<11)   ; Temperature Calibration 1 bit 11 mask
  SIGROW_TEMPSENSE1_11_bp = 11        ; Temperature Calibration 1 bit 11 position
  SIGROW_TEMPSENSE1_12_bm = (1<<12)   ; Temperature Calibration 1 bit 12 mask
  SIGROW_TEMPSENSE1_12_bp = 12        ; Temperature Calibration 1 bit 12 position
  SIGROW_TEMPSENSE1_13_bm = (1<<13)   ; Temperature Calibration 1 bit 13 mask
  SIGROW_TEMPSENSE1_13_bp = 13        ; Temperature Calibration 1 bit 13 position
  SIGROW_TEMPSENSE1_14_bm = (1<<14)   ; Temperature Calibration 1 bit 14 mask
  SIGROW_TEMPSENSE1_14_bp = 14        ; Temperature Calibration 1 bit 14 position
  SIGROW_TEMPSENSE1_15_bm = (1<<15)   ; Temperature Calibration 1 bit 15 mask
  SIGROW_TEMPSENSE1_15_bp = 15        ; Temperature Calibration 1 bit 15 position
  
  
  ;*************************************************************************
  ;** SLPCTRL - Sleep Controller
  ;*************************************************************************
  
  ; SLPCTRL_CTRLA masks
  SLPCTRL_SEN_bm = 0x01               ; Sleep enable bit mask
  SLPCTRL_SEN_bp = 0                  ; Sleep enable bit position
  SLPCTRL_SMODE_gm = 0x06             ; Sleep mode group mask
  SLPCTRL_SMODE_gp = 1                ; Sleep mode group position
  SLPCTRL_SMODE_0_bm = (1<<1)         ; Sleep mode bit 0 mask
  SLPCTRL_SMODE_0_bp = 1              ; Sleep mode bit 0 position
  SLPCTRL_SMODE_1_bm = (1<<2)         ; Sleep mode bit 1 mask
  SLPCTRL_SMODE_1_bp = 2              ; Sleep mode bit 1 position
  
  ; SLPCTRL_VREGCTRL masks
  SLPCTRL_PMODE_gm = 0x07             ; Performance Mode group mask
  SLPCTRL_PMODE_gp = 0                ; Performance Mode group position
  SLPCTRL_PMODE_0_bm = (1<<0)         ; Performance Mode bit 0 mask
  SLPCTRL_PMODE_0_bp = 0              ; Performance Mode bit 0 position
  SLPCTRL_PMODE_1_bm = (1<<1)         ; Performance Mode bit 1 mask
  SLPCTRL_PMODE_1_bp = 1              ; Performance Mode bit 1 position
  SLPCTRL_PMODE_2_bm = (1<<2)         ; Performance Mode bit 2 mask
  SLPCTRL_PMODE_2_bp = 2              ; Performance Mode bit 2 position
  SLPCTRL_HTLLEN_bm = 0x10            ; High Temperature Low Leakage Enable bit mask
  SLPCTRL_HTLLEN_bp = 4               ; High Temperature Low Leakage Enable bit position
  
  ; Sleep mode select
  SLPCTRL_SMODE_IDLE_gc = (0x00<<1)   ; Idle mode
  SLPCTRL_SMODE_STDBY_gc = (0x01<<1)  ; Standby Mode
  SLPCTRL_SMODE_PDOWN_gc = (0x02<<1)  ; Power-down Mode
  
  ; High Temperature Low Leakage Enable select
  SLPCTRL_HTLLEN_OFF_gc = (0x00<<4)   ; Disabled
  SLPCTRL_HTLLEN_ON_gc = (0x01<<4)    ; Enabled
  
  ; Performance Mode select
  SLPCTRL_PMODE_AUTO_gc = (0x00<<0)   ;
  SLPCTRL_PMODE_FULL_gc = (0x01<<0)   ;
  
  
  ;*************************************************************************
  ;** SPI - Serial Peripheral Interface
  ;*************************************************************************
  
  ; SPI_CTRLA masks
  SPI_ENABLE_bm = 0x01                ; Enable Module bit mask
  SPI_ENABLE_bp = 0                   ; Enable Module bit position
  SPI_PRESC_gm = 0x06                 ; Prescaler group mask
  SPI_PRESC_gp = 1                    ; Prescaler group position
  SPI_PRESC_0_bm = (1<<1)             ; Prescaler bit 0 mask
  SPI_PRESC_0_bp = 1                  ; Prescaler bit 0 position
  SPI_PRESC_1_bm = (1<<2)             ; Prescaler bit 1 mask
  SPI_PRESC_1_bp = 2                  ; Prescaler bit 1 position
  SPI_CLK2X_bm = 0x10                 ; Enable Double Speed bit mask
  SPI_CLK2X_bp = 4                    ; Enable Double Speed bit position
  SPI_MASTER_bm = 0x20                ; Host Operation Enable bit mask
  SPI_MASTER_bp = 5                   ; Host Operation Enable bit position
  SPI_DORD_bm = 0x40                  ; Data Order Setting bit mask
  SPI_DORD_bp = 6                     ; Data Order Setting bit position
  
  ; SPI_CTRLB masks
  SPI_MODE_gm = 0x03                  ; SPI Mode group mask
  SPI_MODE_gp = 0                     ; SPI Mode group position
  SPI_MODE_0_bm = (1<<0)              ; SPI Mode bit 0 mask
  SPI_MODE_0_bp = 0                   ; SPI Mode bit 0 position
  SPI_MODE_1_bm = (1<<1)              ; SPI Mode bit 1 mask
  SPI_MODE_1_bp = 1                   ; SPI Mode bit 1 position
  SPI_SSD_bm = 0x04                   ; SPI Select Disable bit mask
  SPI_SSD_bp = 2                      ; SPI Select Disable bit position
  SPI_BUFWR_bm = 0x40                 ; Buffer Mode Wait for Receive bit mask
  SPI_BUFWR_bp = 6                    ; Buffer Mode Wait for Receive bit position
  SPI_BUFEN_bm = 0x80                 ; Buffer Mode Enable bit mask
  SPI_BUFEN_bp = 7                    ; Buffer Mode Enable bit position
  
  ; SPI_INTCTRL masks
  SPI_IE_bm = 0x01                    ; Interrupt Enable bit mask
  SPI_IE_bp = 0                       ; Interrupt Enable bit position
  SPI_SSIE_bm = 0x10                  ; SPI Select Trigger Interrupt Enable bit mask
  SPI_SSIE_bp = 4                     ; SPI Select Trigger Interrupt Enable bit position
  SPI_DREIE_bm = 0x20                 ; Data Register Empty Interrupt Enable bit mask
  SPI_DREIE_bp = 5                    ; Data Register Empty Interrupt Enable bit position
  SPI_TXCIE_bm = 0x40                 ; Transfer Complete Interrupt Enable bit mask
  SPI_TXCIE_bp = 6                    ; Transfer Complete Interrupt Enable bit position
  SPI_RXCIE_bm = 0x80                 ; Receive Complete Interrupt Enable bit mask
  SPI_RXCIE_bp = 7                    ; Receive Complete Interrupt Enable bit position
  
  ; SPI_INTFLAGS masks
  SPI_BUFOVF_bm = 0x01                ; Buffer Overflow bit mask
  SPI_BUFOVF_bp = 0                   ; Buffer Overflow bit position
  SPI_SSIF_bm = 0x10                  ; SPI Select Trigger Interrupt Flag bit mask
  SPI_SSIF_bp = 4                     ; SPI Select Trigger Interrupt Flag bit position
  SPI_DREIF_bm = 0x20                 ; Data Register Empty Interrupt Flag bit mask
  SPI_DREIF_bp = 5                    ; Data Register Empty Interrupt Flag bit position
  SPI_TXCIF_bm = 0x40                 ; Transfer Complete Interrupt Flag bit mask
  SPI_TXCIF_bp = 6                    ; Transfer Complete Interrupt Flag bit position
  SPI_WRCOL_bm = 0x40                 ; Write Collision bit mask
  SPI_WRCOL_bp = 6                    ; Write Collision bit position
  SPI_RXCIF_bm = 0x80                 ; Receive Complete Interrupt Flag bit mask
  SPI_RXCIF_bp = 7                    ; Receive Complete Interrupt Flag bit position
  SPI_IF_bm = 0x80                    ; Interrupt Flag bit mask
  SPI_IF_bp = 7                       ; Interrupt Flag bit position
  
  ; Prescaler select
  SPI_PRESC_DIV4_gc = (0x00<<1)       ; CLK_PER / 4
  SPI_PRESC_DIV16_gc = (0x01<<1)      ; CLK_PER / 16
  SPI_PRESC_DIV64_gc = (0x02<<1)      ; CLK_PER / 64
  SPI_PRESC_DIV128_gc = (0x03<<1)     ; CLK_PER / 128
  
  ; SPI Mode select
  SPI_MODE_0_gc = (0x00<<0)           ; SPI Mode 0
  SPI_MODE_1_gc = (0x01<<0)           ; SPI Mode 1
  SPI_MODE_2_gc = (0x02<<0)           ; SPI Mode 2
  SPI_MODE_3_gc = (0x03<<0)           ; SPI Mode 3
  
  
  ;*************************************************************************
  ;** SYSCFG - System Configuration Registers
  ;*************************************************************************
  
  ; SYSCFG_OCDMSTATUS masks
  SYSCFG_VALID_bm = 0x01              ; OCD Message Valid bit mask
  SYSCFG_VALID_bp = 0                 ; OCD Message Valid bit position
  
  
  ;*************************************************************************
  ;** TCA - 16-bit Timer/Counter Type A
  ;*************************************************************************
  
  ; TCA_SINGLE_CTRLA masks
  TCA_SINGLE_ENABLE_bm = 0x01         ; Module Enable bit mask
  TCA_SINGLE_ENABLE_bp = 0            ; Module Enable bit position
  TCA_SINGLE_CLKSEL_gm = 0x0E         ; Clock Selection group mask
  TCA_SINGLE_CLKSEL_gp = 1            ; Clock Selection group position
  TCA_SINGLE_CLKSEL_0_bm = (1<<1)     ; Clock Selection bit 0 mask
  TCA_SINGLE_CLKSEL_0_bp = 1          ; Clock Selection bit 0 position
  TCA_SINGLE_CLKSEL_1_bm = (1<<2)     ; Clock Selection bit 1 mask
  TCA_SINGLE_CLKSEL_1_bp = 2          ; Clock Selection bit 1 position
  TCA_SINGLE_CLKSEL_2_bm = (1<<3)     ; Clock Selection bit 2 mask
  TCA_SINGLE_CLKSEL_2_bp = 3          ; Clock Selection bit 2 position
  TCA_SINGLE_RUNSTDBY_bm = 0x80       ; Run in Standby bit mask
  TCA_SINGLE_RUNSTDBY_bp = 7          ; Run in Standby bit position
  
  ; TCA_SINGLE_CTRLB masks
  TCA_SINGLE_WGMODE_gm = 0x07         ; Waveform generation mode group mask
  TCA_SINGLE_WGMODE_gp = 0            ; Waveform generation mode group position
  TCA_SINGLE_WGMODE_0_bm = (1<<0)     ; Waveform generation mode bit 0 mask
  TCA_SINGLE_WGMODE_0_bp = 0          ; Waveform generation mode bit 0 position
  TCA_SINGLE_WGMODE_1_bm = (1<<1)     ; Waveform generation mode bit 1 mask
  TCA_SINGLE_WGMODE_1_bp = 1          ; Waveform generation mode bit 1 position
  TCA_SINGLE_WGMODE_2_bm = (1<<2)     ; Waveform generation mode bit 2 mask
  TCA_SINGLE_WGMODE_2_bp = 2          ; Waveform generation mode bit 2 position
  TCA_SINGLE_ALUPD_bm = 0x08          ; Auto Lock Update bit mask
  TCA_SINGLE_ALUPD_bp = 3             ; Auto Lock Update bit position
  TCA_SINGLE_CMP0EN_bm = 0x10         ; Compare 0 Enable bit mask
  TCA_SINGLE_CMP0EN_bp = 4            ; Compare 0 Enable bit position
  TCA_SINGLE_CMP1EN_bm = 0x20         ; Compare 1 Enable bit mask
  TCA_SINGLE_CMP1EN_bp = 5            ; Compare 1 Enable bit position
  TCA_SINGLE_CMP2EN_bm = 0x40         ; Compare 2 Enable bit mask
  TCA_SINGLE_CMP2EN_bp = 6            ; Compare 2 Enable bit position
  
  ; TCA_SINGLE_CTRLC masks
  TCA_SINGLE_CMP0OV_bm = 0x01         ; Compare 0 Waveform Output Value bit mask
  TCA_SINGLE_CMP0OV_bp = 0            ; Compare 0 Waveform Output Value bit position
  TCA_SINGLE_CMP1OV_bm = 0x02         ; Compare 1 Waveform Output Value bit mask
  TCA_SINGLE_CMP1OV_bp = 1            ; Compare 1 Waveform Output Value bit position
  TCA_SINGLE_CMP2OV_bm = 0x04         ; Compare 2 Waveform Output Value bit mask
  TCA_SINGLE_CMP2OV_bp = 2            ; Compare 2 Waveform Output Value bit position
  
  ; TCA_SINGLE_CTRLD masks
  TCA_SINGLE_SPLITM_bm = 0x01         ; Split Mode Enable bit mask
  TCA_SINGLE_SPLITM_bp = 0            ; Split Mode Enable bit position
  
  ; TCA_SINGLE_CTRLECLR masks
  TCA_SINGLE_DIR_bm = 0x01            ; Direction bit mask
  TCA_SINGLE_DIR_bp = 0               ; Direction bit position
  TCA_SINGLE_LUPD_bm = 0x02           ; Lock Update bit mask
  TCA_SINGLE_LUPD_bp = 1              ; Lock Update bit position
  TCA_SINGLE_CMD_gm = 0x0C            ; Command group mask
  TCA_SINGLE_CMD_gp = 2               ; Command group position
  TCA_SINGLE_CMD_0_bm = (1<<2)        ; Command bit 0 mask
  TCA_SINGLE_CMD_0_bp = 2             ; Command bit 0 position
  TCA_SINGLE_CMD_1_bm = (1<<3)        ; Command bit 1 mask
  TCA_SINGLE_CMD_1_bp = 3             ; Command bit 1 position
  
  ; TCA_SINGLE_CTRLESET masks
  ; Masks for TCA_SINGLE_DIR already defined
  ; Masks for TCA_SINGLE_LUPD already defined
  ; Masks for TCA_SINGLE_CMD already defined
  
  ; TCA_SINGLE_CTRLFCLR masks
  TCA_SINGLE_PERBV_bm = 0x01          ; Period Buffer Valid bit mask
  TCA_SINGLE_PERBV_bp = 0             ; Period Buffer Valid bit position
  TCA_SINGLE_CMP0BV_bm = 0x02         ; Compare 0 Buffer Valid bit mask
  TCA_SINGLE_CMP0BV_bp = 1            ; Compare 0 Buffer Valid bit position
  TCA_SINGLE_CMP1BV_bm = 0x04         ; Compare 1 Buffer Valid bit mask
  TCA_SINGLE_CMP1BV_bp = 2            ; Compare 1 Buffer Valid bit position
  TCA_SINGLE_CMP2BV_bm = 0x08         ; Compare 2 Buffer Valid bit mask
  TCA_SINGLE_CMP2BV_bp = 3            ; Compare 2 Buffer Valid bit position
  
  ; TCA_SINGLE_CTRLFSET masks
  ; Masks for TCA_SINGLE_PERBV already defined
  ; Masks for TCA_SINGLE_CMP0BV already defined
  ; Masks for TCA_SINGLE_CMP1BV already defined
  ; Masks for TCA_SINGLE_CMP2BV already defined
  
  ; TCA_SINGLE_EVCTRL masks
  TCA_SINGLE_CNTAEI_bm = 0x01         ; Count on Event Input A bit mask
  TCA_SINGLE_CNTAEI_bp = 0            ; Count on Event Input A bit position
  TCA_SINGLE_EVACTA_gm = 0x0E         ; Event Action A group mask
  TCA_SINGLE_EVACTA_gp = 1            ; Event Action A group position
  TCA_SINGLE_EVACTA_0_bm = (1<<1)     ; Event Action A bit 0 mask
  TCA_SINGLE_EVACTA_0_bp = 1          ; Event Action A bit 0 position
  TCA_SINGLE_EVACTA_1_bm = (1<<2)     ; Event Action A bit 1 mask
  TCA_SINGLE_EVACTA_1_bp = 2          ; Event Action A bit 1 position
  TCA_SINGLE_EVACTA_2_bm = (1<<3)     ; Event Action A bit 2 mask
  TCA_SINGLE_EVACTA_2_bp = 3          ; Event Action A bit 2 position
  TCA_SINGLE_CNTBEI_bm = 0x10         ; Count on Event Input B bit mask
  TCA_SINGLE_CNTBEI_bp = 4            ; Count on Event Input B bit position
  TCA_SINGLE_EVACTB_gm = 0xE0         ; Event Action B group mask
  TCA_SINGLE_EVACTB_gp = 5            ; Event Action B group position
  TCA_SINGLE_EVACTB_0_bm = (1<<5)     ; Event Action B bit 0 mask
  TCA_SINGLE_EVACTB_0_bp = 5          ; Event Action B bit 0 position
  TCA_SINGLE_EVACTB_1_bm = (1<<6)     ; Event Action B bit 1 mask
  TCA_SINGLE_EVACTB_1_bp = 6          ; Event Action B bit 1 position
  TCA_SINGLE_EVACTB_2_bm = (1<<7)     ; Event Action B bit 2 mask
  TCA_SINGLE_EVACTB_2_bp = 7          ; Event Action B bit 2 position
  
  ; TCA_SINGLE_INTCTRL masks
  TCA_SINGLE_OVF_bm = 0x01            ; Overflow Interrupt bit mask
  TCA_SINGLE_OVF_bp = 0               ; Overflow Interrupt bit position
  TCA_SINGLE_CMP0_bm = 0x10           ; Compare 0 Interrupt bit mask
  TCA_SINGLE_CMP0_bp = 4              ; Compare 0 Interrupt bit position
  TCA_SINGLE_CMP1_bm = 0x20           ; Compare 1 Interrupt bit mask
  TCA_SINGLE_CMP1_bp = 5              ; Compare 1 Interrupt bit position
  TCA_SINGLE_CMP2_bm = 0x40           ; Compare 2 Interrupt bit mask
  TCA_SINGLE_CMP2_bp = 6              ; Compare 2 Interrupt bit position
  
  ; TCA_SINGLE_INTFLAGS masks
  ; Masks for TCA_SINGLE_OVF already defined
  ; Masks for TCA_SINGLE_CMP0 already defined
  ; Masks for TCA_SINGLE_CMP1 already defined
  ; Masks for TCA_SINGLE_CMP2 already defined
  
  ; TCA_SINGLE_DBGCTRL masks
  TCA_SINGLE_DBGRUN_bm = 0x01         ; Debug Run bit mask
  TCA_SINGLE_DBGRUN_bp = 0            ; Debug Run bit position
  
  ; Masks for CTRLA already defined
  ; Masks for CTRLB already defined
  ; Masks for CTRLC already defined
  ; Masks for CTRLD already defined
  ; Masks for CTRLECLR already defined
  ; Masks for CTRLESET already defined
  ; Masks for INTCTRL already defined
  ; Masks for INTFLAGS already defined
  ; Masks for DBGCTRL already defined
  ; TCA_SPLIT_CTRLA masks
  TCA_SPLIT_ENABLE_bm = 0x01          ; Module Enable bit mask
  TCA_SPLIT_ENABLE_bp = 0             ; Module Enable bit position
  TCA_SPLIT_CLKSEL_gm = 0x0E          ; Clock Selection group mask
  TCA_SPLIT_CLKSEL_gp = 1             ; Clock Selection group position
  TCA_SPLIT_CLKSEL_0_bm = (1<<1)      ; Clock Selection bit 0 mask
  TCA_SPLIT_CLKSEL_0_bp = 1           ; Clock Selection bit 0 position
  TCA_SPLIT_CLKSEL_1_bm = (1<<2)      ; Clock Selection bit 1 mask
  TCA_SPLIT_CLKSEL_1_bp = 2           ; Clock Selection bit 1 position
  TCA_SPLIT_CLKSEL_2_bm = (1<<3)      ; Clock Selection bit 2 mask
  TCA_SPLIT_CLKSEL_2_bp = 3           ; Clock Selection bit 2 position
  TCA_SPLIT_RUNSTDBY_bm = 0x80        ; Run in Standby bit mask
  TCA_SPLIT_RUNSTDBY_bp = 7           ; Run in Standby bit position
  
  ; TCA_SPLIT_CTRLB masks
  TCA_SPLIT_LCMP0EN_bm = 0x01         ; Low Compare 0 Enable bit mask
  TCA_SPLIT_LCMP0EN_bp = 0            ; Low Compare 0 Enable bit position
  TCA_SPLIT_LCMP1EN_bm = 0x02         ; Low Compare 1 Enable bit mask
  TCA_SPLIT_LCMP1EN_bp = 1            ; Low Compare 1 Enable bit position
  TCA_SPLIT_LCMP2EN_bm = 0x04         ; Low Compare 2 Enable bit mask
  TCA_SPLIT_LCMP2EN_bp = 2            ; Low Compare 2 Enable bit position
  TCA_SPLIT_HCMP0EN_bm = 0x10         ; High Compare 0 Enable bit mask
  TCA_SPLIT_HCMP0EN_bp = 4            ; High Compare 0 Enable bit position
  TCA_SPLIT_HCMP1EN_bm = 0x20         ; High Compare 1 Enable bit mask
  TCA_SPLIT_HCMP1EN_bp = 5            ; High Compare 1 Enable bit position
  TCA_SPLIT_HCMP2EN_bm = 0x40         ; High Compare 2 Enable bit mask
  TCA_SPLIT_HCMP2EN_bp = 6            ; High Compare 2 Enable bit position
  
  ; TCA_SPLIT_CTRLC masks
  TCA_SPLIT_LCMP0OV_bm = 0x01         ; Low Compare 0 Output Value bit mask
  TCA_SPLIT_LCMP0OV_bp = 0            ; Low Compare 0 Output Value bit position
  TCA_SPLIT_LCMP1OV_bm = 0x02         ; Low Compare 1 Output Value bit mask
  TCA_SPLIT_LCMP1OV_bp = 1            ; Low Compare 1 Output Value bit position
  TCA_SPLIT_LCMP2OV_bm = 0x04         ; Low Compare 2 Output Value bit mask
  TCA_SPLIT_LCMP2OV_bp = 2            ; Low Compare 2 Output Value bit position
  TCA_SPLIT_HCMP0OV_bm = 0x10         ; High Compare 0 Output Value bit mask
  TCA_SPLIT_HCMP0OV_bp = 4            ; High Compare 0 Output Value bit position
  TCA_SPLIT_HCMP1OV_bm = 0x20         ; High Compare 1 Output Value bit mask
  TCA_SPLIT_HCMP1OV_bp = 5            ; High Compare 1 Output Value bit position
  TCA_SPLIT_HCMP2OV_bm = 0x40         ; High Compare 2 Output Value bit mask
  TCA_SPLIT_HCMP2OV_bp = 6            ; High Compare 2 Output Value bit position
  
  ; TCA_SPLIT_CTRLD masks
  TCA_SPLIT_SPLITM_bm = 0x01          ; Split Mode Enable bit mask
  TCA_SPLIT_SPLITM_bp = 0             ; Split Mode Enable bit position
  
  ; TCA_SPLIT_CTRLECLR masks
  TCA_SPLIT_CMDEN_gm = 0x03           ; Command Enable group mask
  TCA_SPLIT_CMDEN_gp = 0              ; Command Enable group position
  TCA_SPLIT_CMDEN_0_bm = (1<<0)       ; Command Enable bit 0 mask
  TCA_SPLIT_CMDEN_0_bp = 0            ; Command Enable bit 0 position
  TCA_SPLIT_CMDEN_1_bm = (1<<1)       ; Command Enable bit 1 mask
  TCA_SPLIT_CMDEN_1_bp = 1            ; Command Enable bit 1 position
  TCA_SPLIT_CMD_gm = 0x0C             ; Command group mask
  TCA_SPLIT_CMD_gp = 2                ; Command group position
  TCA_SPLIT_CMD_0_bm = (1<<2)         ; Command bit 0 mask
  TCA_SPLIT_CMD_0_bp = 2              ; Command bit 0 position
  TCA_SPLIT_CMD_1_bm = (1<<3)         ; Command bit 1 mask
  TCA_SPLIT_CMD_1_bp = 3              ; Command bit 1 position
  
  ; TCA_SPLIT_CTRLESET masks
  ; Masks for TCA_SPLIT_CMDEN already defined
  ; Masks for TCA_SPLIT_CMD already defined
  
  ; TCA_SPLIT_INTCTRL masks
  TCA_SPLIT_LUNF_bm = 0x01            ; Low Underflow Interrupt Enable bit mask
  TCA_SPLIT_LUNF_bp = 0               ; Low Underflow Interrupt Enable bit position
  TCA_SPLIT_HUNF_bm = 0x02            ; High Underflow Interrupt Enable bit mask
  TCA_SPLIT_HUNF_bp = 1               ; High Underflow Interrupt Enable bit position
  TCA_SPLIT_LCMP0_bm = 0x10           ; Low Compare 0 Interrupt Enable bit mask
  TCA_SPLIT_LCMP0_bp = 4              ; Low Compare 0 Interrupt Enable bit position
  TCA_SPLIT_LCMP1_bm = 0x20           ; Low Compare 1 Interrupt Enable bit mask
  TCA_SPLIT_LCMP1_bp = 5              ; Low Compare 1 Interrupt Enable bit position
  TCA_SPLIT_LCMP2_bm = 0x40           ; Low Compare 2 Interrupt Enable bit mask
  TCA_SPLIT_LCMP2_bp = 6              ; Low Compare 2 Interrupt Enable bit position
  
  ; TCA_SPLIT_INTFLAGS masks
  ; Masks for TCA_SPLIT_LUNF already defined
  ; Masks for TCA_SPLIT_HUNF already defined
  ; Masks for TCA_SPLIT_LCMP0 already defined
  ; Masks for TCA_SPLIT_LCMP1 already defined
  ; Masks for TCA_SPLIT_LCMP2 already defined
  
  ; TCA_SPLIT_DBGCTRL masks
  TCA_SPLIT_DBGRUN_bm = 0x01          ; Debug Run bit mask
  TCA_SPLIT_DBGRUN_bp = 0             ; Debug Run bit position
  
  ; Clock Selection
  TCA_SINGLE_CLKSEL_DIV1_gc = (0x00<<1) ; CLK_PER
  TCA_SINGLE_CLKSEL_DIV2_gc = (0x01<<1) ; CLK_PER / 2
  TCA_SINGLE_CLKSEL_DIV4_gc = (0x02<<1) ; CLK_PER / 4
  TCA_SINGLE_CLKSEL_DIV8_gc = (0x03<<1) ; CLK_PER / 8
  TCA_SINGLE_CLKSEL_DIV16_gc = (0x04<<1) ; CLK_PER / 16
  TCA_SINGLE_CLKSEL_DIV64_gc = (0x05<<1) ; CLK_PER / 64
  TCA_SINGLE_CLKSEL_DIV256_gc = (0x06<<1) ; CLK_PER / 256
  TCA_SINGLE_CLKSEL_DIV1024_gc = (0x07<<1) ; CLK_PER / 1024
  
  ; Waveform generation mode select
  TCA_SINGLE_WGMODE_NORMAL_gc = (0x00<<0) ; Normal Mode
  TCA_SINGLE_WGMODE_FRQ_gc = (0x01<<0) ; Frequency Generation Mode
  TCA_SINGLE_WGMODE_SINGLESLOPE_gc = (0x03<<0) ; Single Slope PWM
  TCA_SINGLE_WGMODE_DSTOP_gc = (0x05<<0) ; Dual Slope PWM, overflow on TOP
  TCA_SINGLE_WGMODE_DSBOTH_gc = (0x06<<0) ; Dual Slope PWM, overflow on TOP and BOTTOM
  TCA_SINGLE_WGMODE_DSBOTTOM_gc = (0x07<<0) ; Dual Slope PWM, overflow on BOTTOM
  
  ; Command select
  TCA_SINGLE_CMD_NONE_gc = (0x00<<2)  ; No Command
  TCA_SINGLE_CMD_UPDATE_gc = (0x01<<2) ; Force Update
  TCA_SINGLE_CMD_RESTART_gc = (0x02<<2) ; Force Restart
  TCA_SINGLE_CMD_RESET_gc = (0x03<<2) ; Force Hard Reset
  
  ; Direction select
  TCA_SINGLE_DIR_UP_gc = (0x00<<0)    ; Count up
  TCA_SINGLE_DIR_DOWN_gc = (0x01<<0)  ; Count down
  
  ; Event Action A select
  TCA_SINGLE_EVACTA_CNT_POSEDGE_gc = (0x00<<1) ; Count on positive edge event
  TCA_SINGLE_EVACTA_CNT_ANYEDGE_gc = (0x01<<1) ; Count on any edge event
  TCA_SINGLE_EVACTA_CNT_HIGHLVL_gc = (0x02<<1) ; Count on prescaled clock while event line is 1.
  TCA_SINGLE_EVACTA_UPDOWN_gc = (0x03<<1) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.
  
  ; Event Action B select
  TCA_SINGLE_EVACTB_NONE_gc = (0x00<<5) ; No Action
  TCA_SINGLE_EVACTB_UPDOWN_gc = (0x03<<5) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.
  TCA_SINGLE_EVACTB_RESTART_POSEDGE_gc = (0x04<<5) ; Restart counter at positive edge event
  TCA_SINGLE_EVACTB_RESTART_ANYEDGE_gc = (0x05<<5) ; Restart counter on any edge event
  TCA_SINGLE_EVACTB_RESTART_HIGHLVL_gc = (0x06<<5) ; Restart counter while event line is 1.
  
  ; Clock Selection
  TCA_SPLIT_CLKSEL_DIV1_gc = (0x00<<1) ; CLK_PER
  TCA_SPLIT_CLKSEL_DIV2_gc = (0x01<<1) ; CLK_PER / 2
  TCA_SPLIT_CLKSEL_DIV4_gc = (0x02<<1) ; CLK_PER / 4
  TCA_SPLIT_CLKSEL_DIV8_gc = (0x03<<1) ; CLK_PER / 8
  TCA_SPLIT_CLKSEL_DIV16_gc = (0x04<<1) ; CLK_PER / 16
  TCA_SPLIT_CLKSEL_DIV64_gc = (0x05<<1) ; CLK_PER / 64
  TCA_SPLIT_CLKSEL_DIV256_gc = (0x06<<1) ; CLK_PER / 256
  TCA_SPLIT_CLKSEL_DIV1024_gc = (0x07<<1) ; CLK_PER / 1024
  
  ; Command select
  TCA_SPLIT_CMD_NONE_gc = (0x00<<2)   ; No Command
  TCA_SPLIT_CMD_UPDATE_gc = (0x01<<2) ; Force Update
  TCA_SPLIT_CMD_RESTART_gc = (0x02<<2) ; Force Restart
  TCA_SPLIT_CMD_RESET_gc = (0x03<<2)  ; Force Hard Reset
  
  ; Command Enable select
  TCA_SPLIT_CMDEN_NONE_gc = (0x00<<0) ; None
  TCA_SPLIT_CMDEN_BOTH_gc = (0x03<<0) ; Both low byte and high byte counter
  
  
  ;*************************************************************************
  ;** TCB - 16-bit Timer Type B
  ;*************************************************************************
  
  ; TCB_CTRLA masks
  TCB_ENABLE_bm = 0x01                ; Enable bit mask
  TCB_ENABLE_bp = 0                   ; Enable bit position
  TCB_CLKSEL_gm = 0x0E                ; Clock Select group mask
  TCB_CLKSEL_gp = 1                   ; Clock Select group position
  TCB_CLKSEL_0_bm = (1<<1)            ; Clock Select bit 0 mask
  TCB_CLKSEL_0_bp = 1                 ; Clock Select bit 0 position
  TCB_CLKSEL_1_bm = (1<<2)            ; Clock Select bit 1 mask
  TCB_CLKSEL_1_bp = 2                 ; Clock Select bit 1 position
  TCB_CLKSEL_2_bm = (1<<3)            ; Clock Select bit 2 mask
  TCB_CLKSEL_2_bp = 3                 ; Clock Select bit 2 position
  TCB_SYNCUPD_bm = 0x10               ; Synchronize Update bit mask
  TCB_SYNCUPD_bp = 4                  ; Synchronize Update bit position
  TCB_CASCADE_bm = 0x20               ; Cascade two timers bit mask
  TCB_CASCADE_bp = 5                  ; Cascade two timers bit position
  TCB_RUNSTDBY_bm = 0x40              ; Run Standby bit mask
  TCB_RUNSTDBY_bp = 6                 ; Run Standby bit position
  
  ; TCB_CTRLB masks
  TCB_CNTMODE_gm = 0x07               ; Timer Mode group mask
  TCB_CNTMODE_gp = 0                  ; Timer Mode group position
  TCB_CNTMODE_0_bm = (1<<0)           ; Timer Mode bit 0 mask
  TCB_CNTMODE_0_bp = 0                ; Timer Mode bit 0 position
  TCB_CNTMODE_1_bm = (1<<1)           ; Timer Mode bit 1 mask
  TCB_CNTMODE_1_bp = 1                ; Timer Mode bit 1 position
  TCB_CNTMODE_2_bm = (1<<2)           ; Timer Mode bit 2 mask
  TCB_CNTMODE_2_bp = 2                ; Timer Mode bit 2 position
  TCB_CCMPEN_bm = 0x10                ; Pin Output Enable bit mask
  TCB_CCMPEN_bp = 4                   ; Pin Output Enable bit position
  TCB_CCMPINIT_bm = 0x20              ; Pin Initial State bit mask
  TCB_CCMPINIT_bp = 5                 ; Pin Initial State bit position
  TCB_ASYNC_bm = 0x40                 ; Asynchronous Enable bit mask
  TCB_ASYNC_bp = 6                    ; Asynchronous Enable bit position
  
  ; TCB_EVCTRL masks
  TCB_CAPTEI_bm = 0x01                ; Event Input Enable bit mask
  TCB_CAPTEI_bp = 0                   ; Event Input Enable bit position
  TCB_EDGE_bm = 0x10                  ; Event Edge bit mask
  TCB_EDGE_bp = 4                     ; Event Edge bit position
  TCB_FILTER_bm = 0x40                ; Input Capture Noise Cancellation Filter bit mask
  TCB_FILTER_bp = 6                   ; Input Capture Noise Cancellation Filter bit position
  
  ; TCB_INTCTRL masks
  TCB_CAPT_bm = 0x01                  ; Capture or Timeout bit mask
  TCB_CAPT_bp = 0                     ; Capture or Timeout bit position
  TCB_OVF_bm = 0x02                   ; Overflow bit mask
  TCB_OVF_bp = 1                      ; Overflow bit position
  
  ; TCB_INTFLAGS masks
  ; Masks for TCB_CAPT already defined
  ; Masks for TCB_OVF already defined
  
  ; TCB_STATUS masks
  TCB_RUN_bm = 0x01                   ; Run bit mask
  TCB_RUN_bp = 0                      ; Run bit position
  
  ; TCB_DBGCTRL masks
  TCB_DBGRUN_bm = 0x01                ; Debug Run bit mask
  TCB_DBGRUN_bp = 0                   ; Debug Run bit position
  
  ; Clock Select
  TCB_CLKSEL_DIV1_gc = (0x00<<1)      ; CLK_PER
  TCB_CLKSEL_DIV2_gc = (0x01<<1)      ; CLK_PER/2
  TCB_CLKSEL_TCA0_gc = (0x02<<1)      ; Use CLK_TCA from TCA0
  TCB_CLKSEL_EVENT_gc = (0x07<<1)     ; Count on event edge
  
  ; Timer Mode select
  TCB_CNTMODE_INT_gc = (0x00<<0)      ; Periodic Interrupt
  TCB_CNTMODE_TIMEOUT_gc = (0x01<<0)  ; Periodic Timeout
  TCB_CNTMODE_CAPT_gc = (0x02<<0)     ; Input Capture Event
  TCB_CNTMODE_FRQ_gc = (0x03<<0)      ; Input Capture Frequency measurement
  TCB_CNTMODE_PW_gc = (0x04<<0)       ; Input Capture Pulse-Width measurement
  TCB_CNTMODE_FRQPW_gc = (0x05<<0)    ; Input Capture Frequency and Pulse-Width measurement
  TCB_CNTMODE_SINGLE_gc = (0x06<<0)   ; Single Shot
  TCB_CNTMODE_PWM8_gc = (0x07<<0)     ; 8-bit PWM
  
  
  ;*************************************************************************
  ;** TCD - Timer Counter D
  ;*************************************************************************
  
  ; TCD_CTRLA masks
  TCD_ENABLE_bm = 0x01                ; Enable bit mask
  TCD_ENABLE_bp = 0                   ; Enable bit position
  TCD_SYNCPRES_gm = 0x06              ; Synchronization prescaler group mask
  TCD_SYNCPRES_gp = 1                 ; Synchronization prescaler group position
  TCD_SYNCPRES_0_bm = (1<<1)          ; Synchronization prescaler bit 0 mask
  TCD_SYNCPRES_0_bp = 1               ; Synchronization prescaler bit 0 position
  TCD_SYNCPRES_1_bm = (1<<2)          ; Synchronization prescaler bit 1 mask
  TCD_SYNCPRES_1_bp = 2               ; Synchronization prescaler bit 1 position
  TCD_CNTPRES_gm = 0x18               ; Counter prescaler group mask
  TCD_CNTPRES_gp = 3                  ; Counter prescaler group position
  TCD_CNTPRES_0_bm = (1<<3)           ; Counter prescaler bit 0 mask
  TCD_CNTPRES_0_bp = 3                ; Counter prescaler bit 0 position
  TCD_CNTPRES_1_bm = (1<<4)           ; Counter prescaler bit 1 mask
  TCD_CNTPRES_1_bp = 4                ; Counter prescaler bit 1 position
  TCD_CLKSEL_gm = 0x60                ; Clock select group mask
  TCD_CLKSEL_gp = 5                   ; Clock select group position
  TCD_CLKSEL_0_bm = (1<<5)            ; Clock select bit 0 mask
  TCD_CLKSEL_0_bp = 5                 ; Clock select bit 0 position
  TCD_CLKSEL_1_bm = (1<<6)            ; Clock select bit 1 mask
  TCD_CLKSEL_1_bp = 6                 ; Clock select bit 1 position
  
  ; TCD_CTRLB masks
  TCD_WGMODE_gm = 0x03                ; Waveform generation mode group mask
  TCD_WGMODE_gp = 0                   ; Waveform generation mode group position
  TCD_WGMODE_0_bm = (1<<0)            ; Waveform generation mode bit 0 mask
  TCD_WGMODE_0_bp = 0                 ; Waveform generation mode bit 0 position
  TCD_WGMODE_1_bm = (1<<1)            ; Waveform generation mode bit 1 mask
  TCD_WGMODE_1_bp = 1                 ; Waveform generation mode bit 1 position
  
  ; TCD_CTRLC masks
  TCD_CMPOVR_bm = 0x01                ; Compare output value override bit mask
  TCD_CMPOVR_bp = 0                   ; Compare output value override bit position
  TCD_AUPDATE_bm = 0x02               ; Auto update bit mask
  TCD_AUPDATE_bp = 1                  ; Auto update bit position
  TCD_FIFTY_bm = 0x08                 ; Fifty percent waveform bit mask
  TCD_FIFTY_bp = 3                    ; Fifty percent waveform bit position
  TCD_CMPCSEL_bm = 0x40               ; Compare C output select bit mask
  TCD_CMPCSEL_bp = 6                  ; Compare C output select bit position
  TCD_CMPDSEL_bm = 0x80               ; Compare D output select bit mask
  TCD_CMPDSEL_bp = 7                  ; Compare D output select bit position
  
  ; TCD_CTRLD masks
  TCD_CMPAVAL_gm = 0x0F               ; Compare A value group mask
  TCD_CMPAVAL_gp = 0                  ; Compare A value group position
  TCD_CMPAVAL_0_bm = (1<<0)           ; Compare A value bit 0 mask
  TCD_CMPAVAL_0_bp = 0                ; Compare A value bit 0 position
  TCD_CMPAVAL_1_bm = (1<<1)           ; Compare A value bit 1 mask
  TCD_CMPAVAL_1_bp = 1                ; Compare A value bit 1 position
  TCD_CMPAVAL_2_bm = (1<<2)           ; Compare A value bit 2 mask
  TCD_CMPAVAL_2_bp = 2                ; Compare A value bit 2 position
  TCD_CMPAVAL_3_bm = (1<<3)           ; Compare A value bit 3 mask
  TCD_CMPAVAL_3_bp = 3                ; Compare A value bit 3 position
  TCD_CMPBVAL_gm = 0xF0               ; Compare B value group mask
  TCD_CMPBVAL_gp = 4                  ; Compare B value group position
  TCD_CMPBVAL_0_bm = (1<<4)           ; Compare B value bit 0 mask
  TCD_CMPBVAL_0_bp = 4                ; Compare B value bit 0 position
  TCD_CMPBVAL_1_bm = (1<<5)           ; Compare B value bit 1 mask
  TCD_CMPBVAL_1_bp = 5                ; Compare B value bit 1 position
  TCD_CMPBVAL_2_bm = (1<<6)           ; Compare B value bit 2 mask
  TCD_CMPBVAL_2_bp = 6                ; Compare B value bit 2 position
  TCD_CMPBVAL_3_bm = (1<<7)           ; Compare B value bit 3 mask
  TCD_CMPBVAL_3_bp = 7                ; Compare B value bit 3 position
  
  ; TCD_CTRLE masks
  TCD_SYNCEOC_bm = 0x01               ; Synchronize end of cycle strobe bit mask
  TCD_SYNCEOC_bp = 0                  ; Synchronize end of cycle strobe bit position
  TCD_SYNC_bm = 0x02                  ; synchronize strobe bit mask
  TCD_SYNC_bp = 1                     ; synchronize strobe bit position
  TCD_RESTART_bm = 0x04               ; Restart strobe bit mask
  TCD_RESTART_bp = 2                  ; Restart strobe bit position
  TCD_SCAPTUREA_bm = 0x08             ; Software Capture A Strobe bit mask
  TCD_SCAPTUREA_bp = 3                ; Software Capture A Strobe bit position
  TCD_SCAPTUREB_bm = 0x10             ; Software Capture B Strobe bit mask
  TCD_SCAPTUREB_bp = 4                ; Software Capture B Strobe bit position
  TCD_DISEOC_bm = 0x80                ; Disable at end of cycle bit mask
  TCD_DISEOC_bp = 7                   ; Disable at end of cycle bit position
  
  ; TCD_EVCTRLA masks
  TCD_TRIGEI_bm = 0x01                ; Trigger event enable bit mask
  TCD_TRIGEI_bp = 0                   ; Trigger event enable bit position
  TCD_ACTION_bm = 0x04                ; Event action bit mask
  TCD_ACTION_bp = 2                   ; Event action bit position
  TCD_EDGE_bm = 0x10                  ; Edge select bit mask
  TCD_EDGE_bp = 4                     ; Edge select bit position
  TCD_CFG_gm = 0xC0                   ; Event config group mask
  TCD_CFG_gp = 6                      ; Event config group position
  TCD_CFG_0_bm = (1<<6)               ; Event config bit 0 mask
  TCD_CFG_0_bp = 6                    ; Event config bit 0 position
  TCD_CFG_1_bm = (1<<7)               ; Event config bit 1 mask
  TCD_CFG_1_bp = 7                    ; Event config bit 1 position
  
  ; TCD_EVCTRLB masks
  ; Masks for TCD_TRIGEI already defined
  ; Masks for TCD_ACTION already defined
  ; Masks for TCD_EDGE already defined
  ; Masks for TCD_CFG already defined
  
  ; TCD_INTCTRL masks
  TCD_OVF_bm = 0x01                   ; Overflow interrupt enable bit mask
  TCD_OVF_bp = 0                      ; Overflow interrupt enable bit position
  TCD_TRIGA_bm = 0x04                 ; Trigger A interrupt enable bit mask
  TCD_TRIGA_bp = 2                    ; Trigger A interrupt enable bit position
  TCD_TRIGB_bm = 0x08                 ; Trigger B interrupt enable bit mask
  TCD_TRIGB_bp = 3                    ; Trigger B interrupt enable bit position
  
  ; TCD_INTFLAGS masks
  ; Masks for TCD_OVF already defined
  ; Masks for TCD_TRIGA already defined
  ; Masks for TCD_TRIGB already defined
  
  ; TCD_STATUS masks
  TCD_ENRDY_bm = 0x01                 ; Enable ready bit mask
  TCD_ENRDY_bp = 0                    ; Enable ready bit position
  TCD_CMDRDY_bm = 0x02                ; Command ready bit mask
  TCD_CMDRDY_bp = 1                   ; Command ready bit position
  TCD_PWMACTA_bm = 0x40               ; PWM activity on A bit mask
  TCD_PWMACTA_bp = 6                  ; PWM activity on A bit position
  TCD_PWMACTB_bm = 0x80               ; PWM activity on B bit mask
  TCD_PWMACTB_bp = 7                  ; PWM activity on B bit position
  
  ; TCD_INPUTCTRLA masks
  TCD_INPUTMODE_gm = 0x0F             ; Input mode group mask
  TCD_INPUTMODE_gp = 0                ; Input mode group position
  TCD_INPUTMODE_0_bm = (1<<0)         ; Input mode bit 0 mask
  TCD_INPUTMODE_0_bp = 0              ; Input mode bit 0 position
  TCD_INPUTMODE_1_bm = (1<<1)         ; Input mode bit 1 mask
  TCD_INPUTMODE_1_bp = 1              ; Input mode bit 1 position
  TCD_INPUTMODE_2_bm = (1<<2)         ; Input mode bit 2 mask
  TCD_INPUTMODE_2_bp = 2              ; Input mode bit 2 position
  TCD_INPUTMODE_3_bm = (1<<3)         ; Input mode bit 3 mask
  TCD_INPUTMODE_3_bp = 3              ; Input mode bit 3 position
  
  ; TCD_INPUTCTRLB masks
  ; Masks for TCD_INPUTMODE already defined
  
  ; TCD_FAULTCTRL masks
  TCD_CMPA_bm = 0x01                  ; Compare A value bit mask
  TCD_CMPA_bp = 0                     ; Compare A value bit position
  TCD_CMPB_bm = 0x02                  ; Compare B value bit mask
  TCD_CMPB_bp = 1                     ; Compare B value bit position
  TCD_CMPC_bm = 0x04                  ; Compare C value bit mask
  TCD_CMPC_bp = 2                     ; Compare C value bit position
  TCD_CMPD_bm = 0x08                  ; Compare D vaule bit mask
  TCD_CMPD_bp = 3                     ; Compare D vaule bit position
  TCD_CMPAEN_bm = 0x10                ; Compare A enable bit mask
  TCD_CMPAEN_bp = 4                   ; Compare A enable bit position
  TCD_CMPBEN_bm = 0x20                ; Compare B enable bit mask
  TCD_CMPBEN_bp = 5                   ; Compare B enable bit position
  TCD_CMPCEN_bm = 0x40                ; Compare C enable bit mask
  TCD_CMPCEN_bp = 6                   ; Compare C enable bit position
  TCD_CMPDEN_bm = 0x80                ; Compare D enable bit mask
  TCD_CMPDEN_bp = 7                   ; Compare D enable bit position
  
  ; TCD_DLYCTRL masks
  TCD_DLYSEL_gm = 0x03                ; Delay select group mask
  TCD_DLYSEL_gp = 0                   ; Delay select group position
  TCD_DLYSEL_0_bm = (1<<0)            ; Delay select bit 0 mask
  TCD_DLYSEL_0_bp = 0                 ; Delay select bit 0 position
  TCD_DLYSEL_1_bm = (1<<1)            ; Delay select bit 1 mask
  TCD_DLYSEL_1_bp = 1                 ; Delay select bit 1 position
  TCD_DLYTRIG_gm = 0x0C               ; Delay trigger group mask
  TCD_DLYTRIG_gp = 2                  ; Delay trigger group position
  TCD_DLYTRIG_0_bm = (1<<2)           ; Delay trigger bit 0 mask
  TCD_DLYTRIG_0_bp = 2                ; Delay trigger bit 0 position
  TCD_DLYTRIG_1_bm = (1<<3)           ; Delay trigger bit 1 mask
  TCD_DLYTRIG_1_bp = 3                ; Delay trigger bit 1 position
  TCD_DLYPRESC_gm = 0x30              ; Delay prescaler group mask
  TCD_DLYPRESC_gp = 4                 ; Delay prescaler group position
  TCD_DLYPRESC_0_bm = (1<<4)          ; Delay prescaler bit 0 mask
  TCD_DLYPRESC_0_bp = 4               ; Delay prescaler bit 0 position
  TCD_DLYPRESC_1_bm = (1<<5)          ; Delay prescaler bit 1 mask
  TCD_DLYPRESC_1_bp = 5               ; Delay prescaler bit 1 position
  
  ; TCD_DLYVAL masks
  TCD_DLYVAL_gm = 0xFF                ; Delay value group mask
  TCD_DLYVAL_gp = 0                   ; Delay value group position
  TCD_DLYVAL_0_bm = (1<<0)            ; Delay value bit 0 mask
  TCD_DLYVAL_0_bp = 0                 ; Delay value bit 0 position
  TCD_DLYVAL_1_bm = (1<<1)            ; Delay value bit 1 mask
  TCD_DLYVAL_1_bp = 1                 ; Delay value bit 1 position
  TCD_DLYVAL_2_bm = (1<<2)            ; Delay value bit 2 mask
  TCD_DLYVAL_2_bp = 2                 ; Delay value bit 2 position
  TCD_DLYVAL_3_bm = (1<<3)            ; Delay value bit 3 mask
  TCD_DLYVAL_3_bp = 3                 ; Delay value bit 3 position
  TCD_DLYVAL_4_bm = (1<<4)            ; Delay value bit 4 mask
  TCD_DLYVAL_4_bp = 4                 ; Delay value bit 4 position
  TCD_DLYVAL_5_bm = (1<<5)            ; Delay value bit 5 mask
  TCD_DLYVAL_5_bp = 5                 ; Delay value bit 5 position
  TCD_DLYVAL_6_bm = (1<<6)            ; Delay value bit 6 mask
  TCD_DLYVAL_6_bp = 6                 ; Delay value bit 6 position
  TCD_DLYVAL_7_bm = (1<<7)            ; Delay value bit 7 mask
  TCD_DLYVAL_7_bp = 7                 ; Delay value bit 7 position
  
  ; TCD_DITCTRL masks
  TCD_DITHERSEL_gm = 0x03             ; Dither select group mask
  TCD_DITHERSEL_gp = 0                ; Dither select group position
  TCD_DITHERSEL_0_bm = (1<<0)         ; Dither select bit 0 mask
  TCD_DITHERSEL_0_bp = 0              ; Dither select bit 0 position
  TCD_DITHERSEL_1_bm = (1<<1)         ; Dither select bit 1 mask
  TCD_DITHERSEL_1_bp = 1              ; Dither select bit 1 position
  
  ; TCD_DITVAL masks
  TCD_DITHER_gm = 0x0F                ; Dither value group mask
  TCD_DITHER_gp = 0                   ; Dither value group position
  TCD_DITHER_0_bm = (1<<0)            ; Dither value bit 0 mask
  TCD_DITHER_0_bp = 0                 ; Dither value bit 0 position
  TCD_DITHER_1_bm = (1<<1)            ; Dither value bit 1 mask
  TCD_DITHER_1_bp = 1                 ; Dither value bit 1 position
  TCD_DITHER_2_bm = (1<<2)            ; Dither value bit 2 mask
  TCD_DITHER_2_bp = 2                 ; Dither value bit 2 position
  TCD_DITHER_3_bm = (1<<3)            ; Dither value bit 3 mask
  TCD_DITHER_3_bp = 3                 ; Dither value bit 3 position
  
  ; TCD_DBGCTRL masks
  TCD_DBGRUN_bm = 0x01                ; Debug run bit mask
  TCD_DBGRUN_bp = 0                   ; Debug run bit position
  TCD_FAULTDET_bm = 0x04              ; Fault detection bit mask
  TCD_FAULTDET_bp = 2                 ; Fault detection bit position
  
  ; Clock select
  TCD_CLKSEL_OSCHF_gc = (0x00<<5)     ; Internal High-Frequency oscillator
  TCD_CLKSEL_PLL_gc = (0x01<<5)       ; PLL
  TCD_CLKSEL_EXTCLK_gc = (0x02<<5)    ; External Clock
  TCD_CLKSEL_CLKPER_gc = (0x03<<5)    ; Peripheral clock
  
  ; Counter prescaler select
  TCD_CNTPRES_DIV1_gc = (0x00<<3)     ; Sync clock divided by 1
  TCD_CNTPRES_DIV4_gc = (0x01<<3)     ; Sync clock divided by 4
  TCD_CNTPRES_DIV32_gc = (0x02<<3)    ; Sync clock divided by 32
  
  ; Synchronization prescaler select
  TCD_SYNCPRES_DIV1_gc = (0x00<<1)    ; Selected clock source divided by 1
  TCD_SYNCPRES_DIV2_gc = (0x01<<1)    ; Selected clock source divided by 2
  TCD_SYNCPRES_DIV4_gc = (0x02<<1)    ; Selected clock source divided by 4
  TCD_SYNCPRES_DIV8_gc = (0x03<<1)    ; Selected clock source divided by 8
  
  ; Waveform generation mode select
  TCD_WGMODE_ONERAMP_gc = (0x00<<0)   ; One ramp mode
  TCD_WGMODE_TWORAMP_gc = (0x01<<0)   ; Two ramp mode
  TCD_WGMODE_FOURRAMP_gc = (0x02<<0)  ; Four ramp mode
  TCD_WGMODE_DS_gc = (0x03<<0)        ; Dual slope mode
  
  ; Compare C output select
  TCD_CMPCSEL_PWMA_gc = (0x00<<6)     ; PWM A output
  TCD_CMPCSEL_PWMB_gc = (0x01<<6)     ; PWM B output
  
  ; Compare D output select
  TCD_CMPDSEL_PWMA_gc = (0x00<<7)     ; PWM A output
  TCD_CMPDSEL_PWMB_gc = (0x01<<7)     ; PWM B output
  
  ; Dither select
  TCD_DITHERSEL_ONTIMEB_gc = (0x00<<0) ; On-time ramp B
  TCD_DITHERSEL_ONTIMEAB_gc = (0x01<<0) ; On-time ramp A and B
  TCD_DITHERSEL_DEADTIMEB_gc = (0x02<<0) ; Dead-time rampB
  TCD_DITHERSEL_DEADTIMEAB_gc = (0x03<<0) ; Dead-time ramp A and B
  
  ; Delay prescaler select
  TCD_DLYPRESC_DIV1_gc = (0x00<<4)    ; No prescaling
  TCD_DLYPRESC_DIV2_gc = (0x01<<4)    ; Prescale with 2
  TCD_DLYPRESC_DIV4_gc = (0x02<<4)    ; Prescale with 4
  TCD_DLYPRESC_DIV8_gc = (0x03<<4)    ; Prescale with 8
  
  ; Delay select
  TCD_DLYSEL_OFF_gc = (0x00<<0)       ; No delay
  TCD_DLYSEL_INBLANK_gc = (0x01<<0)   ; Input blanking enabled
  TCD_DLYSEL_EVENT_gc = (0x02<<0)     ; Event delay enabled
  
  ; Delay trigger select
  TCD_DLYTRIG_CMPASET_gc = (0x00<<2)  ; Compare A set
  TCD_DLYTRIG_CMPACLR_gc = (0x01<<2)  ; Compare A clear
  TCD_DLYTRIG_CMPBSET_gc = (0x02<<2)  ; Compare B set
  TCD_DLYTRIG_CMPBCLR_gc = (0x03<<2)  ; Compare B clear
  
  ; Event action select
  TCD_ACTION_FAULT_gc = (0x00<<2)     ; Event trigger a fault
  TCD_ACTION_CAPTURE_gc = (0x01<<2)   ; Event trigger a fault and capture
  
  ; Event config select
  TCD_CFG_NEITHER_gc = (0x00<<6)      ; Neither Filter nor Asynchronous Event is enabled
  TCD_CFG_FILTER_gc = (0x01<<6)       ; Input Capture Noise Cancellation Filter enabled
  TCD_CFG_ASYNC_gc = (0x02<<6)        ; Asynchronous Event output qualification enabled
  
  ; Edge select
  TCD_EDGE_FALL_LOW_gc = (0x00<<4)    ; The falling edge or low level of event generates retrigger or fault action
  TCD_EDGE_RISE_HIGH_gc = (0x01<<4)   ; The rising edge or high level of event generates retrigger or fault action
  
  ; Input mode select
  TCD_INPUTMODE_NONE_gc = (0x00<<0)   ; Input has no actions
  TCD_INPUTMODE_JMPWAIT_gc = (0x01<<0) ; Stop output, jump to opposite compare cycle and wait
  TCD_INPUTMODE_EXECWAIT_gc = (0x02<<0) ; Stop output, execute opposite compare cycle and wait
  TCD_INPUTMODE_EXECFAULT_gc = (0x03<<0) ; stop output, execute opposite compare cycle while fault active
  TCD_INPUTMODE_FREQ_gc = (0x04<<0)   ; Stop all outputs, maintain frequency
  TCD_INPUTMODE_EXECDT_gc = (0x05<<0) ; Stop all outputs, execute dead time while fault active
  TCD_INPUTMODE_WAIT_gc = (0x06<<0)   ; Stop all outputs, jump to next compare cycle and wait
  TCD_INPUTMODE_WAITSW_gc = (0x07<<0) ; Stop all outputs, wait for software action
  TCD_INPUTMODE_EDGETRIG_gc = (0x08<<0) ; Stop output on edge, jump to next compare cycle
  TCD_INPUTMODE_EDGETRIGFREQ_gc = (0x09<<0) ; Stop output on edge, maintain frequency
  TCD_INPUTMODE_LVLTRIGFREQ_gc = (0x0A<<0) ; Stop output at level, maintain frequency
  
  
  ;*************************************************************************
  ;** TWI - Two-Wire Interface
  ;*************************************************************************
  
  ; TWI_CTRLA masks
  TWI_FMPEN_bm = 0x02                 ; Fast-mode Plus Enable bit mask
  TWI_FMPEN_bp = 1                    ; Fast-mode Plus Enable bit position
  TWI_SDAHOLD_gm = 0x0C               ; SDA Hold Time group mask
  TWI_SDAHOLD_gp = 2                  ; SDA Hold Time group position
  TWI_SDAHOLD_0_bm = (1<<2)           ; SDA Hold Time bit 0 mask
  TWI_SDAHOLD_0_bp = 2                ; SDA Hold Time bit 0 position
  TWI_SDAHOLD_1_bm = (1<<3)           ; SDA Hold Time bit 1 mask
  TWI_SDAHOLD_1_bp = 3                ; SDA Hold Time bit 1 position
  TWI_SDASETUP_bm = 0x10              ; SDA Setup Time bit mask
  TWI_SDASETUP_bp = 4                 ; SDA Setup Time bit position
  TWI_INPUTLVL_bm = 0x40              ; Input voltage transition level bit mask
  TWI_INPUTLVL_bp = 6                 ; Input voltage transition level bit position
  
  ; TWI_DUALCTRL masks
  TWI_ENABLE_bm = 0x01                ; Enable bit mask
  TWI_ENABLE_bp = 0                   ; Enable bit position
  ; Masks for TWI_FMPEN already defined
  ; Masks for TWI_SDAHOLD already defined
  ; Masks for TWI_INPUTLVL already defined
  
  ; TWI_DBGCTRL masks
  TWI_DBGRUN_bm = 0x01                ; Debug Run bit mask
  TWI_DBGRUN_bp = 0                   ; Debug Run bit position
  
  ; TWI_MCTRLA masks
  ; Masks for TWI_ENABLE already defined
  TWI_SMEN_bm = 0x02                  ; Smart Mode Enable bit mask
  TWI_SMEN_bp = 1                     ; Smart Mode Enable bit position
  TWI_TIMEOUT_gm = 0x0C               ; Inactive Bus Time-Out group mask
  TWI_TIMEOUT_gp = 2                  ; Inactive Bus Time-Out group position
  TWI_TIMEOUT_0_bm = (1<<2)           ; Inactive Bus Time-Out bit 0 mask
  TWI_TIMEOUT_0_bp = 2                ; Inactive Bus Time-Out bit 0 position
  TWI_TIMEOUT_1_bm = (1<<3)           ; Inactive Bus Time-Out bit 1 mask
  TWI_TIMEOUT_1_bp = 3                ; Inactive Bus Time-Out bit 1 position
  TWI_QCEN_bm = 0x10                  ; Quick Command Enable bit mask
  TWI_QCEN_bp = 4                     ; Quick Command Enable bit position
  TWI_WIEN_bm = 0x40                  ; Write Interrupt Enable bit mask
  TWI_WIEN_bp = 6                     ; Write Interrupt Enable bit position
  TWI_RIEN_bm = 0x80                  ; Read Interrupt Enable bit mask
  TWI_RIEN_bp = 7                     ; Read Interrupt Enable bit position
  
  ; TWI_MCTRLB masks
  TWI_MCMD_gm = 0x03                  ; Command group mask
  TWI_MCMD_gp = 0                     ; Command group position
  TWI_MCMD_0_bm = (1<<0)              ; Command bit 0 mask
  TWI_MCMD_0_bp = 0                   ; Command bit 0 position
  TWI_MCMD_1_bm = (1<<1)              ; Command bit 1 mask
  TWI_MCMD_1_bp = 1                   ; Command bit 1 position
  TWI_ACKACT_bm = 0x04                ; Acknowledge Action bit mask
  TWI_ACKACT_bp = 2                   ; Acknowledge Action bit position
  TWI_FLUSH_bm = 0x08                 ; Flush bit mask
  TWI_FLUSH_bp = 3                    ; Flush bit position
  
  ; TWI_MSTATUS masks
  TWI_BUSSTATE_gm = 0x03              ; Bus State group mask
  TWI_BUSSTATE_gp = 0                 ; Bus State group position
  TWI_BUSSTATE_0_bm = (1<<0)          ; Bus State bit 0 mask
  TWI_BUSSTATE_0_bp = 0               ; Bus State bit 0 position
  TWI_BUSSTATE_1_bm = (1<<1)          ; Bus State bit 1 mask
  TWI_BUSSTATE_1_bp = 1               ; Bus State bit 1 position
  TWI_BUSERR_bm = 0x04                ; Bus Error bit mask
  TWI_BUSERR_bp = 2                   ; Bus Error bit position
  TWI_ARBLOST_bm = 0x08               ; Arbitration Lost bit mask
  TWI_ARBLOST_bp = 3                  ; Arbitration Lost bit position
  TWI_RXACK_bm = 0x10                 ; Received Acknowledge bit mask
  TWI_RXACK_bp = 4                    ; Received Acknowledge bit position
  TWI_CLKHOLD_bm = 0x20               ; Clock Hold bit mask
  TWI_CLKHOLD_bp = 5                  ; Clock Hold bit position
  TWI_WIF_bm = 0x40                   ; Write Interrupt Flag bit mask
  TWI_WIF_bp = 6                      ; Write Interrupt Flag bit position
  TWI_RIF_bm = 0x80                   ; Read Interrupt Flag bit mask
  TWI_RIF_bp = 7                      ; Read Interrupt Flag bit position
  
  ; TWI_MBAUD masks
  TWI_BAUD_gm = 0xFF                  ; Baud Rate group mask
  TWI_BAUD_gp = 0                     ; Baud Rate group position
  TWI_BAUD_0_bm = (1<<0)              ; Baud Rate bit 0 mask
  TWI_BAUD_0_bp = 0                   ; Baud Rate bit 0 position
  TWI_BAUD_1_bm = (1<<1)              ; Baud Rate bit 1 mask
  TWI_BAUD_1_bp = 1                   ; Baud Rate bit 1 position
  TWI_BAUD_2_bm = (1<<2)              ; Baud Rate bit 2 mask
  TWI_BAUD_2_bp = 2                   ; Baud Rate bit 2 position
  TWI_BAUD_3_bm = (1<<3)              ; Baud Rate bit 3 mask
  TWI_BAUD_3_bp = 3                   ; Baud Rate bit 3 position
  TWI_BAUD_4_bm = (1<<4)              ; Baud Rate bit 4 mask
  TWI_BAUD_4_bp = 4                   ; Baud Rate bit 4 position
  TWI_BAUD_5_bm = (1<<5)              ; Baud Rate bit 5 mask
  TWI_BAUD_5_bp = 5                   ; Baud Rate bit 5 position
  TWI_BAUD_6_bm = (1<<6)              ; Baud Rate bit 6 mask
  TWI_BAUD_6_bp = 6                   ; Baud Rate bit 6 position
  TWI_BAUD_7_bm = (1<<7)              ; Baud Rate bit 7 mask
  TWI_BAUD_7_bp = 7                   ; Baud Rate bit 7 position
  
  ; TWI_MADDR masks
  TWI_ADDR_gm = 0xFF                  ; Address group mask
  TWI_ADDR_gp = 0                     ; Address group position
  TWI_ADDR_0_bm = (1<<0)              ; Address bit 0 mask
  TWI_ADDR_0_bp = 0                   ; Address bit 0 position
  TWI_ADDR_1_bm = (1<<1)              ; Address bit 1 mask
  TWI_ADDR_1_bp = 1                   ; Address bit 1 position
  TWI_ADDR_2_bm = (1<<2)              ; Address bit 2 mask
  TWI_ADDR_2_bp = 2                   ; Address bit 2 position
  TWI_ADDR_3_bm = (1<<3)              ; Address bit 3 mask
  TWI_ADDR_3_bp = 3                   ; Address bit 3 position
  TWI_ADDR_4_bm = (1<<4)              ; Address bit 4 mask
  TWI_ADDR_4_bp = 4                   ; Address bit 4 position
  TWI_ADDR_5_bm = (1<<5)              ; Address bit 5 mask
  TWI_ADDR_5_bp = 5                   ; Address bit 5 position
  TWI_ADDR_6_bm = (1<<6)              ; Address bit 6 mask
  TWI_ADDR_6_bp = 6                   ; Address bit 6 position
  TWI_ADDR_7_bm = (1<<7)              ; Address bit 7 mask
  TWI_ADDR_7_bp = 7                   ; Address bit 7 position
  
  ; TWI_MDATA masks
  TWI_DATA_gm = 0xFF                  ; Data group mask
  TWI_DATA_gp = 0                     ; Data group position
  TWI_DATA_0_bm = (1<<0)              ; Data bit 0 mask
  TWI_DATA_0_bp = 0                   ; Data bit 0 position
  TWI_DATA_1_bm = (1<<1)              ; Data bit 1 mask
  TWI_DATA_1_bp = 1                   ; Data bit 1 position
  TWI_DATA_2_bm = (1<<2)              ; Data bit 2 mask
  TWI_DATA_2_bp = 2                   ; Data bit 2 position
  TWI_DATA_3_bm = (1<<3)              ; Data bit 3 mask
  TWI_DATA_3_bp = 3                   ; Data bit 3 position
  TWI_DATA_4_bm = (1<<4)              ; Data bit 4 mask
  TWI_DATA_4_bp = 4                   ; Data bit 4 position
  TWI_DATA_5_bm = (1<<5)              ; Data bit 5 mask
  TWI_DATA_5_bp = 5                   ; Data bit 5 position
  TWI_DATA_6_bm = (1<<6)              ; Data bit 6 mask
  TWI_DATA_6_bp = 6                   ; Data bit 6 position
  TWI_DATA_7_bm = (1<<7)              ; Data bit 7 mask
  TWI_DATA_7_bp = 7                   ; Data bit 7 position
  
  ; TWI_SCTRLA masks
  ; Masks for TWI_ENABLE already defined
  ; Masks for TWI_SMEN already defined
  TWI_PMEN_bm = 0x04                  ; Address Recognition Mode bit mask
  TWI_PMEN_bp = 2                     ; Address Recognition Mode bit position
  TWI_PIEN_bm = 0x20                  ; Stop Interrupt Enable bit mask
  TWI_PIEN_bp = 5                     ; Stop Interrupt Enable bit position
  TWI_APIEN_bm = 0x40                 ; Address or Stop Interrupt Enable bit mask
  TWI_APIEN_bp = 6                    ; Address or Stop Interrupt Enable bit position
  TWI_DIEN_bm = 0x80                  ; Data Interrupt Enable bit mask
  TWI_DIEN_bp = 7                     ; Data Interrupt Enable bit position
  
  ; TWI_SCTRLB masks
  TWI_SCMD_gm = 0x03                  ; Command group mask
  TWI_SCMD_gp = 0                     ; Command group position
  TWI_SCMD_0_bm = (1<<0)              ; Command bit 0 mask
  TWI_SCMD_0_bp = 0                   ; Command bit 0 position
  TWI_SCMD_1_bm = (1<<1)              ; Command bit 1 mask
  TWI_SCMD_1_bp = 1                   ; Command bit 1 position
  ; Masks for TWI_ACKACT already defined
  
  ; TWI_SSTATUS masks
  TWI_AP_bm = 0x01                    ; Address or Stop bit mask
  TWI_AP_bp = 0                       ; Address or Stop bit position
  TWI_DIR_bm = 0x02                   ; Read/Write Direction bit mask
  TWI_DIR_bp = 1                      ; Read/Write Direction bit position
  ; Masks for TWI_BUSERR already defined
  TWI_COLL_bm = 0x08                  ; Collision bit mask
  TWI_COLL_bp = 3                     ; Collision bit position
  ; Masks for TWI_RXACK already defined
  ; Masks for TWI_CLKHOLD already defined
  TWI_APIF_bm = 0x40                  ; Address or Stop Interrupt Flag bit mask
  TWI_APIF_bp = 6                     ; Address or Stop Interrupt Flag bit position
  TWI_DIF_bm = 0x80                   ; Data Interrupt Flag bit mask
  TWI_DIF_bp = 7                      ; Data Interrupt Flag bit position
  
  ; TWI_SADDR masks
  ; Masks for TWI_ADDR already defined
  
  ; TWI_SDATA masks
  ; Masks for TWI_DATA already defined
  
  ; TWI_SADDRMASK masks
  TWI_ADDREN_bm = 0x01                ; Address Mask Enable bit mask
  TWI_ADDREN_bp = 0                   ; Address Mask Enable bit position
  TWI_ADDRMASK_gm = 0xFE              ; Address Mask group mask
  TWI_ADDRMASK_gp = 1                 ; Address Mask group position
  TWI_ADDRMASK_0_bm = (1<<1)          ; Address Mask bit 0 mask
  TWI_ADDRMASK_0_bp = 1               ; Address Mask bit 0 position
  TWI_ADDRMASK_1_bm = (1<<2)          ; Address Mask bit 1 mask
  TWI_ADDRMASK_1_bp = 2               ; Address Mask bit 1 position
  TWI_ADDRMASK_2_bm = (1<<3)          ; Address Mask bit 2 mask
  TWI_ADDRMASK_2_bp = 3               ; Address Mask bit 2 position
  TWI_ADDRMASK_3_bm = (1<<4)          ; Address Mask bit 3 mask
  TWI_ADDRMASK_3_bp = 4               ; Address Mask bit 3 position
  TWI_ADDRMASK_4_bm = (1<<5)          ; Address Mask bit 4 mask
  TWI_ADDRMASK_4_bp = 5               ; Address Mask bit 4 position
  TWI_ADDRMASK_5_bm = (1<<6)          ; Address Mask bit 5 mask
  TWI_ADDRMASK_5_bp = 6               ; Address Mask bit 5 position
  TWI_ADDRMASK_6_bm = (1<<7)          ; Address Mask bit 6 mask
  TWI_ADDRMASK_6_bp = 7               ; Address Mask bit 6 position
  
  ; Fast-mode Plus Enable select
  TWI_FMPEN_OFF_gc = (0x00<<1)        ; Operating in Standard-mode or Fast-mode
  TWI_FMPEN_ON_gc = (0x01<<1)         ; Operating in Fast-mode Plus
  
  ; Input voltage transition level select
  TWI_INPUTLVL_I2C_gc = (0x00<<6)     ; I2C input voltage transition level
  TWI_INPUTLVL_SMBUS_gc = (0x01<<6)   ; SMBus 3.0 input voltage transition level
  
  ; SDA Hold Time select
  TWI_SDAHOLD_OFF_gc = (0x00<<2)      ; No SDA Hold Delay
  TWI_SDAHOLD_50NS_gc = (0x01<<2)     ; Short SDA hold time
  TWI_SDAHOLD_300NS_gc = (0x02<<2)    ; Meets SMBUS 2.0 specification under typical conditions
  TWI_SDAHOLD_500NS_gc = (0x03<<2)    ; Meets SMBUS 2.0 specificaiton across all corners
  
  ; SDA Setup Time select
  TWI_SDASETUP_4CYC_gc = (0x00<<4)    ; SDA setup time is four clock cycles
  TWI_SDASETUP_8CYC_gc = (0x01<<4)    ; SDA setup time is eight clock cycle
  
  ; Debug Run select
  TWI_DBGRUN_HALT_gc = (0x00<<0)      ; The peripheral is halted in Break Debug mode and ignores events
  TWI_DBGRUN_RUN_gc = (0x01<<0)       ; The peripheral will continue to run in Break Debug mode when the CPU is halted
  
  ; Inactive Bus Time-Out select
  TWI_TIMEOUT_DISABLED_gc = (0x00<<2) ; Bus time-out disabled. I2C.
  TWI_TIMEOUT_50US_gc = (0x01<<2)     ; 50us - SMBus
  TWI_TIMEOUT_100US_gc = (0x02<<2)    ; 100us
  TWI_TIMEOUT_200US_gc = (0x03<<2)    ; 200us
  
  ; Acknowledge Action select
  TWI_ACKACT_ACK_gc = (0x00<<2)       ; Send ACK
  TWI_ACKACT_NACK_gc = (0x01<<2)      ; Send NACK
  
  ; Command select
  TWI_MCMD_NOACT_gc = (0x00<<0)       ; No action
  TWI_MCMD_REPSTART_gc = (0x01<<0)    ; Execute Acknowledge Action followed by repeated Start.
  TWI_MCMD_RECVTRANS_gc = (0x02<<0)   ; Execute Acknowledge Action followed by a byte read/write operation. Read/write is defined by DIR.
  TWI_MCMD_STOP_gc = (0x03<<0)        ; Execute Acknowledge Action followed by issuing a Stop condition.
  
  ; Bus State select
  TWI_BUSSTATE_UNKNOWN_gc = (0x00<<0) ; Unknown bus state
  TWI_BUSSTATE_IDLE_gc = (0x01<<0)    ; Bus is idle
  TWI_BUSSTATE_OWNER_gc = (0x02<<0)   ; This TWI controls the bus
  TWI_BUSSTATE_BUSY_gc = (0x03<<0)    ; The bus is busy
  
  ; Command select
  TWI_SCMD_NOACT_gc = (0x00<<0)       ; No Action
  TWI_SCMD_COMPTRANS_gc = (0x02<<0)   ; Complete transaction
  TWI_SCMD_RESPONSE_gc = (0x03<<0)    ; Used in response to an interrupt
  
  ; Address or Stop select
  TWI_AP_STOP_gc = (0x00<<0)          ; A Stop condition generated the interrupt on APIF flag
  TWI_AP_ADR_gc = (0x01<<0)           ; Address detection generated the interrupt on APIF flag
  
  
  ;*************************************************************************
  ;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter
  ;*************************************************************************
  
  ; USART_RXDATAL masks
  USART_DATA_gm = 0xFF                ; RX Data group mask
  USART_DATA_gp = 0                   ; RX Data group position
  USART_DATA_0_bm = (1<<0)            ; RX Data bit 0 mask
  USART_DATA_0_bp = 0                 ; RX Data bit 0 position
  USART_DATA_1_bm = (1<<1)            ; RX Data bit 1 mask
  USART_DATA_1_bp = 1                 ; RX Data bit 1 position
  USART_DATA_2_bm = (1<<2)            ; RX Data bit 2 mask
  USART_DATA_2_bp = 2                 ; RX Data bit 2 position
  USART_DATA_3_bm = (1<<3)            ; RX Data bit 3 mask
  USART_DATA_3_bp = 3                 ; RX Data bit 3 position
  USART_DATA_4_bm = (1<<4)            ; RX Data bit 4 mask
  USART_DATA_4_bp = 4                 ; RX Data bit 4 position
  USART_DATA_5_bm = (1<<5)            ; RX Data bit 5 mask
  USART_DATA_5_bp = 5                 ; RX Data bit 5 position
  USART_DATA_6_bm = (1<<6)            ; RX Data bit 6 mask
  USART_DATA_6_bp = 6                 ; RX Data bit 6 position
  USART_DATA_7_bm = (1<<7)            ; RX Data bit 7 mask
  USART_DATA_7_bp = 7                 ; RX Data bit 7 position
  
  ; USART_RXDATAH masks
  USART_DATA8_bm = 0x01               ; Receiver Data Register bit mask
  USART_DATA8_bp = 0                  ; Receiver Data Register bit position
  USART_PERR_bm = 0x02                ; Parity Error bit mask
  USART_PERR_bp = 1                   ; Parity Error bit position
  USART_FERR_bm = 0x04                ; Frame Error bit mask
  USART_FERR_bp = 2                   ; Frame Error bit position
  USART_BUFOVF_bm = 0x40              ; Buffer Overflow bit mask
  USART_BUFOVF_bp = 6                 ; Buffer Overflow bit position
  USART_RXCIF_bm = 0x80               ; Receive Complete Interrupt Flag bit mask
  USART_RXCIF_bp = 7                  ; Receive Complete Interrupt Flag bit position
  
  ; USART_TXDATAL masks
  ; Masks for USART_DATA already defined
  
  ; USART_TXDATAH masks
  ; Masks for USART_DATA8 already defined
  
  ; USART_STATUS masks
  USART_WFB_bm = 0x01                 ; Wait For Break bit mask
  USART_WFB_bp = 0                    ; Wait For Break bit position
  USART_BDF_bm = 0x02                 ; Break Detected Flag bit mask
  USART_BDF_bp = 1                    ; Break Detected Flag bit position
  USART_ISFIF_bm = 0x08               ; Inconsistent Sync Field Interrupt Flag bit mask
  USART_ISFIF_bp = 3                  ; Inconsistent Sync Field Interrupt Flag bit position
  USART_RXSIF_bm = 0x10               ; Receive Start Interrupt bit mask
  USART_RXSIF_bp = 4                  ; Receive Start Interrupt bit position
  USART_DREIF_bm = 0x20               ; Data Register Empty Flag bit mask
  USART_DREIF_bp = 5                  ; Data Register Empty Flag bit position
  USART_TXCIF_bm = 0x40               ; Transmit Interrupt Flag bit mask
  USART_TXCIF_bp = 6                  ; Transmit Interrupt Flag bit position
  ; Masks for USART_RXCIF already defined
  
  ; USART_CTRLA masks
  USART_RS485_bm = 0x01               ; RS485 Mode internal transmitter bit mask
  USART_RS485_bp = 0                  ; RS485 Mode internal transmitter bit position
  USART_ABEIE_bm = 0x04               ; Auto-baud Error Interrupt Enable bit mask
  USART_ABEIE_bp = 2                  ; Auto-baud Error Interrupt Enable bit position
  USART_LBME_bm = 0x08                ; Loop-back Mode Enable bit mask
  USART_LBME_bp = 3                   ; Loop-back Mode Enable bit position
  USART_RXSIE_bm = 0x10               ; Receiver Start Frame Interrupt Enable bit mask
  USART_RXSIE_bp = 4                  ; Receiver Start Frame Interrupt Enable bit position
  USART_DREIE_bm = 0x20               ; Data Register Empty Interrupt Enable bit mask
  USART_DREIE_bp = 5                  ; Data Register Empty Interrupt Enable bit position
  USART_TXCIE_bm = 0x40               ; Transmit Complete Interrupt Enable bit mask
  USART_TXCIE_bp = 6                  ; Transmit Complete Interrupt Enable bit position
  USART_RXCIE_bm = 0x80               ; Receive Complete Interrupt Enable bit mask
  USART_RXCIE_bp = 7                  ; Receive Complete Interrupt Enable bit position
  
  ; USART_CTRLB masks
  USART_MPCM_bm = 0x01                ; Multi-processor Communication Mode bit mask
  USART_MPCM_bp = 0                   ; Multi-processor Communication Mode bit position
  USART_RXMODE_gm = 0x06              ; Receiver Mode group mask
  USART_RXMODE_gp = 1                 ; Receiver Mode group position
  USART_RXMODE_0_bm = (1<<1)          ; Receiver Mode bit 0 mask
  USART_RXMODE_0_bp = 1               ; Receiver Mode bit 0 position
  USART_RXMODE_1_bm = (1<<2)          ; Receiver Mode bit 1 mask
  USART_RXMODE_1_bp = 2               ; Receiver Mode bit 1 position
  USART_ODME_bm = 0x08                ; Open Drain Mode Enable bit mask
  USART_ODME_bp = 3                   ; Open Drain Mode Enable bit position
  USART_SFDEN_bm = 0x10               ; Start Frame Detection Enable bit mask
  USART_SFDEN_bp = 4                  ; Start Frame Detection Enable bit position
  USART_TXEN_bm = 0x40                ; Transmitter Enable bit mask
  USART_TXEN_bp = 6                   ; Transmitter Enable bit position
  USART_RXEN_bm = 0x80                ; Reciever enable bit mask
  USART_RXEN_bp = 7                   ; Reciever enable bit position
  
  ; USART_CTRLC masks
  USART_UCPHA_bm = 0x02               ; SPI Host Mode, Clock Phase bit mask
  USART_UCPHA_bp = 1                  ; SPI Host Mode, Clock Phase bit position
  USART_UDORD_bm = 0x04               ; SPI Host Mode, Data Order bit mask
  USART_UDORD_bp = 2                  ; SPI Host Mode, Data Order bit position
  USART_CHSIZE_gm = 0x07              ; Character Size group mask
  USART_CHSIZE_gp = 0                 ; Character Size group position
  USART_CHSIZE_0_bm = (1<<0)          ; Character Size bit 0 mask
  USART_CHSIZE_0_bp = 0               ; Character Size bit 0 position
  USART_CHSIZE_1_bm = (1<<1)          ; Character Size bit 1 mask
  USART_CHSIZE_1_bp = 1               ; Character Size bit 1 position
  USART_CHSIZE_2_bm = (1<<2)          ; Character Size bit 2 mask
  USART_CHSIZE_2_bp = 2               ; Character Size bit 2 position
  USART_SBMODE_bm = 0x08              ; Stop Bit Mode bit mask
  USART_SBMODE_bp = 3                 ; Stop Bit Mode bit position
  USART_PMODE_gm = 0x30               ; Parity Mode group mask
  USART_PMODE_gp = 4                  ; Parity Mode group position
  USART_PMODE_0_bm = (1<<4)           ; Parity Mode bit 0 mask
  USART_PMODE_0_bp = 4                ; Parity Mode bit 0 position
  USART_PMODE_1_bm = (1<<5)           ; Parity Mode bit 1 mask
  USART_PMODE_1_bp = 5                ; Parity Mode bit 1 position
  USART_CMODE_gm = 0xC0               ; Communication Mode group mask
  USART_CMODE_gp = 6                  ; Communication Mode group position
  USART_CMODE_0_bm = (1<<6)           ; Communication Mode bit 0 mask
  USART_CMODE_0_bp = 6                ; Communication Mode bit 0 position
  USART_CMODE_1_bm = (1<<7)           ; Communication Mode bit 1 mask
  USART_CMODE_1_bp = 7                ; Communication Mode bit 1 position
  
  ; USART_CTRLD masks
  USART_ABW_gm = 0xC0                 ; Auto Baud Window group mask
  USART_ABW_gp = 6                    ; Auto Baud Window group position
  USART_ABW_0_bm = (1<<6)             ; Auto Baud Window bit 0 mask
  USART_ABW_0_bp = 6                  ; Auto Baud Window bit 0 position
  USART_ABW_1_bm = (1<<7)             ; Auto Baud Window bit 1 mask
  USART_ABW_1_bp = 7                  ; Auto Baud Window bit 1 position
  
  ; USART_DBGCTRL masks
  USART_DBGRUN_bm = 0x01              ; Debug Run bit mask
  USART_DBGRUN_bp = 0                 ; Debug Run bit position
  
  ; USART_EVCTRL masks
  USART_IREI_bm = 0x01                ; IrDA Event Input Enable bit mask
  USART_IREI_bp = 0                   ; IrDA Event Input Enable bit position
  
  ; USART_TXPLCTRL masks
  USART_TXPL_gm = 0xFF                ; Transmit pulse length group mask
  USART_TXPL_gp = 0                   ; Transmit pulse length group position
  USART_TXPL_0_bm = (1<<0)            ; Transmit pulse length bit 0 mask
  USART_TXPL_0_bp = 0                 ; Transmit pulse length bit 0 position
  USART_TXPL_1_bm = (1<<1)            ; Transmit pulse length bit 1 mask
  USART_TXPL_1_bp = 1                 ; Transmit pulse length bit 1 position
  USART_TXPL_2_bm = (1<<2)            ; Transmit pulse length bit 2 mask
  USART_TXPL_2_bp = 2                 ; Transmit pulse length bit 2 position
  USART_TXPL_3_bm = (1<<3)            ; Transmit pulse length bit 3 mask
  USART_TXPL_3_bp = 3                 ; Transmit pulse length bit 3 position
  USART_TXPL_4_bm = (1<<4)            ; Transmit pulse length bit 4 mask
  USART_TXPL_4_bp = 4                 ; Transmit pulse length bit 4 position
  USART_TXPL_5_bm = (1<<5)            ; Transmit pulse length bit 5 mask
  USART_TXPL_5_bp = 5                 ; Transmit pulse length bit 5 position
  USART_TXPL_6_bm = (1<<6)            ; Transmit pulse length bit 6 mask
  USART_TXPL_6_bp = 6                 ; Transmit pulse length bit 6 position
  USART_TXPL_7_bm = (1<<7)            ; Transmit pulse length bit 7 mask
  USART_TXPL_7_bp = 7                 ; Transmit pulse length bit 7 position
  
  ; USART_RXPLCTRL masks
  USART_RXPL_gm = 0x7F                ; Receiver Pulse Lenght group mask
  USART_RXPL_gp = 0                   ; Receiver Pulse Lenght group position
  USART_RXPL_0_bm = (1<<0)            ; Receiver Pulse Lenght bit 0 mask
  USART_RXPL_0_bp = 0                 ; Receiver Pulse Lenght bit 0 position
  USART_RXPL_1_bm = (1<<1)            ; Receiver Pulse Lenght bit 1 mask
  USART_RXPL_1_bp = 1                 ; Receiver Pulse Lenght bit 1 position
  USART_RXPL_2_bm = (1<<2)            ; Receiver Pulse Lenght bit 2 mask
  USART_RXPL_2_bp = 2                 ; Receiver Pulse Lenght bit 2 position
  USART_RXPL_3_bm = (1<<3)            ; Receiver Pulse Lenght bit 3 mask
  USART_RXPL_3_bp = 3                 ; Receiver Pulse Lenght bit 3 position
  USART_RXPL_4_bm = (1<<4)            ; Receiver Pulse Lenght bit 4 mask
  USART_RXPL_4_bp = 4                 ; Receiver Pulse Lenght bit 4 position
  USART_RXPL_5_bm = (1<<5)            ; Receiver Pulse Lenght bit 5 mask
  USART_RXPL_5_bp = 5                 ; Receiver Pulse Lenght bit 5 position
  USART_RXPL_6_bm = (1<<6)            ; Receiver Pulse Lenght bit 6 mask
  USART_RXPL_6_bp = 6                 ; Receiver Pulse Lenght bit 6 position
  
  ; RS485 Mode internal transmitter select
  USART_RS485_DISABLE_gc = (0x00<<0)  ; RS485 Mode disabled
  USART_RS485_ENABLE_gc = (0x01<<0)   ; RS485 Mode enabled
  
  ; Receiver Mode select
  USART_RXMODE_NORMAL_gc = (0x00<<1)  ; Normal mode
  USART_RXMODE_CLK2X_gc = (0x01<<1)   ; CLK2x mode
  USART_RXMODE_GENAUTO_gc = (0x02<<1) ; Generic autobaud mode
  USART_RXMODE_LINAUTO_gc = (0x03<<1) ; LIN constrained autobaud mode
  
  ; Communication Mode select
  USART_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode
  USART_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode
  USART_CMODE_IRCOM_gc = (0x02<<6)    ; Infrared Communication
  USART_CMODE_MSPI_gc = (0x03<<6)     ; SPI Host Mode
  
  ; Character Size select
  USART_NORMAL_CHSIZE_5BIT_gc = (0x00<<0) ; Character size: 5 bit
  USART_NORMAL_CHSIZE_6BIT_gc = (0x01<<0) ; Character size: 6 bit
  USART_NORMAL_CHSIZE_7BIT_gc = (0x02<<0) ; Character size: 7 bit
  USART_NORMAL_CHSIZE_8BIT_gc = (0x03<<0) ; Character size: 8 bit
  USART_NORMAL_CHSIZE_9BITL_gc = (0x06<<0) ; Character size: 9 bit read low byte first
  USART_NORMAL_CHSIZE_9BITH_gc = (0x07<<0) ; Character size: 9 bit read high byte first
  
  ; Parity Mode select
  USART_NORMAL_PMODE_DISABLED_gc = (0x00<<4) ; No Parity
  USART_NORMAL_PMODE_EVEN_gc = (0x02<<4) ; Even Parity
  USART_NORMAL_PMODE_ODD_gc = (0x03<<4) ; Odd Parity
  
  ; Stop Bit Mode select
  USART_NORMAL_SBMODE_1BIT_gc = (0x00<<3) ; 1 stop bit
  USART_NORMAL_SBMODE_2BIT_gc = (0x01<<3) ; 2 stop bits
  
  ; Auto Baud Window select
  USART_ABW_WDW0_gc = (0x00<<6)       ; 18% tolerance
  USART_ABW_WDW1_gc = (0x01<<6)       ; 15% tolerance
  USART_ABW_WDW2_gc = (0x02<<6)       ; 21% tolerance
  USART_ABW_WDW3_gc = (0x03<<6)       ; 25% tolerance
  
  
  ;*************************************************************************
  ;** USERROW - User Row
  ;*************************************************************************
  
  
  ;*************************************************************************
  ;** VPORT - Virtual Ports
  ;*************************************************************************
  
  ; VPORT_INTFLAGS masks
  VPORT_INT_gm = 0xFF                 ; Pin Interrupt Flag group mask
  VPORT_INT_gp = 0                    ; Pin Interrupt Flag group position
  VPORT_INT_0_bm = (1<<0)             ; Pin Interrupt Flag bit 0 mask
  VPORT_INT_0_bp = 0                  ; Pin Interrupt Flag bit 0 position
  VPORT_INT_1_bm = (1<<1)             ; Pin Interrupt Flag bit 1 mask
  VPORT_INT_1_bp = 1                  ; Pin Interrupt Flag bit 1 position
  VPORT_INT_2_bm = (1<<2)             ; Pin Interrupt Flag bit 2 mask
  VPORT_INT_2_bp = 2                  ; Pin Interrupt Flag bit 2 position
  VPORT_INT_3_bm = (1<<3)             ; Pin Interrupt Flag bit 3 mask
  VPORT_INT_3_bp = 3                  ; Pin Interrupt Flag bit 3 position
  VPORT_INT_4_bm = (1<<4)             ; Pin Interrupt Flag bit 4 mask
  VPORT_INT_4_bp = 4                  ; Pin Interrupt Flag bit 4 position
  VPORT_INT_5_bm = (1<<5)             ; Pin Interrupt Flag bit 5 mask
  VPORT_INT_5_bp = 5                  ; Pin Interrupt Flag bit 5 position
  VPORT_INT_6_bm = (1<<6)             ; Pin Interrupt Flag bit 6 mask
  VPORT_INT_6_bp = 6                  ; Pin Interrupt Flag bit 6 position
  VPORT_INT_7_bm = (1<<7)             ; Pin Interrupt Flag bit 7 mask
  VPORT_INT_7_bp = 7                  ; Pin Interrupt Flag bit 7 position
  
  
  ;*************************************************************************
  ;** VREF - Voltage reference
  ;*************************************************************************
  
  ; VREF_ADC0REF masks
  VREF_REFSEL_gm = 0x07               ; Reference select group mask
  VREF_REFSEL_gp = 0                  ; Reference select group position
  VREF_REFSEL_0_bm = (1<<0)           ; Reference select bit 0 mask
  VREF_REFSEL_0_bp = 0                ; Reference select bit 0 position
  VREF_REFSEL_1_bm = (1<<1)           ; Reference select bit 1 mask
  VREF_REFSEL_1_bp = 1                ; Reference select bit 1 position
  VREF_REFSEL_2_bm = (1<<2)           ; Reference select bit 2 mask
  VREF_REFSEL_2_bp = 2                ; Reference select bit 2 position
  VREF_ALWAYSON_bm = 0x80             ; Always on bit mask
  VREF_ALWAYSON_bp = 7                ; Always on bit position
  
  ; VREF_DAC0REF masks
  ; Masks for VREF_REFSEL already defined
  ; Masks for VREF_ALWAYSON already defined
  
  ; VREF_ACREF masks
  ; Masks for VREF_REFSEL already defined
  ; Masks for VREF_ALWAYSON already defined
  
  ; Reference select
  VREF_REFSEL_1V024_gc = (0x00<<0)    ; Internal 1.024V reference
  VREF_REFSEL_2V048_gc = (0x01<<0)    ; Internal 2.048V reference
  VREF_REFSEL_4V096_gc = (0x02<<0)    ; Internal 4.096V reference
  VREF_REFSEL_2V500_gc = (0x03<<0)    ; Internal 2.500V reference
  VREF_REFSEL_VDD_gc = (0x05<<0)      ; VDD as reference
  VREF_REFSEL_VREFA_gc = (0x06<<0)    ; External reference on VREFA pin
  
  
  ;*************************************************************************
  ;** WDT - Watch-Dog Timer
  ;*************************************************************************
  
  ; WDT_CTRLA masks
  WDT_PERIOD_gm = 0x0F                ; Period group mask
  WDT_PERIOD_gp = 0                   ; Period group position
  WDT_PERIOD_0_bm = (1<<0)            ; Period bit 0 mask
  WDT_PERIOD_0_bp = 0                 ; Period bit 0 position
  WDT_PERIOD_1_bm = (1<<1)            ; Period bit 1 mask
  WDT_PERIOD_1_bp = 1                 ; Period bit 1 position
  WDT_PERIOD_2_bm = (1<<2)            ; Period bit 2 mask
  WDT_PERIOD_2_bp = 2                 ; Period bit 2 position
  WDT_PERIOD_3_bm = (1<<3)            ; Period bit 3 mask
  WDT_PERIOD_3_bp = 3                 ; Period bit 3 position
  WDT_WINDOW_gm = 0xF0                ; Window group mask
  WDT_WINDOW_gp = 4                   ; Window group position
  WDT_WINDOW_0_bm = (1<<4)            ; Window bit 0 mask
  WDT_WINDOW_0_bp = 4                 ; Window bit 0 position
  WDT_WINDOW_1_bm = (1<<5)            ; Window bit 1 mask
  WDT_WINDOW_1_bp = 5                 ; Window bit 1 position
  WDT_WINDOW_2_bm = (1<<6)            ; Window bit 2 mask
  WDT_WINDOW_2_bp = 6                 ; Window bit 2 position
  WDT_WINDOW_3_bm = (1<<7)            ; Window bit 3 mask
  WDT_WINDOW_3_bp = 7                 ; Window bit 3 position
  
  ; WDT_STATUS masks
  WDT_SYNCBUSY_bm = 0x01              ; Syncronization busy bit mask
  WDT_SYNCBUSY_bp = 0                 ; Syncronization busy bit position
  WDT_LOCK_bm = 0x80                  ; Lock enable bit mask
  WDT_LOCK_bp = 7                     ; Lock enable bit position
  
  ; Period select
  WDT_PERIOD_OFF_gc = (0x00<<0)       ; Off
  WDT_PERIOD_8CLK_gc = (0x01<<0)      ; 8 cycles (8ms)
  WDT_PERIOD_16CLK_gc = (0x02<<0)     ; 16 cycles (16ms)
  WDT_PERIOD_32CLK_gc = (0x03<<0)     ; 32 cycles (32ms)
  WDT_PERIOD_64CLK_gc = (0x04<<0)     ; 64 cycles (64ms)
  WDT_PERIOD_128CLK_gc = (0x05<<0)    ; 128 cycles (0.128s)
  WDT_PERIOD_256CLK_gc = (0x06<<0)    ; 256 cycles (0.256s)
  WDT_PERIOD_512CLK_gc = (0x07<<0)    ; 512 cycles (0.512s)
  WDT_PERIOD_1KCLK_gc = (0x08<<0)     ; 1K cycles (1.0s)
  WDT_PERIOD_2KCLK_gc = (0x09<<0)     ; 2K cycles (2.0s)
  WDT_PERIOD_4KCLK_gc = (0x0A<<0)     ; 4K cycles (4.1s)
  WDT_PERIOD_8KCLK_gc = (0x0B<<0)     ; 8K cycles (8.2s)
  
  ; Window select
  WDT_WINDOW_OFF_gc = (0x00<<4)       ; Off
  WDT_WINDOW_8CLK_gc = (0x01<<4)      ; 8 cycles (8ms)
  WDT_WINDOW_16CLK_gc = (0x02<<4)     ; 16 cycles (16ms)
  WDT_WINDOW_32CLK_gc = (0x03<<4)     ; 32 cycles (32ms)
  WDT_WINDOW_64CLK_gc = (0x04<<4)     ; 64 cycles (64ms)
  WDT_WINDOW_128CLK_gc = (0x05<<4)    ; 128 cycles (0.128s)
  WDT_WINDOW_256CLK_gc = (0x06<<4)    ; 256 cycles (0.256s)
  WDT_WINDOW_512CLK_gc = (0x07<<4)    ; 512 cycles (0.512s)
  WDT_WINDOW_1KCLK_gc = (0x08<<4)     ; 1K cycles (1.0s)
  WDT_WINDOW_2KCLK_gc = (0x09<<4)     ; 2K cycles (2.0s)
  WDT_WINDOW_4KCLK_gc = (0x0A<<4)     ; 4K cycles (4.1s)
  WDT_WINDOW_8KCLK_gc = (0x0B<<4)     ; 8K cycles (8.2s)
  
  
  ;*************************************************************************
  ;** ZCD - Zero Cross Detect
  ;*************************************************************************
  
  ; ZCD_CTRLA masks
  ZCD_ENABLE_bm = 0x01                ; Enable bit mask
  ZCD_ENABLE_bp = 0                   ; Enable bit position
  ZCD_INVERT_bm = 0x08                ; Invert signal from pin bit mask
  ZCD_INVERT_bp = 3                   ; Invert signal from pin bit position
  ZCD_OUTEN_bm = 0x40                 ; Output Pad Enable bit mask
  ZCD_OUTEN_bp = 6                    ; Output Pad Enable bit position
  ZCD_RUNSTDBY_bm = 0x80              ; Run in Standby Mode bit mask
  ZCD_RUNSTDBY_bp = 7                 ; Run in Standby Mode bit position
  
  ; ZCD_INTCTRL masks
  ZCD_INTMODE_gm = 0x03               ; Interrupt Mode group mask
  ZCD_INTMODE_gp = 0                  ; Interrupt Mode group position
  ZCD_INTMODE_0_bm = (1<<0)           ; Interrupt Mode bit 0 mask
  ZCD_INTMODE_0_bp = 0                ; Interrupt Mode bit 0 position
  ZCD_INTMODE_1_bm = (1<<1)           ; Interrupt Mode bit 1 mask
  ZCD_INTMODE_1_bp = 1                ; Interrupt Mode bit 1 position
  
  ; ZCD_STATUS masks
  ZCD_CROSSIF_bm = 0x01               ; ZCD Interrupt Flag bit mask
  ZCD_CROSSIF_bp = 0                  ; ZCD Interrupt Flag bit position
  ZCD_STATE_bm = 0x10                 ; ZCD State bit mask
  ZCD_STATE_bp = 4                    ; ZCD State bit position
  
  ; Interrupt Mode select
  ZCD_INTMODE_NONE_gc = (0x00<<0)     ; No interrupt
  ZCD_INTMODE_RISING_gc = (0x01<<0)   ; Interrupt on rising input signal
  ZCD_INTMODE_FALLING_gc = (0x02<<0)  ; Interrupt on falling input signal
  ZCD_INTMODE_BOTH_gc = (0x03<<0)     ; Interrupt on both rising and falling input signal
  
  ; ZCD State select
  ZCD_STATE_LOW_gc = (0x00<<4)        ; Output is 0
  ZCD_STATE_HIGH_gc = (0x01<<4)       ; Output is 1
  
  
  
  

[Registers]
'For specific details of the registers see the microcontroller datasheet
'The first parameter is the GCBASIC register name used in user code to expose the specific register
 AC0_CTRLA,1664
 AC0_MUXCTRL,1666
 AC0_DACREF,1669
 AC0_INTCTRL,1670
 AC0_STATUS,1671
 ADC0_CTRLA,1536
 ADC0_CTRLB,1537
 ADC0_CTRLC,1538
 ADC0_CTRLD,1539
 ADC0_CTRLE,1540
 ADC0_SAMPCTRL,1541
 ADC0_MUXPOS,1544
 ADC0_MUXNEG,1545
 ADC0_COMMAND,1546
 ADC0_EVCTRL,1547
 ADC0_INTCTRL,1548
 ADC0_INTFLAGS,1549
 ADC0_DBGCTRL,1550
 ADC0_TEMP,1551
 ADC0_RES,1552
 ADC0_RESL,1552
 ADC0_RESH,1553
 ADC0_WINLT,1554
 ADC0_WINLTL,1554
 ADC0_WINLTH,1555
 ADC0_WINHT,1556
 ADC0_WINHTL,1556
 ADC0_WINHTH,1557
 BOD_CTRLA,160
 BOD_CTRLB,161
 BOD_VLMCTRLA,168
 BOD_INTCTRL,169
 BOD_INTFLAGS,170
 BOD_STATUS,171
 CCL_CTRLA,448
 CCL_SEQCTRL0,449
 CCL_SEQCTRL1,450
 CCL_INTCTRL0,453
 CCL_INTFLAGS,455
 CCL_LUT0CTRLA,456
 CCL_LUT0CTRLB,457
 CCL_LUT0CTRLC,458
 CCL_TRUTH0,459
 CCL_LUT1CTRLA,460
 CCL_LUT1CTRLB,461
 CCL_LUT1CTRLC,462
 CCL_TRUTH1,463
 CCL_LUT2CTRLA,464
 CCL_LUT2CTRLB,465
 CCL_LUT2CTRLC,466
 CCL_TRUTH2,467
 CCL_LUT3CTRLA,468
 CCL_LUT3CTRLB,469
 CCL_LUT3CTRLC,470
 CCL_TRUTH3,471
 CLKCTRL_MCLKCTRLA,96
 CLKCTRL_MCLKCTRLB,97
 CLKCTRL_MCLKCTRLC,98
 CLKCTRL_MCLKINTCTRL,99
 CLKCTRL_MCLKINTFLAGS,100
 CLKCTRL_MCLKSTATUS,101
 CLKCTRL_OSCHFCTRLA,104
 CLKCTRL_OSCHFTUNE,105
 CLKCTRL_PLLCTRLA,112
 CLKCTRL_OSC32KCTRLA,120
 CLKCTRL_XOSC32KCTRLA,124
 CLKCTRL_XOSCHFCTRLA,128
 CPU_CCP,52
 CPU_SP,61
; .equ CPU_SPL = 0x003D                    ; Stack Pointer low byte a duplicate or resevered register or ALIAS_
; .equ CPU_SPH = 0x003E                    ; Stack Pointer hi byte a duplicate or resevered register or ALIAS_
 CPU_SREG,63
 CPUINT_CTRLA,272
 CPUINT_STATUS,273
 CPUINT_LVL0PRI,274
 CPUINT_LVL1VEC,275
 CRCSCAN_CTRLA,288
 CRCSCAN_CTRLB,289
 CRCSCAN_STATUS,290
 DAC0_CTRLA,1696
 DAC0_DATA,1698
 DAC0_DATAL,1698
 DAC0_DATAH,1699
 EVSYS_SWEVENTA,512
 EVSYS_SWEVENTB,513
 EVSYS_CHANNEL0,528
 EVSYS_CHANNEL1,529
 EVSYS_CHANNEL2,530
 EVSYS_CHANNEL3,531
 EVSYS_CHANNEL4,532
 EVSYS_CHANNEL5,533
 EVSYS_USERCCLLUT0A,544
 EVSYS_USERCCLLUT0B,545
 EVSYS_USERCCLLUT1A,546
 EVSYS_USERCCLLUT1B,547
 EVSYS_USERCCLLUT2A,548
 EVSYS_USERCCLLUT2B,549
 EVSYS_USERCCLLUT3A,550
 EVSYS_USERCCLLUT3B,551
 EVSYS_USERADC0START,552
 EVSYS_USEREVSYSEVOUTA,553
 EVSYS_USEREVSYSEVOUTC,554
 EVSYS_USEREVSYSEVOUTD,555
 EVSYS_USEREVSYSEVOUTF,556
 EVSYS_USERUSART0IRDA,557
 EVSYS_USERUSART1IRDA,558
 EVSYS_USERTCA0CNTA,559
 EVSYS_USERTCA0CNTB,560
 EVSYS_USERTCB0CAPT,561
 EVSYS_USERTCB0COUNT,562
 EVSYS_USERTCB1CAPT,563
 EVSYS_USERTCB1COUNT,564
 EVSYS_USERTCB2CAPT,565
 EVSYS_USERTCB2COUNT,566
 EVSYS_USERTCD0INPUTA,567
 EVSYS_USERTCD0INPUTB,568
 FUSE_WDTCFG,4176
 FUSE_BODCFG,4177
 FUSE_OSCCFG,4178
 FUSE_SYSCFG0,4181
 FUSE_SYSCFG1,4182
 FUSE_CODESIZE,4183
 FUSE_BOOTSIZE,4184
 GPR_GPR0,28
 GPR_GPR1,29
 GPR_GPR2,30
 GPR_GPR3,31
 LOCK_KEY,4160
 LOCK_KEY0,4160
 LOCK_KEY1,4161
 LOCK_KEY2,4162
 LOCK_KEY3,4163
 MVIO_INTCTRL,192
 MVIO_INTFLAGS,193
 MVIO_STATUS,194
 NVMCTRL_CTRLA,4096
 NVMCTRL_CTRLB,4097
 NVMCTRL_STATUS,4098
 NVMCTRL_INTCTRL,4099
 NVMCTRL_INTFLAGS,4100
 NVMCTRL_DATA,4102
 NVMCTRL_DATAL,4102
 NVMCTRL_DATAH,4103
 NVMCTRL_ADDR,4104
 NVMCTRL_ADDR0,4104
 NVMCTRL_ADDR1,4105
 NVMCTRL_ADDR2,4106
 NVMCTRL_ADDR3,4107
 PORTA_DIR,1024
 PORTA_DIRSET,1025
 PORTA_DIRCLR,1026
 PORTA_DIRTGL,1027
 PORTA_OUT,1028
 PORTA_OUTSET,1029
 PORTA_OUTCLR,1030
 PORTA_OUTTGL,1031
 PORTA_IN,1032
 PORTA_INTFLAGS,1033
 PORTA_PORTCTRL,1034
 PORTA_PINCONFIG,1035
 PORTA_PINCTRLUPD,1036
 PORTA_PINCTRLSET,1037
 PORTA_PINCTRLCLR,1038
 PORTA_PIN0CTRL,1040
 PORTA_PIN1CTRL,1041
 PORTA_PIN2CTRL,1042
 PORTA_PIN3CTRL,1043
 PORTA_PIN4CTRL,1044
 PORTA_PIN5CTRL,1045
 PORTA_PIN6CTRL,1046
 PORTA_PIN7CTRL,1047
 PORTC_DIR,1088
 PORTC_DIRSET,1089
 PORTC_DIRCLR,1090
 PORTC_DIRTGL,1091
 PORTC_OUT,1092
 PORTC_OUTSET,1093
 PORTC_OUTCLR,1094
 PORTC_OUTTGL,1095
 PORTC_IN,1096
 PORTC_INTFLAGS,1097
 PORTC_PORTCTRL,1098
 PORTC_PINCONFIG,1099
 PORTC_PINCTRLUPD,1100
 PORTC_PINCTRLSET,1101
 PORTC_PINCTRLCLR,1102
 PORTC_PIN0CTRL,1104
 PORTC_PIN1CTRL,1105
 PORTC_PIN2CTRL,1106
 PORTC_PIN3CTRL,1107
 PORTC_PIN4CTRL,1108
 PORTC_PIN5CTRL,1109
 PORTC_PIN6CTRL,1110
 PORTC_PIN7CTRL,1111
 PORTD_DIR,1120
 PORTD_DIRSET,1121
 PORTD_DIRCLR,1122
 PORTD_DIRTGL,1123
 PORTD_OUT,1124
 PORTD_OUTSET,1125
 PORTD_OUTCLR,1126
 PORTD_OUTTGL,1127
 PORTD_IN,1128
 PORTD_INTFLAGS,1129
 PORTD_PORTCTRL,1130
 PORTD_PINCONFIG,1131
 PORTD_PINCTRLUPD,1132
 PORTD_PINCTRLSET,1133
 PORTD_PINCTRLCLR,1134
 PORTD_PIN0CTRL,1136
 PORTD_PIN1CTRL,1137
 PORTD_PIN2CTRL,1138
 PORTD_PIN3CTRL,1139
 PORTD_PIN4CTRL,1140
 PORTD_PIN5CTRL,1141
 PORTD_PIN6CTRL,1142
 PORTD_PIN7CTRL,1143
 PORTF_DIR,1184
 PORTF_DIRSET,1185
 PORTF_DIRCLR,1186
 PORTF_DIRTGL,1187
 PORTF_OUT,1188
 PORTF_OUTSET,1189
 PORTF_OUTCLR,1190
 PORTF_OUTTGL,1191
 PORTF_IN,1192
 PORTF_INTFLAGS,1193
 PORTF_PORTCTRL,1194
 PORTF_PINCONFIG,1195
 PORTF_PINCTRLUPD,1196
 PORTF_PINCTRLSET,1197
 PORTF_PINCTRLCLR,1198
 PORTF_PIN0CTRL,1200
 PORTF_PIN1CTRL,1201
 PORTF_PIN2CTRL,1202
 PORTF_PIN3CTRL,1203
 PORTF_PIN4CTRL,1204
 PORTF_PIN5CTRL,1205
 PORTF_PIN6CTRL,1206
 PORTF_PIN7CTRL,1207
 PORTMUX_EVSYSROUTEA,1504
 PORTMUX_CCLROUTEA,1505
 PORTMUX_USARTROUTEA,1506
 PORTMUX_SPIROUTEA,1509
 PORTMUX_TWIROUTEA,1510
 PORTMUX_TCAROUTEA,1511
 PORTMUX_TCBROUTEA,1512
 PORTMUX_TCDROUTEA,1513
 RSTCTRL_RSTFR,64
 RSTCTRL_SWRR,65
 RTC_CTRLA,320
 RTC_STATUS,321
 RTC_INTCTRL,322
 RTC_INTFLAGS,323
 RTC_TEMP,324
 RTC_DBGCTRL,325
 RTC_CALIB,326
 RTC_CLKSEL,327
 RTC_CNT,328
 RTC_CNTL,328
 RTC_CNTH,329
 RTC_PER,330
 RTC_PERL,330
 RTC_PERH,331
; .equ RTC_CMP = 0x014C                    ; Compare a duplicate or resevered register or ALIAS_
; .equ RTC_CMPL = 0x014C                   ; Compare low byte a duplicate or resevered register or ALIAS_
; .equ RTC_CMPH = 0x014D                   ; Compare hi byte a duplicate or resevered register or ALIAS_
 RTC_PITCTRLA,336
 RTC_PITSTATUS,337
 RTC_PITINTCTRL,338
 RTC_PITINTFLAGS,339
 RTC_PITDBGCTRL,341
 SIGROW_DEVICEID0,4352
 SIGROW_DEVICEID1,4353
 SIGROW_DEVICEID2,4354
 SIGROW_TEMPSENSE0,4356
 SIGROW_TEMPSENSE0L,4356
 SIGROW_TEMPSENSE0H,4357
 SIGROW_TEMPSENSE1,4358
 SIGROW_TEMPSENSE1L,4358
 SIGROW_TEMPSENSE1H,4359
 SIGROW_SERNUM0,4368
 SIGROW_SERNUM1,4369
 SIGROW_SERNUM2,4370
 SIGROW_SERNUM3,4371
 SIGROW_SERNUM4,4372
 SIGROW_SERNUM5,4373
 SIGROW_SERNUM6,4374
 SIGROW_SERNUM7,4375
 SIGROW_SERNUM8,4376
 SIGROW_SERNUM9,4377
 SIGROW_SERNUM10,4378
 SIGROW_SERNUM11,4379
 SIGROW_SERNUM12,4380
 SIGROW_SERNUM13,4381
 SIGROW_SERNUM14,4382
 SIGROW_SERNUM15,4383
 SLPCTRL_CTRLA,80
 SLPCTRL_VREGCTRL,81
 SPI0_CTRLA,2368
 SPI0_CTRLB,2369
 SPI0_INTCTRL,2370
 SPI0_INTFLAGS,2371
 SPI0_DATA,2372
 SYSCFG_REVID,3841
 SYSCFG_OCDMCTRL,3844
 SYSCFG_OCDMSTATUS,3845
 TCA0_SINGLE_CTRLA,2560
 TCA0_SPLIT_CTRLA,2560
 TCA0_SINGLE_CTRLB,2561
 TCA0_SPLIT_CTRLB,2561
 TCA0_SINGLE_CTRLC,2562
 TCA0_SPLIT_CTRLC,2562
 TCA0_SINGLE_CTRLD,2563
 TCA0_SPLIT_CTRLD,2563
 TCA0_SINGLE_CTRLECLR,2564
 TCA0_SPLIT_CTRLECLR,2564
 TCA0_SINGLE_CTRLESET,2565
 TCA0_SPLIT_CTRLESET,2565
 TCA0_SINGLE_CTRLFCLR,2566
 TCA0_SINGLE_CTRLFSET,2567
 TCA0_SINGLE_EVCTRL,2569
 TCA0_SINGLE_INTCTRL,2570
 TCA0_SPLIT_INTCTRL,2570
 TCA0_SINGLE_INTFLAGS,2571
 TCA0_SPLIT_INTFLAGS,2571
 TCA0_SINGLE_DBGCTRL,2574
 TCA0_SPLIT_DBGCTRL,2574
 TCA0_SINGLE_TEMP,2575
 TCA0_SINGLE_CNT,2592
 TCA0_SINGLE_CNTL,2592
 TCA0_SINGLE_CNTH,2593
 TCA0_SPLIT_LCNT,2592
 TCA0_SPLIT_HCNT,2593
 TCA0_SINGLE_PER,2598
 TCA0_SINGLE_PERL,2598
 TCA0_SINGLE_PERH,2599
 TCA0_SPLIT_LPER,2598
 TCA0_SPLIT_HPER,2599
 TCA0_SINGLE_CMP0,2600
 TCA0_SINGLE_CMP0L,2600
 TCA0_SINGLE_CMP0H,2601
 TCA0_SPLIT_LCMP0,2600
 TCA0_SPLIT_HCMP0,2601
 TCA0_SINGLE_CMP1,2602
 TCA0_SINGLE_CMP1L,2602
 TCA0_SINGLE_CMP1H,2603
 TCA0_SPLIT_LCMP1,2602
 TCA0_SPLIT_HCMP1,2603
 TCA0_SINGLE_CMP2,2604
 TCA0_SINGLE_CMP2L,2604
 TCA0_SINGLE_CMP2H,2605
 TCA0_SPLIT_LCMP2,2604
 TCA0_SPLIT_HCMP2,2605
 TCA0_SINGLE_PERBUF,2614
 TCA0_SINGLE_PERBUFL,2614
 TCA0_SINGLE_PERBUFH,2615
 TCA0_SINGLE_CMP0BUF,2616
 TCA0_SINGLE_CMP0BUFL,2616
 TCA0_SINGLE_CMP0BUFH,2617
 TCA0_SINGLE_CMP1BUF,2618
 TCA0_SINGLE_CMP1BUFL,2618
 TCA0_SINGLE_CMP1BUFH,2619
 TCA0_SINGLE_CMP2BUF,2620
 TCA0_SINGLE_CMP2BUFL,2620
 TCA0_SINGLE_CMP2BUFH,2621
 TCB0_CTRLA,2816
 TCB0_CTRLB,2817
 TCB0_EVCTRL,2820
 TCB0_INTCTRL,2821
 TCB0_INTFLAGS,2822
 TCB0_STATUS,2823
 TCB0_DBGCTRL,2824
 TCB0_TEMP,2825
 TCB0_CNT,2826
 TCB0_CNTL,2826
 TCB0_CNTH,2827
 TCB0_CCMP,2828
 TCB0_CCMPL,2828
 TCB0_CCMPH,2829
 TCB1_CTRLA,2832
 TCB1_CTRLB,2833
 TCB1_EVCTRL,2836
 TCB1_INTCTRL,2837
 TCB1_INTFLAGS,2838
 TCB1_STATUS,2839
 TCB1_DBGCTRL,2840
 TCB1_TEMP,2841
 TCB1_CNT,2842
 TCB1_CNTL,2842
 TCB1_CNTH,2843
 TCB1_CCMP,2844
 TCB1_CCMPL,2844
 TCB1_CCMPH,2845
 TCB2_CTRLA,2848
 TCB2_CTRLB,2849
 TCB2_EVCTRL,2852
 TCB2_INTCTRL,2853
 TCB2_INTFLAGS,2854
 TCB2_STATUS,2855
 TCB2_DBGCTRL,2856
 TCB2_TEMP,2857
 TCB2_CNT,2858
 TCB2_CNTL,2858
 TCB2_CNTH,2859
 TCB2_CCMP,2860
 TCB2_CCMPL,2860
 TCB2_CCMPH,2861
 TCD0_CTRLA,2944
 TCD0_CTRLB,2945
 TCD0_CTRLC,2946
 TCD0_CTRLD,2947
 TCD0_CTRLE,2948
 TCD0_EVCTRLA,2952
 TCD0_EVCTRLB,2953
 TCD0_INTCTRL,2956
 TCD0_INTFLAGS,2957
 TCD0_STATUS,2958
 TCD0_INPUTCTRLA,2960
 TCD0_INPUTCTRLB,2961
 TCD0_FAULTCTRL,2962
 TCD0_DLYCTRL,2964
 TCD0_DLYVAL,2965
 TCD0_DITCTRL,2968
 TCD0_DITVAL,2969
 TCD0_DBGCTRL,2974
 TCD0_CAPTUREA,2978
 TCD0_CAPTUREAL,2978
 TCD0_CAPTUREAH,2979
 TCD0_CAPTUREB,2980
 TCD0_CAPTUREBL,2980
 TCD0_CAPTUREBH,2981
 TCD0_CMPASET,2984
 TCD0_CMPASETL,2984
 TCD0_CMPASETH,2985
 TCD0_CMPACLR,2986
 TCD0_CMPACLRL,2986
 TCD0_CMPACLRH,2987
 TCD0_CMPBSET,2988
 TCD0_CMPBSETL,2988
 TCD0_CMPBSETH,2989
 TCD0_CMPBCLR,2990
 TCD0_CMPBCLRL,2990
 TCD0_CMPBCLRH,2991
 TWI0_CTRLA,2304
 TWI0_DUALCTRL,2305
 TWI0_DBGCTRL,2306
 TWI0_MCTRLA,2307
 TWI0_MCTRLB,2308
 TWI0_MSTATUS,2309
 TWI0_MBAUD,2310
 TWI0_MADDR,2311
 TWI0_MDATA,2312
 TWI0_SCTRLA,2313
 TWI0_SCTRLB,2314
 TWI0_SSTATUS,2315
 TWI0_SADDR,2316
 TWI0_SDATA,2317
 TWI0_SADDRMASK,2318
 USART0_RXDATAL,2048
 USART0_RXDATAH,2049
 USART0_TXDATAL,2050
 USART0_TXDATAH,2051
 USART0_STATUS,2052
 USART0_CTRLA,2053
 USART0_CTRLB,2054
 USART0_CTRLC,2055
 USART0_BAUD,2056
 USART0_BAUDL,2056
 USART0_BAUDH,2057
 USART0_CTRLD,2058
 USART0_DBGCTRL,2059
 USART0_EVCTRL,2060
 USART0_TXPLCTRL,2061
 USART0_RXPLCTRL,2062
 USART1_RXDATAL,2080
 USART1_RXDATAH,2081
 USART1_TXDATAL,2082
 USART1_TXDATAH,2083
 USART1_STATUS,2084
 USART1_CTRLA,2085
 USART1_CTRLB,2086
 USART1_CTRLC,2087
 USART1_BAUD,2088
 USART1_BAUDL,2088
 USART1_BAUDH,2089
 USART1_CTRLD,2090
 USART1_DBGCTRL,2091
 USART1_EVCTRL,2092
 USART1_TXPLCTRL,2093
 USART1_RXPLCTRL,2094
 USERROW_USERROW0,4224
 USERROW_USERROW1,4225
 USERROW_USERROW2,4226
 USERROW_USERROW3,4227
 USERROW_USERROW4,4228
 USERROW_USERROW5,4229
 USERROW_USERROW6,4230
 USERROW_USERROW7,4231
 USERROW_USERROW8,4232
 USERROW_USERROW9,4233
 USERROW_USERROW10,4234
 USERROW_USERROW11,4235
 USERROW_USERROW12,4236
 USERROW_USERROW13,4237
 USERROW_USERROW14,4238
 USERROW_USERROW15,4239
 USERROW_USERROW16,4240
 USERROW_USERROW17,4241
 USERROW_USERROW18,4242
 USERROW_USERROW19,4243
 USERROW_USERROW20,4244
 USERROW_USERROW21,4245
 USERROW_USERROW22,4246
 USERROW_USERROW23,4247
 USERROW_USERROW24,4248
 USERROW_USERROW25,4249
 USERROW_USERROW26,4250
 USERROW_USERROW27,4251
 USERROW_USERROW28,4252
 USERROW_USERROW29,4253
 USERROW_USERROW30,4254
 USERROW_USERROW31,4255
 VPORTA_DIR,0
 VPORTA_OUT,1
 VPORTA_IN,2
 VPORTA_INTFLAGS,3
 VPORTC_DIR,8
 VPORTC_OUT,9
 VPORTC_IN,10
 VPORTC_INTFLAGS,11
 VPORTD_DIR,12
 VPORTD_OUT,13
 VPORTD_IN,14
 VPORTD_INTFLAGS,15
 VPORTF_DIR,20
 VPORTF_OUT,21
 VPORTF_IN,22
 VPORTF_INTFLAGS,23
 VREF_ADC0REF,176
 VREF_DAC0REF,178
 VREF_ACREF,180
 WDT_CTRLA,256
 WDT_STATUS,257
 ZCD3_CTRLA,1752
 ZCD3_INTCTRL,1754
 ZCD3_STATUS,1755

[Bits]
'For details of the bits (relative to a register in terms of registerbits) see the microcontroller datasheet
'The first parameter is the GCBASIC bit name used in user code to expose the specific registerbit
 ' Required for GCBASIC operations
  I,SREG,7
  T,SREG,6
  H,SREG,5
  S,SREG,4
  V,SREG,3
  N,SREG,2
  Z,SREG,1
  C,SREG,0
AC_ENABLE,AC,0			'  Enable bit position
AC_OUTEN,AC,6			'  Output Pad Enable bit position
AC_RUNSTDBY,AC,7			'  Run in Standby Mode bit position
AC_INITVAL,AC,6			'  AC Output Initial Value bit position
AC_INVERT,AC,7			'  Invert AC Output bit position
AC_CMP,AC,0			'  Interrupt Enable bit position
AC_CMPIF,AC,0			'  Analog Comparator Interrupt Flag bit position
AC_CMPSTATE,AC,4			'  Analog Comparator State bit position
ADC_ENABLE,ADC,0			'  ADC Enable bit position
ADC_FREERUN,ADC,1			'  Free running mode bit position
ADC_LEFTADJ,ADC,4			'  Left adjust result bit position
ADC_CONVMODE,ADC,5			'  Conversion mode bit position
ADC_RUNSTBY,ADC,7			'  Run standby mode bit position
ADC_STCONV,ADC,0			'  Start Conversion bit position
ADC_SPCONV,ADC,1			'  Stop Conversion bit position
ADC_STARTEI,ADC,0			'  Start Event Input Enable bit position
ADC_RESRDY,ADC,0			'  Result Ready Interrupt Enable bit position
ADC_WCMP,ADC,1			'  Window Comparator Interrupt Enable bit position
ADC_DBGRUN,ADC,0			'  Debug run bit position
BOD_SAMPFREQ,BOD,4			'  Sample frequency bit position
BOD_VLMIE,BOD,0			'  voltage level monitor interrrupt enable bit position
BOD_VLMIF,BOD,0			'  Voltage level monitor interrupt flag bit position
BOD_VLMS,BOD,0			'  Voltage level monitor status bit position
CCL_ENABLE,CCL,0			'  Enable bit position
CCL_RUNSTDBY,CCL,6			'  Run in Standby bit position
CCL_OUTEN,CCL,6			'  Output Enable bit position
CCL_EDGEDET,CCL,7			'  Edge Detection Enable bit position
CLKCTRL_CLKOUT,CLKCTRL,7			'  System clock out bit position
CLKCTRL_PEN,CLKCTRL,0			'  Prescaler enable bit position
CLKCTRL_CFDEN,CLKCTRL,0			'  Clock Failure Detect Enable bit position
CLKCTRL_CFDTST,CLKCTRL,1			'  Clock Failure Detect Test bit position
CLKCTRL_CFD,CLKCTRL,0			'  Clock Failure Detect Interrupt Enable bit position
CLKCTRL_INTTYPE,CLKCTRL,7			'  Interrupt type bit position
CLKCTRL_SOSC,CLKCTRL,0			'  System Oscillator changing bit position
CLKCTRL_OSCHFS,CLKCTRL,1			'  High frequency oscillator status bit position
CLKCTRL_OSC32KS,CLKCTRL,2			'  32KHz oscillator status bit position
CLKCTRL_XOSC32KS,CLKCTRL,3			'  32.768 kHz Crystal Oscillator status bit position
CLKCTRL_EXTS,CLKCTRL,4			'  External Clock status bit position
CLKCTRL_PLLS,CLKCTRL,5			'  PLL oscillator status bit position
CLKCTRL_AUTOTUNE,CLKCTRL,0			'  Autotune bit position
CLKCTRL_RUNSTDBY,CLKCTRL,7			'  Run standby bit position
CLKCTRL_SOURCE,CLKCTRL,6			'  Source bit position
CLKCTRL_ENABLE,CLKCTRL,0			'  Enable bit position
CLKCTRL_LPMODE,CLKCTRL,1			'  Low power mode bit position
CLKCTRL_SEL,CLKCTRL,2			'  Select bit position
CLKCTRL_SELHF,CLKCTRL,1			'  External Source Select bit position
CLKCTRL_RUNSTBY,CLKCTRL,7			'  Run Standby bit position
CPU_C,CPU,0			'  Carry Flag bit position
CPU_Z,CPU,1			'  Zero Flag bit position
CPU_N,CPU,2			'  Negative Flag bit position
CPU_V,CPU,3			'  Two's Complement Overflow Flag bit position
CPU_S,CPU,4			'  N Exclusive Or V Flag bit position
CPU_H,CPU,5			'  Half Carry Flag bit position
CPU_T,CPU,6			'  Transfer Bit bit position
CPU_I,CPU,7			'  Global Interrupt Enable Flag bit position
CPUINT_LVL0RR,CPUINT,0			'  Round-robin Scheduling Enable bit position
CPUINT_CVT,CPUINT,5			'  Compact Vector Table bit position
CPUINT_IVSEL,CPUINT,6			'  Interrupt Vector Select bit position
CPUINT_LVL0EX,CPUINT,0			'  Level 0 Interrupt Executing bit position
CPUINT_LVL1EX,CPUINT,1			'  Level 1 Interrupt Executing bit position
CPUINT_NMIEX,CPUINT,7			'  Non-maskable Interrupt Executing bit position
CRCSCAN_ENABLE,CRCSCAN,0			'  Enable CRC scan bit position
CRCSCAN_NMIEN,CRCSCAN,1			'  Enable NMI Trigger bit position
CRCSCAN_RESET,CRCSCAN,7			'  Reset CRC scan bit position
CRCSCAN_BUSY,CRCSCAN,0			'  CRC Busy bit position
CRCSCAN_OK,CRCSCAN,1			'  CRC Ok bit position
DAC_ENABLE,DAC,0			'  DAC Enable bit position
DAC_OUTEN,DAC,6			'  Output Buffer Enable bit position
DAC_RUNSTDBY,DAC,7			'  Run in Standby Mode bit position
FUSE_SAMPFREQ,FUSE,4			'  BOD Sample Frequency bit position
FUSE_EESAVE,FUSE,0			'  EEPROM Save bit position
FUSE_RSTPINCFG,FUSE,3			'  Reset Pin Configuration bit position
FUSE_UPDIPINCFG,FUSE,4			'  UPDI Pin Configuration bit position
FUSE_CRCSEL,FUSE,5			'  CRC Select bit position
MVIO_VDDIO2IE,MVIO,0			'  VDDIO2 Interrupt Enable bit position
MVIO_VDDIO2IF,MVIO,0			'  VDDIO2 Interrupt Flag bit position
MVIO_VDDIO2S,MVIO,0			'  VDDIO2 Status bit position
NVMCTRL_APPCODEWP,NVMCTRL,0			'  Application Code Write Protect bit position
NVMCTRL_BOOTRP,NVMCTRL,1			'  Boot Read Protect bit position
NVMCTRL_APPDATAWP,NVMCTRL,2			'  Application Data Write Protect bit position
NVMCTRL_FLMAPLOCK,NVMCTRL,7			'  Flash Mapping Lock bit position
NVMCTRL_FBUSY,NVMCTRL,0			'  Flash busy bit position
NVMCTRL_EEBUSY,NVMCTRL,1			'  EEPROM busy bit position
NVMCTRL_EEREADY,NVMCTRL,0			'  EEPROM Ready bit position
PORT_SRL,PORT,0			'  Slew Rate Limit Enable bit position
PORT_PULLUPEN,PORT,3			'  Pullup enable bit position
PORT_INLVL,PORT,6			'  Input level select bit position
PORT_INVEN,PORT,7			'  Inverted I/O Enable bit position
PORTMUX_EVOUTA,PORTMUX,0			'  Event Output A bit position
PORTMUX_EVOUTC,PORTMUX,2			'  Event Output C bit position
PORTMUX_EVOUTD,PORTMUX,3			'  Event Output D bit position
PORTMUX_EVOUTF,PORTMUX,5			'  Event Output F bit position
PORTMUX_LUT0,PORTMUX,0			'  CCL Look-Up Table 0 Signals bit position
PORTMUX_LUT1,PORTMUX,1			'  CCL Look-Up Table 1 Signals bit position
PORTMUX_LUT2,PORTMUX,2			'  CCL Look-Up Table 2 Signals bit position
PORTMUX_LUT3,PORTMUX,3			'  CCL Look-Up Table 3 Signals bit position
PORTMUX_TCB0,PORTMUX,0			'  TCB0 Output bit position
PORTMUX_TCB1,PORTMUX,1			'  TCB1 Output bit position
RSTCTRL_PORF,RSTCTRL,0			'  Power on Reset flag bit position
RSTCTRL_BORF,RSTCTRL,1			'  Brown out detector Reset flag bit position
RSTCTRL_EXTRF,RSTCTRL,2			'  External Reset flag bit position
RSTCTRL_WDRF,RSTCTRL,3			'  Watch dog Reset flag bit position
RSTCTRL_SWRF,RSTCTRL,4			'  Software Reset flag bit position
RSTCTRL_UPDIRF,RSTCTRL,5			'  UPDI Reset flag bit position
RSTCTRL_SWRST,RSTCTRL,0			'  Software reset enable bit position
RTC_RTCEN,RTC,0			'  Enable bit position
RTC_CORREN,RTC,2			'  Correction enable bit position
RTC_RUNSTDBY,RTC,7			'  Run In Standby bit position
RTC_CTRLABUSY,RTC,0			'  CTRLA Synchronization Busy Flag bit position
RTC_CNTBUSY,RTC,1			'  Count Synchronization Busy Flag bit position
RTC_PERBUSY,RTC,2			'  Period Synchronization Busy Flag bit position
RTC_CMPBUSY,RTC,3			'  Comparator Synchronization Busy Flag bit position
RTC_OVF,RTC,0			'  Overflow Interrupt enable bit position
RTC_CMP,RTC,1			'  Compare Match Interrupt enable bit position
RTC_DBGRUN,RTC,0			'  Run in debug bit position
RTC_SIGN,RTC,7			'  Error Correction Sign Bit bit position
RTC_PITEN,RTC,0			'  Enable bit position
RTC_CTRLBUSY,RTC,0			'  CTRLA Synchronization Busy Flag bit position
RTC_PI,RTC,0			'  Periodic Interrupt bit position
SLPCTRL_SEN,SLPCTRL,0			'  Sleep enable bit position
SLPCTRL_HTLLEN,SLPCTRL,4			'  High Temperature Low Leakage Enable bit position
SPI_ENABLE,SPI,0			'  Enable Module bit position
SPI_CLK2X,SPI,4			'  Enable Double Speed bit position
SPI_MASTER,SPI,5			'  Host Operation Enable bit position
SPI_DORD,SPI,6			'  Data Order Setting bit position
SPI_SSD,SPI,2			'  SPI Select Disable bit position
SPI_BUFWR,SPI,6			'  Buffer Mode Wait for Receive bit position
SPI_BUFEN,SPI,7			'  Buffer Mode Enable bit position
SPI_IE,SPI,0			'  Interrupt Enable bit position
SPI_SSIE,SPI,4			'  SPI Select Trigger Interrupt Enable bit position
SPI_DREIE,SPI,5			'  Data Register Empty Interrupt Enable bit position
SPI_TXCIE,SPI,6			'  Transfer Complete Interrupt Enable bit position
SPI_RXCIE,SPI,7			'  Receive Complete Interrupt Enable bit position
SPI_BUFOVF,SPI,0			'  Buffer Overflow bit position
SPI_SSIF,SPI,4			'  SPI Select Trigger Interrupt Flag bit position
SPI_DREIF,SPI,5			'  Data Register Empty Interrupt Flag bit position
SPI_TXCIF,SPI,6			'  Transfer Complete Interrupt Flag bit position
SPI_WRCOL,SPI,6			'  Write Collision bit position
SPI_RXCIF,SPI,7			'  Receive Complete Interrupt Flag bit position
SPI_IF,SPI,7			'  Interrupt Flag bit position
SYSCFG_VALID,SYSCFG,0			'  OCD Message Valid bit position
TCA_SINGLE_ENABLE,TCA,0			'  Module Enable bit position
TCA_SINGLE_RUNSTDBY,TCA,7			'  Run in Standby bit position
TCA_SINGLE_ALUPD,TCA,3			'  Auto Lock Update bit position
TCA_SINGLE_CMP0EN,TCA,4			'  Compare 0 Enable bit position
TCA_SINGLE_CMP1EN,TCA,5			'  Compare 1 Enable bit position
TCA_SINGLE_CMP2EN,TCA,6			'  Compare 2 Enable bit position
TCA_SINGLE_CMP0OV,TCA,0			'  Compare 0 Waveform Output Value bit position
TCA_SINGLE_CMP1OV,TCA,1			'  Compare 1 Waveform Output Value bit position
TCA_SINGLE_CMP2OV,TCA,2			'  Compare 2 Waveform Output Value bit position
TCA_SINGLE_SPLITM,TCA,0			'  Split Mode Enable bit position
TCA_SINGLE_DIR,TCA,0			'  Direction bit position
TCA_SINGLE_LUPD,TCA,1			'  Lock Update bit position
TCA_SINGLE_PERBV,TCA,0			'  Period Buffer Valid bit position
TCA_SINGLE_CMP0BV,TCA,1			'  Compare 0 Buffer Valid bit position
TCA_SINGLE_CMP1BV,TCA,2			'  Compare 1 Buffer Valid bit position
TCA_SINGLE_CMP2BV,TCA,3			'  Compare 2 Buffer Valid bit position
TCA_SINGLE_CNTAEI,TCA,0			'  Count on Event Input A bit position
TCA_SINGLE_CNTBEI,TCA,4			'  Count on Event Input B bit position
TCA_SINGLE_OVF,TCA,0			'  Overflow Interrupt bit position
TCA_SINGLE_CMP0,TCA,4			'  Compare 0 Interrupt bit position
TCA_SINGLE_CMP1,TCA,5			'  Compare 1 Interrupt bit position
TCA_SINGLE_CMP2,TCA,6			'  Compare 2 Interrupt bit position
TCA_SINGLE_DBGRUN,TCA,0			'  Debug Run bit position
TCA_SPLIT_ENABLE,for CTRLA already defined,0			'  Module Enable bit position
TCA_SPLIT_RUNSTDBY,for CTRLA already defined,7			'  Run in Standby bit position
TCA_SPLIT_LCMP0EN,TCA,0			'  Low Compare 0 Enable bit position
TCA_SPLIT_LCMP1EN,TCA,1			'  Low Compare 1 Enable bit position
TCA_SPLIT_LCMP2EN,TCA,2			'  Low Compare 2 Enable bit position
TCA_SPLIT_HCMP0EN,TCA,4			'  High Compare 0 Enable bit position
TCA_SPLIT_HCMP1EN,TCA,5			'  High Compare 1 Enable bit position
TCA_SPLIT_HCMP2EN,TCA,6			'  High Compare 2 Enable bit position
TCA_SPLIT_LCMP0OV,TCA,0			'  Low Compare 0 Output Value bit position
TCA_SPLIT_LCMP1OV,TCA,1			'  Low Compare 1 Output Value bit position
TCA_SPLIT_LCMP2OV,TCA,2			'  Low Compare 2 Output Value bit position
TCA_SPLIT_HCMP0OV,TCA,4			'  High Compare 0 Output Value bit position
TCA_SPLIT_HCMP1OV,TCA,5			'  High Compare 1 Output Value bit position
TCA_SPLIT_HCMP2OV,TCA,6			'  High Compare 2 Output Value bit position
TCA_SPLIT_SPLITM,TCA,0			'  Split Mode Enable bit position
TCA_SPLIT_LUNF,TCA,0			'  Low Underflow Interrupt Enable bit position
TCA_SPLIT_HUNF,TCA,1			'  High Underflow Interrupt Enable bit position
TCA_SPLIT_LCMP0,TCA,4			'  Low Compare 0 Interrupt Enable bit position
TCA_SPLIT_LCMP1,TCA,5			'  Low Compare 1 Interrupt Enable bit position
TCA_SPLIT_LCMP2,TCA,6			'  Low Compare 2 Interrupt Enable bit position
TCA_SPLIT_DBGRUN,TCA,0			'  Debug Run bit position
TCB_ENABLE,TCB,0			'  Enable bit position
TCB_SYNCUPD,TCB,4			'  Synchronize Update bit position
TCB_CASCADE,TCB,5			'  Cascade two timers bit position
TCB_RUNSTDBY,TCB,6			'  Run Standby bit position
TCB_CCMPEN,TCB,4			'  Pin Output Enable bit position
TCB_CCMPINIT,TCB,5			'  Pin Initial State bit position
TCB_ASYNC,TCB,6			'  Asynchronous Enable bit position
TCB_CAPTEI,TCB,0			'  Event Input Enable bit position
TCB_EDGE,TCB,4			'  Event Edge bit position
TCB_FILTER,TCB,6			'  Input Capture Noise Cancellation Filter bit position
TCB_CAPT,TCB,0			'  Capture or Timeout bit position
TCB_OVF,TCB,1			'  Overflow bit position
TCB_RUN,TCB,0			'  Run bit position
TCB_DBGRUN,TCB,0			'  Debug Run bit position
TCD_ENABLE,TCD,0			'  Enable bit position
TCD_CMPOVR,TCD,0			'  Compare output value override bit position
TCD_AUPDATE,TCD,1			'  Auto update bit position
TCD_FIFTY,TCD,3			'  Fifty percent waveform bit position
TCD_CMPCSEL,TCD,6			'  Compare C output select bit position
TCD_CMPDSEL,TCD,7			'  Compare D output select bit position
TCD_SYNCEOC,TCD,0			'  Synchronize end of cycle strobe bit position
TCD_SYNC,TCD,1			'  synchronize strobe bit position
TCD_RESTART,TCD,2			'  Restart strobe bit position
TCD_SCAPTUREA,TCD,3			'  Software Capture A Strobe bit position
TCD_SCAPTUREB,TCD,4			'  Software Capture B Strobe bit position
TCD_DISEOC,TCD,7			'  Disable at end of cycle bit position
TCD_TRIGEI,TCD,0			'  Trigger event enable bit position
TCD_ACTION,TCD,2			'  Event action bit position
TCD_EDGE,TCD,4			'  Edge select bit position
TCD_OVF,TCD,0			'  Overflow interrupt enable bit position
TCD_TRIGA,TCD,2			'  Trigger A interrupt enable bit position
TCD_TRIGB,TCD,3			'  Trigger B interrupt enable bit position
TCD_ENRDY,TCD,0			'  Enable ready bit position
TCD_CMDRDY,TCD,1			'  Command ready bit position
TCD_PWMACTA,TCD,6			'  PWM activity on A bit position
TCD_PWMACTB,TCD,7			'  PWM activity on B bit position
TCD_CMPA,TCD,0			'  Compare A value bit position
TCD_CMPB,TCD,1			'  Compare B value bit position
TCD_CMPC,TCD,2			'  Compare C value bit position
TCD_CMPD,TCD,3			'  Compare D vaule bit position
TCD_CMPAEN,TCD,4			'  Compare A enable bit position
TCD_CMPBEN,TCD,5			'  Compare B enable bit position
TCD_CMPCEN,TCD,6			'  Compare C enable bit position
TCD_CMPDEN,TCD,7			'  Compare D enable bit position
TCD_DBGRUN,TCD,0			'  Debug run bit position
TCD_FAULTDET,TCD,2			'  Fault detection bit position
TWI_FMPEN,TWI,1			'  Fast-mode Plus Enable bit position
TWI_SDASETUP,TWI,4			'  SDA Setup Time bit position
TWI_INPUTLVL,TWI,6			'  Input voltage transition level bit position
TWI_ENABLE,TWI,0			'  Enable bit position
TWI_DBGRUN,TWI,0			'  Debug Run bit position
TWI_SMEN,TWI,1			'  Smart Mode Enable bit position
TWI_QCEN,TWI,4			'  Quick Command Enable bit position
TWI_WIEN,TWI,6			'  Write Interrupt Enable bit position
TWI_RIEN,TWI,7			'  Read Interrupt Enable bit position
TWI_ACKACT,TWI,2			'  Acknowledge Action bit position
TWI_FLUSH,TWI,3			'  Flush bit position
TWI_BUSERR,TWI,2			'  Bus Error bit position
TWI_ARBLOST,TWI,3			'  Arbitration Lost bit position
TWI_RXACK,TWI,4			'  Received Acknowledge bit position
TWI_CLKHOLD,TWI,5			'  Clock Hold bit position
TWI_WIF,TWI,6			'  Write Interrupt Flag bit position
TWI_RIF,TWI,7			'  Read Interrupt Flag bit position
TWI_PMEN,TWI,2			'  Address Recognition Mode bit position
TWI_PIEN,TWI,5			'  Stop Interrupt Enable bit position
TWI_APIEN,TWI,6			'  Address or Stop Interrupt Enable bit position
TWI_DIEN,TWI,7			'  Data Interrupt Enable bit position
TWI_AP,TWI,0			'  Address or Stop bit position
TWI_DIR,TWI,1			'  Read/Write Direction bit position
TWI_COLL,TWI,3			'  Collision bit position
TWI_APIF,TWI,6			'  Address or Stop Interrupt Flag bit position
TWI_DIF,TWI,7			'  Data Interrupt Flag bit position
TWI_ADDREN,TWI,0			'  Address Mask Enable bit position
USART_DATA8,USART,0			'  Receiver Data Register bit position
USART_PERR,USART,1			'  Parity Error bit position
USART_FERR,USART,2			'  Frame Error bit position
USART_BUFOVF,USART,6			'  Buffer Overflow bit position
USART_RXCIF,USART,7			'  Receive Complete Interrupt Flag bit position
USART_WFB,USART,0			'  Wait For Break bit position
USART_BDF,USART,1			'  Break Detected Flag bit position
USART_ISFIF,USART,3			'  Inconsistent Sync Field Interrupt Flag bit position
USART_RXSIF,USART,4			'  Receive Start Interrupt bit position
USART_DREIF,USART,5			'  Data Register Empty Flag bit position
USART_TXCIF,USART,6			'  Transmit Interrupt Flag bit position
USART_RS485,USART,0			'  RS485 Mode internal transmitter bit position
USART_ABEIE,USART,2			'  Auto-baud Error Interrupt Enable bit position
USART_LBME,USART,3			'  Loop-back Mode Enable bit position
USART_RXSIE,USART,4			'  Receiver Start Frame Interrupt Enable bit position
USART_DREIE,USART,5			'  Data Register Empty Interrupt Enable bit position
USART_TXCIE,USART,6			'  Transmit Complete Interrupt Enable bit position
USART_RXCIE,USART,7			'  Receive Complete Interrupt Enable bit position
USART_MPCM,USART,0			'  Multi-processor Communication Mode bit position
USART_ODME,USART,3			'  Open Drain Mode Enable bit position
USART_SFDEN,USART,4			'  Start Frame Detection Enable bit position
USART_TXEN,USART,6			'  Transmitter Enable bit position
USART_RXEN,USART,7			'  Reciever enable bit position
USART_UCPHA,USART,1			'  SPI Host Mode, Clock Phase bit position
USART_UDORD,USART,2			'  SPI Host Mode, Data Order bit position
USART_SBMODE,USART,3			'  Stop Bit Mode bit position
USART_DBGRUN,USART,0			'  Debug Run bit position
USART_IREI,USART,0			'  IrDA Event Input Enable bit position
VREF_ALWAYSON,VREF,7			'  Always on bit position
WDT_SYNCBUSY,WDT,0			'  Syncronization busy bit position
WDT_LOCK,WDT,7			'  Lock enable bit position
ZCD_ENABLE,ZCD,0			'  Enable bit position
ZCD_INVERT,ZCD,3			'  Invert signal from pin bit position
ZCD_OUTEN,ZCD,6			'  Output Pad Enable bit position
ZCD_RUNSTDBY,ZCD,7			'  Run in Standby Mode bit position
ZCD_CROSSIF,ZCD,0			'  ZCD Interrupt Flag bit position
ZCD_STATE,ZCD,4			'  ZCD State bit position

[FreeRAM]
'This is the extent of the RAM.  Inclusive of start and end address
7000:8000

[ConfigOps]
NoConfig-PRG

[Config]
NoConfig-PRG
